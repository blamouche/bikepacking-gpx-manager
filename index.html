<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bikepacking helper - Localisez les points d'intérêt dont vous avez besoin</title>
  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    :root {
      --color-primary: #1976d2;
      --color-primary-hover: #1565c0;
      --color-secondary: #f5f5f5;
      --color-secondary-hover: #eeeeee;
      --color-danger: #f44336;
      --color-background: #ffffff;
      --color-background-alt: #f8f9fa;
      --color-text-primary: #212121;
      --color-text-secondary: #424242;
      --color-text-muted: #757575;
      --color-border: #e0e0e0;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--color-background-alt);
      color: var(--color-text-primary);
    }

    body {
      overflow: hidden;
    }

    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .hidden {
      display: none !important;
    }

    .tools-panel {
      width: 420px;
      min-width: 420px;
      height: 100vh;
      background: var(--color-background);
      border-right: 1px solid var(--color-border);
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .panel-header {
      padding: 1.5rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .panel-title {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem 1.5rem;
    }

    .panel-section {
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid var(--color-border);
    }

    .panel-section:last-child {
      border-bottom: none;
      padding-bottom: 0;
      margin-bottom: 0;
    }

    /* Calques POI */
    .layer-section {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .layer-global-actions {
      display: flex;
      gap: 0.5rem;
    }

    .layer-global-actions .btn {
      flex: 1;
    }

    .layer-presets {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .layer-presets label {
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .preset-select {
      flex: 1;
      padding: 0.45rem 0.6rem;
      border-radius: 6px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
      background: #fff;
    }

    .layer-group {
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: #fff;
      overflow: hidden;
      margin-bottom: 0.5rem;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
    }

    .layer-group-header {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem;
      background: var(--color-background-alt);
      border: none;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }

    .layer-group-header:hover {
      background: rgba(0, 0, 0, 0.03);
    }

    .layer-group-icon {
      font-size: 1.1rem;
    }

    .layer-group-label {
      flex: 1;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--color-text-primary);
      text-align: left;
    }

    .layer-group-count {
      font-size: 0.85rem;
      color: var(--color-text-muted);
    }

    .layer-group-chevron {
      font-size: 0.8rem;
      color: var(--color-text-muted);
      transition: transform 0.3s ease;
    }

    .layer-group.expanded .layer-group-chevron {
      transform: rotate(180deg);
    }

    .layer-group-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
      padding: 0 0.75rem;
    }

    .layer-group.expanded .layer-group-content {
      max-height: 1000px;
      padding: 0.75rem;
    }

    .layer-toggle {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
      user-select: none;
      padding: 0.4rem 0.25rem;
    }

    .layer-toggle + .layer-toggle {
      border-top: 1px dashed rgba(0, 0, 0, 0.05);
    }

    .toggle-input {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      background: #ccc;
      border-radius: 12px;
      transition: background 0.3s ease;
      flex-shrink: 0;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      top: 3px;
      left: 3px;
      transition: transform 0.3s ease;
    }

    .toggle-input:checked + .toggle-switch {
      background: var(--color-primary);
    }

    .toggle-input:checked + .toggle-switch::after {
      transform: translateX(20px);
    }

    .toggle-input:focus + .toggle-switch {
      outline: 2px solid var(--color-primary);
      outline-offset: 2px;
    }

    .toggle-text {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--color-text-primary);
      flex: 1;
    }

    .toggle-icon {
      font-size: 1.1rem;
    }

    .toggle-count {
      font-size: 0.85rem;
      color: var(--color-text-muted);
      font-weight: 600;
    }

    .layer-indicators {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .layer-loading,
    .layer-error,
    .layer-info,
    .layer-total {
      padding: 0.6rem 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      display: none;
    }

    .layer-loading {
      background: #e3f2fd;
      color: #1976d2;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .layer-error {
      background: #ffebee;
      color: #c62828;
      border: 1px solid rgba(198, 40, 40, 0.2);
    }

    .layer-info {
      background: #fff8e1;
      color: #f57f17;
      border: 1px solid rgba(245, 127, 23, 0.2);
    }

    .layer-total {
      background: var(--color-background-alt);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
    }

    .layer-count-value {
      color: var(--color-primary);
      font-weight: 700;
      font-size: 1rem;
    }

    .layer-loading .loading-spinner {
      display: inline-block;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .section-title {
      margin: 0 0 1rem 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 1.75rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: var(--color-primary);
      color: #fff;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      width: 100%;
      border: none;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      transition: box-shadow 0.2s ease, transform 0.1s ease;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    .btn-primary {
      background: var(--color-primary);
      color: #ffffff;
    }

    .btn-primary:not(:disabled):hover,
    .btn-primary:not(:disabled):focus {
      background: var(--color-primary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-secondary {
      background: var(--color-secondary);
      color: var(--color-text-secondary);
    }

    .btn-secondary:hover,
    .btn-secondary:focus {
      background: var(--color-secondary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-small {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
    }

    .btn-icon-small {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 1rem;
      padding: 0.25rem;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .btn-icon-small:hover,
    .btn-icon-small:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .import-actions {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .file-info {
      margin-top: 1rem;
      padding: 0.75rem;
      border-radius: 6px;
      background: var(--color-background-alt);
      border: 1px solid var(--color-border);
    }

    .file-info small {
      display: block;
      color: var(--color-text-muted);
      margin-bottom: 0.25rem;
    }

    .filename {
      margin: 0;
      font-weight: 600;
      color: var(--color-text-primary);
      word-break: break-all;
    }

    .file-name-input {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
      margin-top: 0.75rem;
    }

    .drop-zone {
      margin-top: 1rem;
      padding: 1rem;
      border: 2px dashed var(--color-border);
      border-radius: 8px;
      text-align: center;
      color: var(--color-text-muted);
      background: #fff;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .drop-zone.dragover {
      border-color: var(--color-primary);
      background: rgba(25, 118, 210, 0.08);
      color: var(--color-text-primary);
    }

    .waypoints-list {
      max-height: 240px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .waypoint-item {
      display: grid;
      grid-template-columns: auto 1fr auto auto;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.6rem;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: #fff;
      box-shadow: var(--shadow-sm);
    }

    .waypoint-popup {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 200px;
    }

    .waypoint-popup label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .waypoint-popup input {
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
    }

    .waypoint-popup-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .waypoint-popup-buttons button {
      flex: 1;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: var(--color-secondary);
    }

    .waypoint-popup-buttons button[data-action="save"] {
      background: var(--color-primary);
      color: #fff;
    }

    .waypoint-popup-buttons button[data-action="delete"] {
      background: var(--color-danger);
      color: #fff;
    }

    .waypoint-name {
      font-size: 0.95rem;
      color: var(--color-text-primary);
    }

    .waypoint-icon {
      font-size: 1.1rem;
    }

    .info-list {
      margin: 0;
      display: grid;
      grid-template-columns: auto 1fr;
      row-gap: 0.75rem;
      column-gap: 1rem;
      font-size: 0.95rem;
    }

    .info-list dt {
      font-weight: 600;
      color: var(--color-text-secondary);
    }

    .info-list dd {
      margin: 0;
      color: var(--color-text-primary);
    }

    .text-muted {
      color: var(--color-text-muted);
    }

    .trace-name {
      font-weight: 600;
      font-size: 1rem;
      word-break: break-word;
    }

    .trace-name--gpx-track,
    .trace-name--gpx-route,
    .trace-name--gpx-metadata {
      color: var(--color-primary);
    }

    .trace-name--filename {
      color: var(--color-text-muted);
      font-style: italic;
    }

    .trace-name--default {
      color: #9e9e9e;
      font-style: italic;
    }

    .file-name {
      font-family: "Courier New", Courier, monospace;
      font-size: 0.9rem;
      color: var(--color-text-muted);
      word-break: break-all;
    }

    .trace-name-help {
      font-size: 1rem;
      cursor: help;
      color: var(--color-text-muted);
      display: inline-block;
      margin-left: 0.35rem;
    }

    .stat-highlight {
      font-weight: 600;
      color: var(--color-primary);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .elevation-profile {
      position: relative;
      width: 100%;
      background: var(--color-background);
      border-top: 2px solid var(--color-primary);
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
      display: none;
      flex-direction: column;
      z-index: 500;
      transition: height 0.3s ease;
      height: 200px;
    }

    .elevation-profile.visible {
      display: flex;
    }

    .elevation-profile.collapsed {
      height: 40px;
    }

    .elevation-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.75rem 1rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      cursor: pointer;
      user-select: none;
      min-height: 40px;
    }

    .elevation-header:hover {
      background: rgba(0, 0, 0, 0.02);
    }

    .elevation-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .elevation-title h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .elevation-icon {
      font-size: 1.25rem;
    }

    .elevation-stats-quick {
      display: flex;
      gap: 1.5rem;
      flex: 1;
      justify-content: center;
    }

    .stat-item {
      display: flex;
      gap: 0.25rem;
      font-size: 0.9rem;
    }

    .stat-label {
      color: var(--color-text-muted);
    }

    .stat-value {
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .btn-collapse {
      border: none;
      background: transparent;
      font-size: 1rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .btn-collapse:hover,
    .btn-collapse:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .elevation-profile.collapsed .btn-collapse span {
      transform: rotate(180deg);
      display: inline-block;
    }

    .elevation-content {
      flex: 1;
      position: relative;
      overflow: hidden;
      padding: 1rem;
      display: none;
    }

    .elevation-profile:not(.collapsed) .elevation-content {
      display: block;
    }

    #elevation-canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .elevation-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .tooltip-row {
      display: flex;
      gap: 0.5rem;
      white-space: nowrap;
    }

    /* Marqueurs POI OSM */
    .poi-marker {
      border: none !important;
      background: transparent !important;
    }

    .poi-marker-inner {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      border: 2px solid #fff;
      transition: transform 0.2s ease;
    }

    .poi-marker:hover .poi-marker-inner {
      transform: scale(1.15);
    }

    .poi-marker-icon {
      font-size: 14px;
      line-height: 1;
      filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
    }

    .poi-popup-container .leaflet-popup-content-wrapper {
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .poi-popup {
      font-family: inherit;
      min-width: 220px;
    }

    .poi-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--color-border);
      margin-bottom: 0.75rem;
    }

    .poi-header .poi-icon {
      font-size: 1.5rem;
    }

    .poi-name {
      font-size: 1rem;
      color: var(--color-text-primary);
    }

    .poi-details {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .poi-row {
      display: flex;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .poi-label {
      color: var(--color-text-muted);
      min-width: 70px;
    }

    .poi-value {
      color: var(--color-text-primary);
      font-weight: 500;
    }

    .poi-footer {
      padding-top: 0.5rem;
      border-top: 1px solid var(--color-border);
    }

    .poi-footer a {
      color: var(--color-primary);
      text-decoration: none;
      font-size: 0.85rem;
    }

    .poi-footer a:hover {
      text-decoration: underline;
    }

    .tooltip-label {
      color: rgba(255, 255, 255, 0.7);
    }

    .tooltip-value {
      font-weight: 600;
    }

    @media (max-width: 767px) {
      .layer-global-actions {
        flex-direction: column;
      }

      .layer-presets {
        flex-direction: column;
        align-items: stretch;
        gap: 0.35rem;
      }

      .layer-presets label {
        font-size: 0.85rem;
      }

      .elevation-profile {
        height: 150px;
      }

      .elevation-stats-quick {
        display: none;
      }

      .elevation-header {
        padding: 0.5rem 0.75rem;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .elevation-stats-quick {
        gap: 1rem;
        font-size: 0.85rem;
      }
    }

    .panel-messages {
      padding: 0;
    }

    .message {
      min-height: 3rem;
      padding: 0.75rem 1rem;
      border-radius: 6px;
      border: 1px solid transparent;
      background: #f1f8ff;
      color: #0d47a1;
    }

    .message.hidden {
      display: none;
    }

    .message.error {
      background: #ffebee;
      border-color: rgba(244, 67, 54, 0.3);
      color: #c62828;
    }

    .map-container {
      flex: 1;
      position: relative;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .map-main {
      position: relative;
      flex: 1;
      min-height: 0;
    }

    .poi-refresh-button {
      position: absolute;
      z-index: 900;
      top: 3.25rem;
      display: none;
      align-items: center;
      gap: 0.4rem;
      padding: 0.6rem 0.85rem;
      background: rgba(25, 118, 210, 0.95);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      box-shadow: var(--shadow-md);
      cursor: pointer;
      transition: background 0.2s ease, transform 0.1s ease;
    
      left: 50%;
      transform: translateX(-50%);}

    .poi-refresh-button:hover,
    .poi-refresh-button:focus {
      background: rgba(21, 101, 192, 0.95);
      transform: translateX(-50%) translateY(-1px);
      outline: none;
    }

    .poi-refresh-button span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .btn-menu {
      display: none;
      position: absolute;
      top: 1rem;
      left: 1rem;
      z-index: 1000;
      background: #fff;
      border: 2px solid var(--color-border);
      border-radius: 6px;
      padding: 0.6rem 0.8rem;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: var(--shadow-md);
    }

    .btn-close-panel {
      border: none;
      background: transparent;
      font-size: 1.25rem;
      cursor: pointer;
      border-radius: 4px;
      padding: 0.2rem 0.4rem;
    }

    .btn-close-panel:hover,
    .btn-close-panel:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .panel-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      z-index: 1500;
      opacity: 0;
      animation: fadeIn 0.2s forwards;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    @media (max-width: 767px) {
      .tools-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 90vw;
        max-width: 420px;
        z-index: 2000;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }

      .tools-panel.open {
        transform: translateX(0);
      }

      .btn-menu {
        display: block;
      }
    }

    @media (min-width: 768px) {
      .btn-close-panel {
        display: none;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .tools-panel {
        width: 280px;
        min-width: 280px;
      }
    }
  
/* === Layer indicators overrides merged === */

/* === Waypoint Markers === */
.waypoint-marker {
  border: none !important;
  background: transparent !important;
}

.waypoint-marker-inner {
  width: 28px;
  height: 36px;
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
  filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
}

.waypoint-marker-pin {
  width: 28px;
  height: 28px;
  background: #FF5722;
  border-radius: 50% 50% 50% 0;
  transform: rotate(-45deg);
  border: 3px solid #FFFFFF;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.waypoint-marker-icon {
  transform: rotate(45deg);
  font-size: 14px;
  line-height: 1;
}

.waypoint-marker:hover .waypoint-marker-inner {
  transform: scale(1.15) translateY(-3px);
  filter: drop-shadow(0 6px 12px rgba(255, 87, 34, 0.5));
}

@keyframes waypointAppear {
  from { opacity: 0; transform: scale(0.3) translateY(10px); }
  to   { opacity: 1; transform: scale(1) translateY(0); }
}

.waypoint-marker-inner {
  animation: waypointAppear 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}


/* === Map Style Control === */

/* Contrôle principal (positionné par Leaflet) */
.leaflet-map-style-control {
  position: absolute;
  top: 90px; /* Sous les contrôles de zoom (80px) + marge */
  right: 10px;
  z-index: 1000;
}

/* Bouton toggle */
.map-style-toggle {
  width: 30px;
  height: 30px;
  background: #FFFFFF;
  border: 2px solid rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  transition: all 0.2s ease;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
}

.map-style-toggle:hover {
  background: #F7F8FA;
  border-color: rgba(0, 0, 0, 0.3);
}

.map-style-toggle:active {
  transform: scale(0.95);
}

.map-style-toggle .map-style-icon {
  font-size: 16px;
  line-height: 1;
}

/* Panel déroulant */
.map-style-panel {
  position: absolute;
  top: 0;
  right: 40px; /* Aligné à droite du bouton */
  width: 200px;
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: blur(10px);
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
  overflow: hidden;
  animation: mapStylePanelAppear 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  border: 1px solid var(--color-border-light, rgba(0,0,0,0.12));
}

@keyframes mapStylePanelAppear {
  from { opacity: 0; transform: translateX(10px); }
  to   { opacity: 1; transform: translateX(0); }
}

/* Header du panel */
.map-style-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1rem;
  background: var(--color-background-alt, #FAFBFC);
  border-bottom: 1px solid var(--color-border-light, rgba(0,0,0,0.08));
}

.map-style-header .map-style-icon {
  font-size: 18px;
  line-height: 1;
}

.map-style-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--color-text-primary, #111);
}

/* Sections */
.map-style-section { padding: 0.5rem 0; }
.map-style-section + .map-style-section { border-top: 1px solid var(--color-border-light, rgba(0,0,0,0.08)); }

.map-style-section-title {
  padding: 0.5rem 1rem 0.25rem;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--color-text-muted, #666);
}

/* Options de style */
.map-style-option {
  width: 100%;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.625rem 1rem;
  background: transparent;
  border: none;
  cursor: pointer;
  transition: background 0.15s ease;
  text-align: left;
}

.map-style-option:hover { background: #F7F8FA; }
.map-style-option:active { background: #E8EAED; }

/* Checkmark (visible uniquement pour l'option active) */
.map-style-check {
  width: 16px;
  font-size: 14px;
  color: var(--color-primary, #0066FF);
  font-weight: 700;
  opacity: 0;
  transition: opacity 0.15s ease;
}

.map-style-option.active .map-style-check { opacity: 1; }

/* Label */
.map-style-label {
  flex: 1;
  font-size: 14px;
  font-weight: 500;
  color: var(--color-text-primary, #111);
}
.map-style-option.active .map-style-label {
  font-weight: 600;
  color: var(--color-primary, #0066FF);
}

/* Badge recommandé */
.map-style-badge { font-size: 12px; line-height: 1; }

/* Responsive mobile */
@media (max-width: 767px) {
  .leaflet-map-style-control { top: auto; bottom: 1rem; right: 1rem; }
  .map-style-panel { right: auto; left: 0; bottom: 45px; }
  .map-style-panel::before {
    content: '';
    position: fixed;
    inset: 0;
    z-index: -1;
    background: rgba(0, 0, 0, 0.2);
    animation: fadeIn 0.2s;
  }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  .map-style-toggle { background: #2C2C2E; border-color: rgba(255, 255, 255, 0.2); }
  .map-style-toggle:hover { background: #3A3A3C; }
  .map-style-panel { background: rgba(44, 44, 46, 0.98); border-color: rgba(255, 255, 255, 0.1); }
  .map-style-header { background: #1C1C1E; border-bottom-color: rgba(255, 255, 255, 0.1); }
  .map-style-title, .map-style-label { color: #FFFFFF; }
  .map-style-section { border-top-color: rgba(255, 255, 255, 0.1); }
  .map-style-option:hover { background: rgba(255, 255, 255, 0.1); }
  .map-style-option:active { background: rgba(255, 255, 255, 0.15); }
}

</style>

<!-- Modern Compact UI Overrides -->
<style>
:root {
  /* Couleurs primaires - Bleu moderne plus saturé */
  --color-primary: #0066FF;
  --color-primary-hover: #0052CC;
  --color-primary-light: #E6F0FF;
  
  /* Couleurs secondaires - Gris modernes */
  --color-secondary: #F7F8FA;
  --color-secondary-hover: #E8EAED;
  
  /* Couleurs de danger */
  --color-danger: #FF3B30;
  --color-danger-hover: #E62E24;
  
  /* Backgrounds */
  --color-background: #FFFFFF;
  --color-background-alt: #FAFBFC;
  --color-background-elevated: #FFFFFF;
  
  /* Textes */
  --color-text-primary: #1A1A1A;
  --color-text-secondary: #4A4A4A;
  --color-text-muted: #8E8E93;
  
  /* Bordures */
  --color-border: #E5E5EA;
  --color-border-light: #F2F2F7;
  
  /* Ombres modernisées */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
  
  /* Bordures arrondies plus subtiles */
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;
  
  /* Espacements compacts */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 0.75rem;
  --spacing-lg: 1rem;
  --spacing-xl: 1.5rem;
}

/* 2. Typographie modernisée */
html, body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  font-size: 14px;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.panel-title {
  font-size: 1.25rem;
  font-weight: 700;
  letter-spacing: -0.02em;
}

.section-title {
  font-size: 0.95rem;
  font-weight: 600;
  letter-spacing: -0.01em;
  text-transform: uppercase;
  color: var(--color-text-muted);
}

/* 3. Panneau latéral compact */
.panel-header {
  padding: 1rem 1.25rem;
  background: var(--color-background);
  border-bottom: 1px solid var(--color-border-light);
  backdrop-filter: blur(10px);
}

.panel-content {
  padding: 0.75rem 1rem;
}

.panel-section {
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--color-border-light);
}

.tools-panel {
  width: 280px;
  min-width: 280px;
}

@media (min-width: 768px) and (max-width: 1023px) {
  .tools-panel {
    width: 260px;
    min-width: 260px;
  }
}

/* 4. Boutons modernisés */
.btn {
  padding: 0.625rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  border-radius: var(--radius-md);
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  border: none;
  cursor: pointer;
}

.btn:not(:disabled):active {
  transform: scale(0.98);
}

.btn-primary {
  background: var(--color-primary);
  color: #FFFFFF;
  box-shadow: 0 1px 3px rgba(0, 102, 255, 0.2);
}

.btn-primary:not(:disabled):hover {
  background: var(--color-primary-hover);
  box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
  transform: translateY(-1px);
}

.btn-secondary {
  background: var(--color-secondary);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
}

.btn-small {
  padding: 0.375rem 0.75rem;
  font-size: 0.8125rem;
}

/* 5. Cartes et conteneurs modernisés */
.layer-group {
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-md);
  background: var(--color-background-elevated);
  overflow: hidden;
  margin-bottom: 0.5rem;
  box-shadow: var(--shadow-sm);
  transition: all 0.2s ease;
}

.layer-group:hover {
  box-shadow: var(--shadow-md);
}

.layer-group-header {
  padding: 0.625rem 0.75rem;
  background: var(--color-background-alt);
  border: none;
  transition: background 0.15s ease;
}

.layer-group-content {
  padding: 0 0.75rem;
}

.layer-group.expanded .layer-group-content {
  padding: 0.625rem 0.75rem;
}

/* File info modernisé */
.file-info {
  margin-top: 0.75rem;
  padding: 0.75rem;
  border-radius: var(--radius-md);
  background: var(--color-background-alt);
  border: 1px solid var(--color-border-light);
}

/* 6. Toggles et contrôles modernisés */
.toggle-switch {
  width: 40px;
  height: 22px;
  border-radius: 11px;
  background: #E5E5EA;
}

.toggle-switch::after {
  width: 16px;
  height: 16px;
  top: 3px;
  left: 3px;
}

.toggle-input:checked + .toggle-switch::after {
  transform: translateX(18px);
}

.layer-toggle {
  padding: 0.375rem 0.25rem;
  gap: 0.625rem;
}

.toggle-text {
  font-size: 0.875rem;
}

.toggle-icon {
  font-size: 1rem;
}

/* 7. Waypoints et listes compactes */
.waypoints-list {
  max-height: 200px;
  gap: 0.375rem;
}

.waypoint-item {
  padding: 0.5rem;
  gap: 0.5rem;
  border-radius: var(--radius-md);
  background: var(--color-background-elevated);
  border: 1px solid var(--color-border-light);
}

/* 8. Info-list modernisée */
.info-list {
  grid-template-columns: auto 1fr;
  row-gap: 0.625rem;
  column-gap: 0.75rem;
  font-size: 0.875rem;
}

.info-list dt {
  font-weight: 600;
  font-size: 0.8125rem;
  color: var(--color-text-muted);
}

/* 9. Badge modernisé */
.badge {
  min-width: 1.5rem;
  padding: 0.125rem 0.375rem;
  border-radius: 999px;
  background: var(--color-primary);
  color: #FFFFFF;
  font-size: 0.75rem;
  font-weight: 600;
  box-shadow: 0 1px 3px rgba(0, 102, 255, 0.2);
}

/* 10. Profil d'élévation compact */
.elevation-profile {
  height: 180px;
}

.elevation-header {
  padding: 0.625rem 1rem;
  min-height: 36px;
}

.elevation-title h3 {
  font-size: 0.9375rem;
  font-weight: 600;
}

.elevation-stats-quick {
  gap: 1.25rem;
}

.stat-item {
  font-size: 0.8125rem;
}

@media (max-width: 767px) {
  .elevation-profile {
    height: 140px;
  }
}

/* 11. Bouton POI refresh modernisé */
.poi-refresh-button {
  left: 50%;
  top: 1rem;
  transform: translateX(-50%);
  padding: 0.5rem 0.875rem;
  background: rgba(0, 102, 255, 0.95);
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
  backdrop-filter: blur(10px);
}

.poi-refresh-button:hover {
  background: rgba(0, 82, 204, 0.95);
  transform: translateX(-50%) translateY(-2px);
  box-shadow: 0 6px 16px rgba(0, 102, 255, 0.4);
}

/* 12. Indicateurs et messages compacts */
.layer-loading,
.layer-error,
.layer-info,
.layer-total {
  padding: 0.5rem 0.625rem;
  border-radius: var(--radius-md);
  font-size: 0.8125rem;
}

.layer-loading {
  background: var(--color-primary-light);
  color: var(--color-primary);
}

.message {
  min-height: 2.5rem;
  padding: 0.625rem 0.875rem;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
}

/* 13. Drop zone modernisée */
.drop-zone {
  margin-top: 0.75rem;
  padding: 1rem;
  border: 2px dashed var(--color-border);
  border-radius: var(--radius-lg);
  background: var(--color-background-alt);
  transition: all 0.2s ease;
}

.drop-zone.dragover {
  border-color: var(--color-primary);
  background: var(--color-primary-light);
  transform: scale(1.01);
}

/* 14. Popups POI modernisés */
.poi-popup-container .leaflet-popup-content-wrapper {
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  padding: 0;
}

.poi-popup {
  font-size: 0.875rem;
  min-width: 200px;
}

.poi-header {
  padding-bottom: 0.625rem;
  margin-bottom: 0.625rem;
}

.poi-details {
  gap: 0.375rem;
  margin-bottom: 0.625rem;
}

.poi-row {
  font-size: 0.8125rem;
}

/* 15. Animations fluides */
* {
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

.layer-group,
.waypoint-item,
.poi-marker {
  animation: fadeIn 0.2s ease-out;
}

/* 16. Scrollbars modernisées */
.panel-content::-webkit-scrollbar,
.waypoints-list::-webkit-scrollbar {
  width: 6px;
}

.panel-content::-webkit-scrollbar-track,
.waypoints-list::-webkit-scrollbar-track {
  background: transparent;
}

.panel-content::-webkit-scrollbar-thumb,
.waypoints-list::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: 3px;
}

.panel-content::-webkit-scrollbar-thumb:hover,
.waypoints-list::-webkit-scrollbar-thumb:hover {
  background: var(--color-text-muted);
}
</style>

<!-- Layer Indicators on Map Overrides -->
<style>
/* 1) Container des indicateurs - arraché du panneau et centré en haut de la carte */
.panel-section .layer-indicators {
  /* Retirer du flux normal du panneau */
  position: absolute;

  /* Positionnement centré en haut de la carte */
  left: 50%;
  top: 1rem;
  transform: translateX(-50%);

  /* Z-index supérieur au bouton POI (900) mais inférieur aux popups */
  z-index: 950;

  /* Largeur adaptative */
  max-width: 500px;
  width: calc(100vw - 2rem);

  /* Espacement entre les indicateurs */
  display: flex;
  flex-direction: column;
  gap: 0.5rem;

  /* Permettre le clic à travers si vide */
  pointer-events: none;
}

/* Restaurer pointer-events sur les éléments visibles */
.layer-loading,
.layer-error,
.layer-info,
.layer-zoom-info,
.layer-total {
  pointer-events: auto;
}

/* 2) Styles modernisés des indicateurs */
.layer-loading {
  display: none; /* caché par défaut */
  align-items: center;
  gap: 0.5rem;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  font-weight: 500;

  /* Glassmorphism */
  background: rgba(0, 102, 255, 0.95);
  color: #FFFFFF;
  backdrop-filter: blur(10px);

  /* Ombre */
  box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);

  /* Animation */
  animation: slideDown 0.3s ease-out;
}

/* keyframes communs */
@keyframes slideDown {
  from { opacity: 0; transform: translateY(-10px); }
  to   { opacity: 1; transform: translateY(0); }
}

@keyframes slideUp {
  from { opacity: 1; transform: translateY(0); }
  to   { opacity: 0; transform: translateY(-10px); }
}

.layer-error {
  display: none;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 59, 48, 0.95);
  color: #FFFFFF;
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
  animation: slideDown 0.3s ease-out;
}

.layer-info {
  display: none;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 149, 0, 0.95);
  color: #FFFFFF;
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(255, 149, 0, 0.3);
  animation: slideDown 0.3s ease-out;
}

/* Le HTML existant utilise id="layers-zoom-info" avec la classe .layer-info.
   On applique donc le style "zoom-info" sur cet id pour respecter la spec,
   sans modifier le JS/HTML. */
#layers-zoom-info {
  display: none;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 204, 0, 0.95);
  color: #1A1A1A;
  border: 1px solid rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(255, 204, 0, 0.3);
  animation: slideDown 0.3s ease-out;
}

/* 3) Bouton POI : déjà centré. On confirme la hiérarchie (z-index: 900) */
.poi-refresh-button {
  position: absolute;
  z-index: 900; /* Inférieur aux indicateurs */
  left: 50%;
  top: 1rem;
  transform: translateX(-50%);
  transition: transform 0.3s ease, top 0.3s ease;
}

/* 4) Compteur total POI : overlay sous les indicateurs */
.layer-total {
  display: none; /* caché par défaut */
  align-items: center;
  justify-content: space-between;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 255, 255, 0.95);
  color: var(--color-text-primary);
  border: 1px solid var(--color-border-light);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  animation: slideDown 0.3s ease-out;

  /* Position fixe pour apparaître sur la carte, sous les indicateurs */
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  z-index: 950;
  top: 4.25rem; /* espace sous la ligne des indicateurs */
}

.layer-count-value {
  color: var(--color-primary);
  font-weight: 700;
  font-size: 1.125rem;
}

/* 5) Responsive mobile */
@media (max-width: 767px) {
  .panel-section .layer-indicators {
    top: 4.5rem; /* sous le bouton menu mobile */
    left: 1rem;
    right: 1rem;
    transform: none;
    width: auto;
    max-width: none;
  }

  .layer-loading,
  .layer-error,
  .layer-info,
  #layers-zoom-info,
  .layer-total {
    padding: 0.5rem 0.75rem;
    font-size: 0.8125rem;
  }

  .poi-refresh-button {
    top: 1rem;
  }

  .layer-total {
    left: 1rem;
    right: 1rem;
    transform: none;
    top: 7.25rem; /* sous la zone d'indicateurs sur mobile */
  }
}

/* 6) Gestion du panneau ouvert sur mobile : éviter chevauchement */
@media (max-width: 767px) {
  .tools-panel.open ~ .map-container .map-main::after {
    /* pseudo repère (aucun rendu) */
    content: '';
  }
  /* Les indicateurs étant positionnés fixed depuis le panneau, on ajuste avec l'état du panneau */
  .tools-panel.open .panel-section .layer-indicators {
    left: calc(85vw + 1rem);
    right: 1rem;
    width: auto;
    transform: none;
  }

  @media (max-width: 480px) {
    .tools-panel.open .panel-section .layer-indicators {
      opacity: 0;
      pointer-events: none;
    }
  }
}

/* 7) Animations d'apparition lorsqu'ils passent à display: ... */
.layer-loading[style*="display: flex"],
.layer-error[style*="display: block"],
.layer-info[style*="display: block"],
#layers-zoom-info[style*="display: block"],
.layer-total[style*="display: flex"] {
  animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* 8) Spinner de chargement */
.layer-loading .loading-spinner {
  display: inline-block;
  animation: spin 1s linear infinite;
  font-size: 1rem;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to   { transform: rotate(360deg); }
}

/* 9) Icônes/visuels via pseudo-éléments */
.layer-error::before { content: "⚠️ "; }
.layer-info::before { content: "ℹ️ "; }
/* zoom-info déjà traité via #layers-zoom-info ; ajout d'icône via ::before */
#layers-zoom-info::before { content: "🔍 "; }

/* 10) Accessibilité (focus visible) */
.layer-error:focus-within,
.layer-info:focus-within,
#layers-zoom-info:focus-within {
  outline: 2px solid rgba(255, 255, 255, 0.5);
  outline-offset: 2px;
}

/* 11) Dark mode */
@media (prefers-color-scheme: dark) {
  .layer-loading { background: rgba(10, 132, 255, 0.95); }
  .layer-error { background: rgba(255, 69, 58, 0.95); }
  .layer-info { background: rgba(255, 159, 10, 0.95); }
  #layers-zoom-info { background: rgba(255, 214, 10, 0.95); color: #1A1A1A; }
  .layer-total {
    background: rgba(28, 28, 30, 0.95);
    color: #FFFFFF;
    border-color: rgba(255, 255, 255, 0.15);
  }
}
</style>


<!-- Center & Stack Indicators Override -->
<style>
/* Center the indicators container (relative to viewport for consistency) */
.panel-section .layer-indicators {
  position: fixed !important;       /* ensure not relative to panel */
  left: 50% !important;
  top: 1rem !important;
  transform: translateX(-50%) !important;
  max-width: 500px !important;
  width: auto !important;           /* shrink to content */
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;   /* center children horizontally */
  gap: 0.5rem !important;
  pointer-events: none !important;
}

/* Make each message box intrinsically sized and centered */
.layer-loading,
.layer-error,
.layer-info,
#layers-zoom-info,
.layer-total {
  width: max-content;               /* fit content width */
  max-width: 90vw;                  /* avoid overflow */
  text-align: center;
  pointer-events: auto;
}

/* Ensure the total counter stacks with others (not absolutely positioned) */
.layer-total {
  position: static !important;
  left: auto !important;
  top: auto !important;
  transform: none !important;
}

/* Give the POI refresh button room below stacked indicators */
.poi-refresh-button {
  top: 3.75rem !important;          /* slightly lower to clear stacked messages */
}

@media (max-width: 767px) {
  .panel-section .layer-indicators {
    top: 4.5rem !important;
  }
  .poi-refresh-button {
    top: 1rem !important;
  }
}
</style>


<!-- === Empilement vertical des indicateurs & bouton POI (CSS + JS) === -->
<style>
/* 1) Pile virtuelle centrée : on utilise .layer-indicators comme pile fixe */
.layer-indicators {
  position: fixed !important;
  top: 1rem !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  z-index: 950 !important;
  max-width: 500px !important;
  width: min(500px, calc(100vw - 2rem)) !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  gap: 0.5rem !important;
  pointer-events: none !important;
}

/* Les enfants redeviennent interactifs et prennent la largeur de la pile */
.layer-indicators > .layer-loading,
.layer-indicators > .layer-error,
.layer-indicators > .layer-info,
.layer-indicators > #layers-zoom-info,
.layer-indicators > .layer-zoom-info,
.layer-indicators > .layer-total {
  pointer-events: auto;
  width: 100%;
  text-align: center;
}

/* 3) Styles communs (au cas où non appliqués ailleurs) */
.layer-loading,
.layer-error,
.layer-info,
.layer-zoom-info,
#layers-zoom-info,
.layer-total {
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  font-weight: 500;
  animation: slideDown 0.3s cubic-bezier(0.4,0,0.2,1);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

/* Variantes couleurs (rappel) */
.layer-loading { background: rgba(0,102,255,0.95); color:#fff; border:1px solid rgba(255,255,255,0.2); }
.layer-error   { background: rgba(255,59,48,0.95); color:#fff; border:1px solid rgba(255,255,255,0.2); }
.layer-info    { background: rgba(255,149,0,0.95); color:#fff; border:1px solid rgba(255,255,255,0.2); }
.layer-zoom-info, #layers-zoom-info { background: rgba(255,204,0,0.95); color:#1A1A1A; border:1px solid rgba(255,255,255,0.3); }
.layer-total   { background: rgba(255,255,255,0.95); color: var(--color-text-primary, #1A1A1A); border:1px solid var(--color-border-light, rgba(0,0,0,0.08)); }

/* Padding standard des boîtes */
.layer-loading, .layer-error, .layer-info, .layer-zoom-info, #layers-zoom-info, .layer-total {
  padding: 0.625rem 1rem;
}

/* 5) Bouton POI : centré et positionné sous la pile dynamique */
.poi-refresh-button {
  position: fixed !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  z-index: 949 !important; /* juste sous les boîtes */
  transition: top 0.25s cubic-bezier(0.4,0,0.2,1);
  white-space: nowrap;
}

/* 7) Responsive */
@media (max-width: 767px) {
  .layer-indicators {
    top: 4.5rem !important;
    left: 1rem !important;
    right: 1rem !important;
    transform: none !important;
    max-width: none !important;
    width: auto !important;
    align-items: stretch !important;
  }
  .poi-refresh-button {
    /* Le JS ajustera top; on garde centré par défaut si assez de place */
  }
  .layer-loading, .layer-error, .layer-info, .layer-zoom-info, #layers-zoom-info, .layer-total {
    padding: 0.5rem 0.75rem;
    font-size: 0.8125rem;
  }
}

/* Animations */
@keyframes slideDown {
  from { opacity:0; transform: translateY(-10px); }
  to   { opacity:1; transform: translateY(0); }
}
</style>

<script>
// === Empilement dynamique : calcule la hauteur totale des indicateurs visibles
(function() {
  function isVisible(el) {
    if (!el) return false;
    const cs = getComputedStyle(el);
    return cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0';
  }

  function updateButtonPosition() {
    const stack = document.querySelector('.layer-indicators');
    const btn = document.querySelector('.poi-refresh-button');
    if (!stack || !btn) return;

    // Mesurer uniquement les éléments visibles dans la pile
    const items = Array.from(stack.children).filter(isVisible);
    const gap = parseFloat(getComputedStyle(stack).gap || '8'); // px
    const stackTop = stack.getBoundingClientRect().top + window.scrollY; // position initiale top

    // Hauteur totale = somme des hauteurs + gaps
    let total = 0;
    items.forEach((el, idx) => {
      total += el.offsetHeight;
      if (idx < items.length - 1) total += gap;
    });

    // Positionner le bouton sous la pile (si pile vide, coller au top de la pile)
    const topPx = Math.round((stackTop || 16) + total);
    btn.style.top = topPx + 'px';
  }

  // Observer les mutations de visibilité/changement de texte/contenu
  const observer = new MutationObserver(() => {
    requestAnimationFrame(updateButtonPosition);
  });

  function init() {
    const stack = document.querySelector('.layer-indicators');
    const btn = document.querySelector('.poi-refresh-button');
    if (!stack || !btn) return;

    observer.observe(stack, { attributes: true, childList: true, subtree: true, attributeFilter: ['style', 'class'] });

    // Ajuster à l'ouverture/fermeture du panneau (resize / orientation)
    window.addEventListener('resize', () => requestAnimationFrame(updateButtonPosition));
    window.addEventListener('orientationchange', () => requestAnimationFrame(updateButtonPosition));

    // Premier calcul
    updateButtonPosition();

    // Exposer une fonction globale légère si le code existant veut forcer un recalcul
    window.__updatePoiButtonPosition = updateButtonPosition;
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

// === Map Style Control ===

// Définitions des fonds de carte gratuits (100% sans clé API)
const mapStyles = {
  cyclosm: {
    name: 'CyclOSM',
    url: 'https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png',
    attribution: '&copy; OpenStreetMap | CyclOSM',
    maxZoom: 20
  },
  osm: {
    name: 'OpenStreetMap',
    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    attribution: '&copy; OpenStreetMap contributors',
    maxZoom: 19
  },
  topo: {
    name: 'OpenTopoMap',
    url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
    attribution: '&copy; OpenStreetMap | OpenTopoMap',
    maxZoom: 17
  },
  voyager: {
    name: 'CARTO Voyager',
    url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
    attribution: '&copy; OpenStreetMap | CARTO',
    maxZoom: 20
  },  satellite: {
    name: 'Esri Imagery',
    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    attribution: '&copy; Esri, Maxar, Earthstar Geographics',
    maxZoom: 19
  },
  hybrid: {
    name: 'Esri Hybrid',
    layers: [
      { url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', maxZoom: 19 },
      { url: 'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', maxZoom: 19 }
    ],
    attribution: '&copy; Esri, Maxar, Earthstar Geographics',
    maxZoom: 19
  }
};

// État du contrôle
const mapStyleControl = {
  currentStyle: 'voyager',
  tileLayers: [],
  isOpen: false,
  toggleButton: null,
  panel: null,
  options: []
};

function changeMapStyle(styleId) {
  if (!mapStyles[styleId]) return;

  // retirer anciennes couches
  mapStyleControl.tileLayers.forEach(layer => { if (map.hasLayer(layer)) map.removeLayer(layer); });
  mapStyleControl.tileLayers = [];

  const style = mapStyles[styleId];
  if (style.layers) {
    style.layers.forEach(ld => {
      const layer = L.tileLayer(ld.url, { maxZoom: ld.maxZoom, attribution: style.attribution || '' }).addTo(map);
      mapStyleControl.tileLayers.push(layer);
    });
  } else {
    const layer = L.tileLayer(style.url, { maxZoom: style.maxZoom, attribution: style.attribution }).addTo(map);
    mapStyleControl.tileLayers.push(layer);
  }

  mapStyleControl.currentStyle = styleId;
  updateMapStyleUI(styleId);
  try { localStorage.setItem('gpx_map_style', styleId); } catch(_) {}
}

function updateMapStyleUI(active) {
  mapStyleControl.options.forEach(btn => {
    const id = btn.getAttribute('data-style');
    if (id === active) btn.classList.add('active'); else btn.classList.remove('active');
  });
}

function toggleMapStylePanel(forceState) {
  const shouldOpen = forceState !== undefined ? forceState : !mapStyleControl.isOpen;
  mapStyleControl.panel.style.display = shouldOpen ? 'block' : 'none';
  mapStyleControl.toggleButton.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
  mapStyleControl.isOpen = shouldOpen;
}

function loadMapStylePreference() {
  try { const v = localStorage.getItem('gpx_map_style'); return (v && mapStyles[v]) ? v : 'voyager'; } catch(_) { return 'cyclosm'; }
}

function initMapStyleControl() {
  mapStyleControl.toggleButton = document.getElementById('map-style-toggle');
  mapStyleControl.panel = document.getElementById('map-style-panel');
  mapStyleControl.options = Array.from(document.querySelectorAll('.map-style-option'));

  if (!mapStyleControl.toggleButton || !mapStyleControl.panel) return;

  // appliquer préférence
  changeMapStyle(loadMapStylePreference() || 'voyager');

  // events
  mapStyleControl.toggleButton.addEventListener('click', (e) => { e.stopPropagation(); toggleMapStylePanel(); });
  mapStyleControl.options.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const id = btn.getAttribute('data-style');
      if (id) { changeMapStyle(id); toggleMapStylePanel(false); }
    });
  });
  document.addEventListener('click', (e) => {
    if (mapStyleControl.isOpen) {
      const inside = mapStyleControl.panel.contains(e.target) || mapStyleControl.toggleButton.contains(e.target);
      if (!inside) toggleMapStylePanel(false);
    }
  });
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && mapStyleControl.isOpen) toggleMapStylePanel(false); });
}

document.addEventListener('DOMContentLoaded', () => { try { attachWaypointPersistence(); } catch(e){} });
</script>


<style>
/* === Géolocalisation : styles === */
.geolocation-toggle { padding: 0.5rem 0; }
.geolocation-info {
  margin-top: 0.75rem; padding: 0.75rem; border-radius: var(--radius-md);
  background: var(--color-background-alt); border: 1px solid var(--color-border-light);
}
.geolocation-status {
  display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: var(--color-text-secondary);
}
.geolocation-status .status-icon { font-size: 1rem; }
.geolocation-status.active .status-icon { animation: pulse 2s ease-in-out infinite; }
.geolocation-status.error { color: var(--color-danger); }
.geolocation-error {
  margin-top: 0.75rem; padding: 0.625rem 0.875rem; border-radius: var(--radius-md);
  background: rgba(255, 59, 48, 0.1); color: var(--color-danger); font-size: 0.875rem;
  border: 1px solid rgba(255, 59, 48, 0.2);
}
@keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:.5;} }

/* Marqueur de position */
.user-location-marker { border: none !important; background: transparent !important; }
.user-location-marker-inner {
  width: 100%; height: 100%; border-radius: 50%; background: #4285F4; border: 3px solid #ffffff;
  box-shadow: 0 2px 8px rgba(66,133,244,0.4); animation: locationPulse 2s ease-in-out infinite;
}
@keyframes locationPulse { 0%,100%{transform:scale(1);opacity:1;} 50%{transform:scale(1.1);opacity:.8;} }
.user-location-accuracy { fill: rgba(66,133,244,0.15); stroke: rgba(66,133,244,0.3); stroke-width: 2; }
</style>


<style>
/* Sidebar widening & preset select layout overrides */
.tools-panel { width: 460px !important; min-width: 460px !important; }
@media (max-width: 1024px) {
  .tools-panel { width: 92vw !important; max-width: 460px !important; }
}
@media (max-width: 767px) {
  .tools-panel { width: 95vw !important; max-width: 460px !important; }
  .layer-presets { flex-direction: column !important; align-items: stretch !important; }
}
.layer-presets { display: flex; gap: 0.5rem; align-items: center; }
.layer-presets label { flex: 0 0 auto; margin-right: 0.25rem; }
.preset-select { flex: 1 1 auto; width: 100%; }
</style>

<style>
/* ===== Mobile Portrait Sidebar Compatibility (overrides) ===== */
@media (max-width: 600px) and (orientation: portrait) {
  .tools-panel {
    position: fixed;
    inset: 0 auto 0 0;            /* top:0; left:0; full height */
    width: 100vw !important;
    max-width: 100vw !important;
    min-width: 0 !important;
    height: 100dvh !important;    /* account for mobile browser UI */
    border-right: none !important;
    box-shadow: 0 0 24px rgba(0,0,0,0.15) !important;
    z-index: 2200 !important;
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    transform: translateX(-100%); /* respect existing open/close behavior */
  }
  .tools-panel.open {
    transform: translateX(0);
  }

  .panel-content {
    padding: 0.75rem 1rem !important;
  }

  /* Presets layout: vertical, full width */
  .layer-presets {
    display: flex !important;
    flex-direction: column !important;
    align-items: stretch !important;
    gap: 0.5rem !important;
  }
  .layer-presets label { margin-right: 0 !important; }
  .preset-select { width: 100% !important; min-height: 40px; }

  /* Buttons row wraps gracefully */
  .layer-global-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  /* Slightly smaller section titles to save space */
  .section-title {
    font-size: 1rem !important;
    line-height: 1.25rem !important;
  }
}
</style>

<script id="map-style-control-defs">
// === Map Style Control (defs preloaded) ===
(function(){
  if (window.__MAP_STYLE_CONTROL_DEFINED__) return;
  window.__MAP_STYLE_CONTROL_DEFINED__ = true;

  window.mapStyles = {
    cyclosm: { name:'CyclOSM', url:'https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', attribution:'&copy; OpenStreetMap | CyclOSM', maxZoom:20 },
    osm: { name:'OpenStreetMap', url:'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', attribution:'&copy; OpenStreetMap contributors', maxZoom:19 },
    topo: { name:'OpenTopoMap', url:'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attribution:'&copy; OpenStreetMap | OpenTopoMap', maxZoom:17 },
    voyager: { name:'CARTO Voyager', url:'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', attribution:'&copy; OpenStreetMap | CARTO', maxZoom:20 },
    satellite: { name:'Esri Imagery', url:'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', attribution:'&copy; Esri, Maxar, Earthstar Geographics', maxZoom:19 },
    hybrid: { name:'Esri Hybrid', layers:[
      { url:'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', maxZoom:19 },
      { url:'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', maxZoom:19 }
    ], attribution:'&copy; Esri, Maxar, Earthstar Geographics', maxZoom:19 }
  };

  window.mapStyleControl = { currentStyle:'voyager', tileLayers:[], isOpen:false, toggleButton:null, panel:null, options:[] };

  window.changeMapStyle = function(styleId){
    if (!window.map || !window.mapStyles[styleId]) return;
    // remove old
    window.mapStyleControl.tileLayers.forEach(l => { if (window.map.hasLayer(l)) window.map.removeLayer(l); });
    window.mapStyleControl.tileLayers = [];
    const style = window.mapStyles[styleId];
    if (style.layers) {
      style.layers.forEach(ld => {
        const layer = L.tileLayer(ld.url, { maxZoom: ld.maxZoom, attribution: style.attribution || '' }).addTo(window.map);
        window.mapStyleControl.tileLayers.push(layer);
      });
    } else {
      const layer = L.tileLayer(style.url, { maxZoom: style.maxZoom, attribution: style.attribution }).addTo(window.map);
      window.mapStyleControl.tileLayers.push(layer);
    }
    window.mapStyleControl.currentStyle = styleId;
    window.updateMapStyleUI(styleId);
    try { localStorage.setItem('gpx_map_style', styleId); } catch(_) {}
  };

  window.updateMapStyleUI = function(active){
    (window.mapStyleControl.options || []).forEach(btn => {
      const id = btn.getAttribute('data-style');
      if (id === active) btn.classList.add('active'); else btn.classList.remove('active');
    });
  };

  window.toggleMapStylePanel = function(forceState){
    const shouldOpen = forceState !== undefined ? forceState : !window.mapStyleControl.isOpen;
    if (!window.mapStyleControl.panel || !window.mapStyleControl.toggleButton) return;
    window.mapStyleControl.panel.style.display = shouldOpen ? 'block' : 'none';
    window.mapStyleControl.toggleButton.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    window.mapStyleControl.isOpen = shouldOpen;
  };

  window.loadMapStylePreference = function(){
    try { const v = localStorage.getItem('gpx_map_style'); return (v && window.mapStyles[v]) ? v : 'voyager'; } catch(_) { return 'voyager'; }
  };

  window.initMapStyleControl = function(){
    window.mapStyleControl.toggleButton = document.getElementById('map-style-toggle');
    window.mapStyleControl.panel = document.getElementById('map-style-panel');
    window.mapStyleControl.options = Array.from(document.querySelectorAll('.map-style-option'));
    if (!window.mapStyleControl.toggleButton || !window.mapStyleControl.panel) return;

    // appliquer préférence
    window.changeMapStyle(window.loadMapStylePreference());

    // events
    window.mapStyleControl.toggleButton.addEventListener('click', (e) => { e.stopPropagation(); window.toggleMapStylePanel(); });
    window.mapStyleControl.options.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const id = btn.getAttribute('data-style');
        if (id) { window.changeMapStyle(id); window.toggleMapStylePanel(false); }
      });
    });
    document.addEventListener('click', (e) => {
      if (window.mapStyleControl.isOpen) {
        const inside = window.mapStyleControl.panel.contains(e.target) || window.mapStyleControl.toggleButton.contains(e.target);
        if (!inside) window.toggleMapStylePanel(false);
      }
    });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && window.mapStyleControl.isOpen) window.toggleMapStylePanel(false); });
  };
})();
</script>


<style>
/* Bouton "Effacer la trace" */
#clear-trace-button {
  margin-top: 0.5rem;
}

#clear-trace-button:hover {
  background: var(--color-danger);
  color: white;
}
</style>


<style>
  /* Ensure elevation canvas has a minimum render size after reload */
  #elevation-canvas {
    min-height: 220px;
    width: 100%;
    display: block;
  }
</style>


<style>
  /* Elevation panel responsive sizing */
  #elevation-profile {
    overflow: hidden;
  }
  #elevation-canvas {
    width: 100%;
    display: block;
    /* height is set dynamically by JS; this is a safe fallback */
    max-height: 40vh;
  }
</style>


<style>
  /* Viewport-aware elevation sizing */
  #elevation-profile { overflow: hidden; }
  #elevation-canvas { width: 100%; display: block; }
</style>


<style>
  /* Elevation container should auto-size to its content */
  #elevation-profile { overflow: visible; }
  #elevation-content {
    height: auto !important;
    max-height: none !important;
    overflow: visible !important;
  }
</style>


<style>
  /* Canvas fills its parent container */
  #elevation-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  /* Parent controls height; provide a safe default you can override */
  #elevation-content {
    --elev-content-height: 260px;
    height: var(--elev-content-height);
  }
</style>

</head>
<body>
  <div class="app-container">
    <aside class="tools-panel" id="tools-panel" role="complementary" aria-label="Panneau d'outils">
      <header class="panel-header">
        <h1 class="panel-title">Bikepacking helper</h1>
        <button class="btn-close-panel" id="close-panel" aria-label="Fermer le panneau">✕</button>
      </header>
      <div class="panel-content">
  <section class="panel-section geolocation-section" id="geolocation-section">
  <h3 class="section-title">Ma position</h3>
  <label class="layer-toggle geolocation-toggle">
    <input type="checkbox" id="geolocation-toggle" class="toggle-input" aria-label="Activer la géolocalisation en temps réel"/>
    <span class="toggle-switch"></span>
    <span class="toggle-text">
      <span class="toggle-icon" aria-hidden="true">📍</span>
      Activer la localisation
    </span>
  </label>
  <div class="geolocation-info" id="geolocation-info" style="display: none;">
    <div class="geolocation-status" id="geolocation-status">
      <span class="status-icon">🔄</span>
      <span class="status-text">Recherche de position...</span>
    </div>
    <button type="button" class="btn btn-secondary btn-small" id="center-on-position" style="margin-top: 0.5rem;" disabled>
      <span aria-hidden="true">🎯</span>
      Centrer sur ma position
    </button>
  </div>
  <div class="geolocation-error" id="geolocation-error" style="display: none;"></div>
</section>

  <section class="panel-section">
          <h3 class="section-title">Fichier GPX</h3>
          <div class="import-actions">
            <button class="btn btn-primary" id="import-button">
              <span aria-hidden="true">📁</span>
              Importer GPX
            </button>

<!-- Après le bouton "Exporter GPX" -->
<button class="btn btn-secondary" id="clear-trace-button" style="display: none;">
  <span aria-hidden="true">🗑️</span>
  Effacer la trace
</button>


            <button class="btn btn-primary" id="export-button" disabled>
              <span aria-hidden="true">💾</span>
              Exporter GPX
            </button>
          </div>
          <div class="file-info" id="file-info" style="display: none;">
            <small class="text-muted">Fichier actuel :</small>
            <p class="filename" id="current-filename">—</p>
            <label for="gpx-name-input" style="display:block; font-size:0.85rem; color:var(--color-text-muted); margin-top:0.75rem;">
              Nom d'export
            </label>
            <input id="gpx-name-input" class="file-name-input" type="text" placeholder="Nom du fichier" autocomplete="off" />
          </div>
          <div class="drop-zone" id="panel-drop-zone">
            <p>Ou glissez-déposez un fichier .gpx ici</p>
          </div>
        </section>

  <section class="panel-section" id="layers-section-placeholder"></section>

  <section class="panel-section" id="waypoints-section" style="display: none;">
          <h3 class="section-title">
            Waypoints
            <span class="badge" id="waypoint-count">0</span>
          </h3>
          <div class="waypoints-list" id="waypoints-list"></div>
          <button class="btn btn-secondary btn-small" id="clear-waypoints">Effacer tous les waypoints</button>
        </section>

  <section class="panel-section" id="trace-info-section" style="display: none;">
          <h3 class="section-title">Informations</h3>
          <dl class="info-list">
            <dt>Nom de la trace</dt>
            <dd>
              <span id="trace-name" class="trace-name">—</span>
              <span
                class="trace-name-help"
                title="Le nom provient d'abord du fichier GPX, puis du nom de fichier, ou d'un nom par défaut."
                aria-hidden="true"
              >
                ℹ️
              </span>
            </dd>
            <dt>Nom du fichier</dt>
            <dd id="file-name" class="file-name">—</dd>
            <dt>Distance totale</dt>
            <dd id="trace-distance" class="stat-highlight">—</dd>
            <dt>Dénivelé positif (D+)</dt>
            <dd id="trace-elevation-gain" class="stat-highlight">—</dd>
            <dt>Dénivelé négatif (D-)</dt>
            <dd id="trace-elevation-loss" class="stat-highlight">—</dd>
            <dt>Altitude</dt>
            <dd id="trace-altitude-range">—</dd>
            <dt>Nombre de points</dt>
            <dd id="point-count">—</dd>
            <dt>Type</dt>
            <dd id="trace-type">—</dd>
          </dl>
        </section>

  <section class="panel-section panel-messages">
          <div id="message" class="message hidden" role="status" aria-live="polite"></div>
        </section>
</div>
    </aside>

    <main class="map-container">
      <div class="map-main">
        <div id="map"></div>

<div class="leaflet-map-style-control leaflet-bar leaflet-control" id="map-style-control">
  <button class="map-style-toggle" id="map-style-toggle" type="button" title="Changer le fond de carte" aria-label="Changer le fond de carte" aria-expanded="false">
    <span class="map-style-icon">🗺️</span>
  </button>
  <div class="map-style-panel" id="map-style-panel" style="display: none;">
    <div class="map-style-header">
      <span class="map-style-icon">🗺️</span>
      <span class="map-style-title">Fond de carte</span>
    </div>
    <div class="map-style-section">
      <div class="map-style-section-title">Routes & Cyclisme</div>
      <button class="map-style-option" data-style="cyclosm" type="button">
        <span class="map-style-check">✓</span>
        <span class="map-style-label">CyclOSM</span>
        <span class="map-style-badge">⭐</span>
      </button>
      <button class="map-style-option" data-style="osm" type="button">
        <span class="map-style-check">✓</span>
        <span class="map-style-label">OpenStreetMap</span>
      </button>
      <button class="map-style-option" data-style="topo" type="button">
        <span class="map-style-check">✓</span>
        <span class="map-style-label">OpenTopoMap</span>
      </button>
      <button class="map-style-option" data-style="voyager" type="button">
        <span class="map-style-check">✓</span>
        <span class="map-style-label">CARTO Voyager</span>
      </button>
    </div>
    <div class="map-style-section">
      <div class="map-style-section-title">🛰️ Satellite</div>
      <button class="map-style-option" data-style="satellite" type="button">
        <span class="map-style-check">✓</span>
        <span class="map-style-label">Esri Imagery</span>
      </button>
      <button class="map-style-option" data-style="hybrid" type="button">
        <span class="map-style-check">✓</span>
        <span class="map-style-label">Esri Hybrid</span>
        <span class="map-style-badge">⭐</span>
      </button>
    </div>
  </div>
</div>

        <button class="poi-refresh-button" id="poi-refresh-button" type="button" aria-label="Recharger les points d'intérêt">
          <span aria-hidden="true">🔄</span>
          Recharger les POI
        </button>
        <button class="btn-menu" id="menu-toggle" aria-label="Ouvrir le panneau" aria-expanded="false">☰</button>
      </div>
      <div class="elevation-profile" id="elevation-profile" aria-hidden="true">
        <div class="elevation-header" id="elevation-header">
          <div class="elevation-title" title="Profil altimétrique">
            <span class="elevation-icon" aria-hidden="true">📊</span>
            <h3>Profil altimétrique</h3>
          </div>
          <div class="elevation-stats-quick">
            <span class="stat-item">
              <span class="stat-label">Distance :</span>
              <span class="stat-value" id="profile-distance">—</span>
            </span>
            <span class="stat-item">
              <span class="stat-label">D+ :</span>
              <span class="stat-value" id="profile-elevation-gain">—</span>
            </span>
            <span class="stat-item">
              <span class="stat-label">D- :</span>
              <span class="stat-value" id="profile-elevation-loss">—</span>
            </span>
          </div>
          <button class="btn-collapse" id="elevation-collapse" type="button" aria-expanded="true" aria-label="Réduire le profil">
            <span aria-hidden="true">▼</span>
          </button>
        </div>
        <div class="elevation-content" id="elevation-content">
          <canvas
            id="elevation-canvas"
            role="img"
            aria-label="Graphique du profil altimétrique de la trace"
            aria-describedby="elevation-description"
            tabindex="0"
          ></canvas>
          <div id="elevation-description" class="sr-only">
            Le graphique montre l'élévation en mètres en fonction de la distance parcourue en kilomètres.
            Distance totale : <span id="aria-distance">—</span>.
            Dénivelé positif : <span id="aria-d-plus">—</span>.
            Altitude minimum : <span id="aria-min">—</span>.
            Altitude maximum : <span id="aria-max">—</span>.
          </div>
          <div class="elevation-tooltip" id="elevation-tooltip" style="display: none;">
            <div class="tooltip-row">
              <span class="tooltip-label">Distance :</span>
              <span class="tooltip-value" id="tooltip-distance">—</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Altitude :</span>
              <span class="tooltip-value" id="tooltip-elevation">—</span>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <input id="file-input" type="file" accept=".gpx" hidden />

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
  <script>
    /**
     * Convertit un élément XML GPX en GeoJSON Feature.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertPoint(element, featureType) {
      if (!element) {
        return null;
      }

      const lat = parseFloat(element.getAttribute('lat'));
      const lon = parseFloat(element.getAttribute('lon'));

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }

      const properties = { kind: featureType };

      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const ele = element.querySelector('ele');
      if (ele && ele.textContent.trim()) {
        const elevation = parseFloat(ele.textContent.trim());
        if (Number.isFinite(elevation)) {
          properties.ele = elevation;
        }
      }

      const time = element.querySelector('time');
      if (time && time.textContent.trim()) {
        properties.time = time.textContent.trim();
      }

      return {
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [lon, lat]
        },
        properties
      };
    }

    /**
     * Convertit une liste de points GPX en coordonnées GeoJSON.
     * @param {NodeListOf<Element>} points
     * @returns {number[][]}
     */
    function extractCoordinates(points) {
      const coordinates = [];
      points.forEach((point) => {
        const lat = parseFloat(point.getAttribute('lat'));
        const lon = parseFloat(point.getAttribute('lon'));
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          coordinates.push([lon, lat]);
        }
      });
      return coordinates;
    }

    /**
     * Convertit un élément GPX en GeoJSON pour les routes ou pistes.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertLinearFeature(element, featureType) {
      if (!element) {
        return null;
      }

      const properties = { kind: featureType };
      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const segments = [];

      if (featureType === 'track') {
        const trksegs = element.querySelectorAll('trkseg');
        trksegs.forEach((segment) => {
          const coords = extractCoordinates(segment.querySelectorAll('trkpt'));
          if (coords.length > 1) {
            segments.push(coords);
          }
        });
      } else if (featureType === 'route') {
        const coords = extractCoordinates(element.querySelectorAll('rtept'));
        if (coords.length > 1) {
          segments.push(coords);
        }
      }

      if (segments.length === 0) {
        return null;
      }

      const geometry =
        segments.length === 1
          ? { type: 'LineString', coordinates: segments[0] }
          : { type: 'MultiLineString', coordinates: segments };

      return {
        type: 'Feature',
        geometry,
        properties
      };
    }

    /**
     * Réalise une conversion minimale GPX -> GeoJSON pour les traces, routes et waypoints.
     * @param {XMLDocument} xml
     * @returns {GeoJSON.FeatureCollection}
     */
    function convertGpxToGeoJSON(xml) {
      const features = [];

      xml.querySelectorAll('wpt').forEach((wpt) => {
        const feature = convertPoint(wpt, 'waypoint');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('rte').forEach((route) => {
        const feature = convertLinearFeature(route, 'route');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('trk').forEach((track) => {
        const feature = convertLinearFeature(track, 'track');
        if (feature) {
          features.push(feature);
        }
      });

      return {
        type: 'FeatureCollection',
        features
      };
    }

    const OVERPASS_ENDPOINTS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://overpass.openstreetmap.fr/api/interpreter'
    ];

    const POI_GROUPS = {
      bike_services: { id: 'bike_services', label: 'Services vélo', icon: '🚴', defaultExpanded: true, order: 1 },
      resources: { id: 'resources', label: 'Ressources', icon: '💧', defaultExpanded: true, order: 2 },
      accommodation_outdoor: { id: 'accommodation_outdoor', label: 'Hébergement outdoor', icon: '🏕️', defaultExpanded: true, order: 3 },
      accommodation: { id: 'accommodation', label: 'Hébergement', icon: '🏨', defaultExpanded: false, order: 4 },
      sanitary: { id: 'sanitary', label: 'Sanitaires', icon: '🚻', defaultExpanded: true, order: 5 },
      food_shop: { id: 'food_shop', label: 'Alimentation', icon: '🛒', defaultExpanded: true, order: 6 },
      food_service: { id: 'food_service', label: 'Restauration', icon: '🍴', defaultExpanded: false, order: 7 },
      health: { id: 'health', label: 'Santé', icon: '💊', defaultExpanded: true, order: 8 },
      heritage: { id: 'heritage', label: 'Patrimoine', icon: '🪦', defaultExpanded: false, order: 9 }
    };

    const POI_CATEGORIES = {bicycle_repair: {
        id: 'bicycle_repair',
        label: 'Stations réparation',
        icon: '🔧',
        color: '#FF6B00',
        group: 'bike_services',
        tags: { amenity: 'bicycle_repair_station' },
        priority: 'high',
        minZoom: 12
      },
      bicycle_shop: {
        id: 'bicycle_shop',
        label: 'Magasins vélo',
        icon: '🚲',
        color: '#FF8C00',
        group: 'bike_services',
        tags: { shop: 'bicycle' },
        priority: 'high',
        minZoom: 12
      },
      drinking_water: {
        id: 'drinking_water',
        label: 'Eau potable',
        icon: '💧',
        color: '#2196F3',
        group: 'resources',
        tags: { amenity: 'drinking_water' },
        priority: 'high',
        minZoom: 11
      },
      camp_site: {
        id: 'camp_site',
        label: 'Camping',
        icon: '🏕️',
        color: '#4CAF50',
        group: 'accommodation_outdoor',
        tags: { tourism: 'camp_site' },
        excludeTags: { backcountry: 'yes' },
        priority: 'high',
        minZoom: 11
      },
      camp_site_backcountry: {
        id: 'camp_site_backcountry',
        label: 'Bivouac autorisé',
        icon: '⛺',
        color: '#66BB6A',
        group: 'accommodation_outdoor',
        tags: { tourism: 'camp_site', backcountry: 'yes' },
        priority: 'high',
        minZoom: 11
      },
      wilderness_hut: {
        id: 'wilderness_hut',
        label: 'Refuge',
        icon: '🛖',
        color: '#8D6E63',
        group: 'accommodation_outdoor',
        tags: { tourism: 'wilderness_hut' },
        priority: 'high',
        minZoom: 11
      },
      alpine_hut: {
        id: 'alpine_hut',
        label: 'Refuge alpin',
        icon: '🏔️',
        color: '#795548',
        group: 'accommodation_outdoor',
        tags: { tourism: 'alpine_hut' },
        priority: 'high',
        minZoom: 11
      },
      hotel: {
        id: 'hotel',
        label: 'Hôtel',
        icon: '🏨',
        color: '#9C27B0',
        group: 'accommodation',
        tags: { tourism: 'hotel' },
        priority: 'medium',
        minZoom: 12
      },
      hostel: {
        id: 'hostel',
        label: 'Auberge de jeunesse',
        icon: '🏠',
        color: '#AB47BC',
        group: 'accommodation',
        tags: { tourism: 'hostel' },
        priority: 'medium',
        minZoom: 12
      },
      guest_house: {
        id: 'guest_house',
        label: "Chambre d'hôtes",
        icon: '🏡',
        color: '#BA68C8',
        group: 'accommodation',
        tags: { tourism: 'guest_house' },
        priority: 'medium',
        minZoom: 13
      },
      toilets: {
        id: 'toilets',
        label: 'Toilettes',
        icon: '🚻',
        color: '#607D8B',
        group: 'sanitary',
        tags: { amenity: 'toilets' },
        priority: 'high',
        minZoom: 12
      },
      shower: {
        id: 'shower',
        label: 'Douches',
        icon: '🚿',
        color: '#78909C',
        group: 'sanitary',
        tags: { amenity: 'shower' },
        priority: 'medium',
        minZoom: 13
      },
      supermarket: {
        id: 'supermarket',
        label: 'Supermarché',
        icon: '🛒',
        color: '#FF5252',
        group: 'food_shop',
        tags: { shop: 'supermarket' },
        priority: 'high',
        minZoom: 12
      },
      convenience: {
        id: 'convenience',
        label: 'Épicerie',
        icon: '🏪',
        color: '#FF7043',
        group: 'food_shop',
        tags: { shop: 'convenience' },
        priority: 'high',
        minZoom: 12
      },
      restaurant: {
        id: 'restaurant',
        label: 'Restaurant',
        icon: '🍴',
        color: '#FFC107',
        group: 'food_service',
        tags: { amenity: 'restaurant' },
        priority: 'medium',
        minZoom: 13
      },
      cafe: {
        id: 'cafe',
        label: 'Café',
        icon: '☕',
        color: '#FFD54F',
        group: 'food_service',
        tags: { amenity: 'cafe' },
        priority: 'medium',
        minZoom: 13
      },
      fast_food: {
        id: 'fast_food',
        label: 'Fast-food',
        icon: '🍔',
        color: '#FFEB3B',
        group: 'food_service',
        tags: { amenity: 'fast_food' },
        priority: 'low',
        minZoom: 13
      },
      pharmacy: {
        id: 'pharmacy',
        label: 'Pharmacie',
        icon: '💊',
        color: '#00C853',
        group: 'health',
        tags: { amenity: 'pharmacy' },
        priority: 'high',
        minZoom: 12
      },

      hospital: {
        id: 'hospital',
        label: 'Hôpital',
        icon: '🏥',
        color: '#E53935',
        group: 'health',
        tags: { amenity: 'hospital' },
        priority: 'high',
        minZoom: 11
      },

      cemetery: {
        id: 'cemetery',
        label: 'Cimetière',
        icon: '🪦',
        color: '#6A1B9A',
        group: 'heritage',
        tags: { landuse: 'cemetery' },
        priority: 'low',
        minZoom: 12
      },
      grave_yard: {
        id: 'grave_yard',
        label: 'Petit cimetière',
        icon: '⛪',
        color: '#757575',
        group: 'heritage',
        tags: { amenity: 'grave_yard' },
        priority: 'low',
        minZoom: 12
      }
    };


    const LAYER_PRESETS = {
  need_water: {
    label: "J'ai besoin d'eau",
    icon: '💧',
    categories: [
      'drinking_water',
      'cemetery',
      'grave_yard',
      'convenience'
    ]
  },
  need_food: {
    label: 'J\'ai besoin de manger',
    icon: '🍽️',
    categories: [
      'supermarket',
      'convenience',
      'restaurant',
      'fast_food'
    ]
  },
  need_repair: {
    label: 'J\'ai besoin de réparer',
    icon: '🔧',
    categories: [
      'bicycle_repair',
      'bicycle_shop'
    ]
  },
  need_accommodation: {
    label: 'J\'ai besoin d\'un hébergement',
    icon: '🏕️',
    categories: [
      'camp_site',
      'wilderness_hut',
      'alpine_hut',
      'hotel',
      'hostel',
      'guest_house'
    ]
  },
  need_health: {
    label: 'J\'ai besoin de me soigner',
    icon: '🏥',
    categories: [
      'pharmacy',
      'hospital'
    ]
  }
};

    const POI_SETTINGS = {
      debounceMs: 2000,
      minZoomDefault: 11,
      maxTotalItems: 500,
      maxItemsPerCategory: 120,
      cacheTtlMs: 10 * 60 * 1000,
      maxCacheEntries: 15,
      areaLimitDegSq: 0.12,
      maxRetries: 2,
      requestTimeoutMs: 12000
    };

    const poiCache = {
      data: new Map(),
      set(key, value) {
        this.data.set(key, { value, timestamp: Date.now() });
      },
      get(key) {
        const entry = this.data.get(key);
        if (!entry) {
          return null;
        }
        if (Date.now() - entry.timestamp > POI_SETTINGS.cacheTtlMs) {
          this.data.delete(key);
          return null;
        }
        return entry.value;
      },
      prune(maxEntries) {
        if (this.data.size <= maxEntries) {
          return;
        }
        const sorted = Array.from(this.data.entries()).sort(
          (a, b) => a[1].timestamp - b[1].timestamp
        );
        while (sorted.length > maxEntries) {
          const [keyToDelete] = sorted.shift();
          this.data.delete(keyToDelete);
        }
      },
      clear() {
        this.data.clear();
      }
    };

    const poiRequestLimiter = {
      lastRequest: 0,
      minInterval: 1500
    };

    const poiManager = {
      activeCategories: new Set(),
      expandedGroups: new Set(),
      layerGroups: new Map(),
      counts: new Map(),
      debounceTimer: null,
      abortController: null,
      currentRequestId: 0,
      loading: false,
      enabled: false,
      refreshPending: false,
      suppressRefreshPrompt: false,
      stats: {
        totalLoaded: 0,
        currentDisplayed: 0,
        requestCount: 0,
        errorCount: 0
      }
    };

    let layersSectionElement = null;
    let layersLoadingElement = null;
    let layersErrorElement = null;
    let layersInfoElement = null;
    let layersZoomInfoElement = null;
    let layersTotalElement = null;
    let layersTotalCountElement = null;
    let presetSelectElement = null;
    let isApplyingPreset = false;

    function getDefaultExpandedGroups() {
      return new Set(
        Object.values(POI_GROUPS)
          .filter((group) => group.defaultExpanded)
          .map((group) => group.id)
      );
    }

    function getDefaultActiveCategories() {
      return new Set(['cemetery', 'grave_yard']);
    }

    function loadLayerPreferences() {
      try {
        const raw = localStorage.getItem('gpx_layer_preferences');
        if (!raw) {
          return null;
        }
        const parsed = JSON.parse(raw);
        const active = new Set(
          Array.isArray(parsed.activeCategories)
            ? parsed.activeCategories.filter((id) => POI_CATEGORIES[id])
            : []
        );
        const expanded = new Set(
          Array.isArray(parsed.expandedGroups)
            ? parsed.expandedGroups.filter((id) => POI_GROUPS[id])
            : []
        );
        return { active, expanded };
      } catch (error) {
        console.warn('Impossible de charger les préférences:', error);
        return null;
      }
    }

    function saveLayerPreferences() {
      const data = {
        activeCategories: Array.from(poiManager.activeCategories),
        expandedGroups: Array.from(poiManager.expandedGroups)
      };
      try {
        localStorage.setItem('gpx_layer_preferences', JSON.stringify(data));
      } catch (error) {
        console.warn('Impossible de sauvegarder les préférences:', error);
      }
    }

    function generateLayersHTML() {
      const groups = Object.values(POI_GROUPS).sort((a, b) => a.order - b.order);
      let html = `
        <section class="panel-section layer-section" id="layers-section">
          <h3 class="section-title">Calques et affichage</h3>
          <div class="layer-global-actions">
            <button type="button" class="btn btn-secondary btn-small" id="layers-enable-all">Activer tout</button>
            <button type="button" class="btn btn-secondary btn-small" id="layers-disable-all">Désactiver tout</button>
          </div>
          <div class="layer-presets">
            <label for="preset-select">Profil :</label>
            <select id="preset-select" class="preset-select">
              <option value="">Personnalisé</option>`;
      Object.entries(LAYER_PRESETS).forEach(([presetId, preset]) => {
        html += `
              <option value="${presetId}">${preset.icon} ${preset.label}</option>`;
      });
      html += `
            </select>
          </div>`;
      groups.forEach((group) => {
        const categories = Object.values(POI_CATEGORIES).filter((category) => category.group === group.id);
        if (categories.length === 0) {
          return;
        }
        const isExpanded = poiManager.expandedGroups.has(group.id);
        html += `
          <div class="layer-group ${isExpanded ? 'expanded' : ''}" data-group="${group.id}">
            <button class="layer-group-header" type="button" data-group="${group.id}" aria-expanded="${isExpanded ? 'true' : 'false'}">
              <span class="layer-group-icon">${group.icon}</span>
              <span class="layer-group-label">${group.label}</span>
              <span class="layer-group-count">(${categories.length})</span>
              <span class="layer-group-chevron">▼</span>
            </button>
            <div class="layer-group-content">`;
        categories.forEach((category) => {
          const isChecked = poiManager.activeCategories.has(category.id) ? 'checked' : '';
          html += `
              <label class="layer-toggle" data-category="${category.id}">
                <input
                  type="checkbox"
                  id="layer-${category.id}"
                  class="toggle-input layer-checkbox"
                  data-category="${category.id}"
                  ${isChecked}
                />
                <span class="toggle-switch"></span>
                <span class="toggle-text">
                  <span class="toggle-icon" aria-hidden="true">${category.icon}</span>
                  ${category.label}
                </span>
                <span class="toggle-count" id="count-${category.id}" style="display: none;">(0)</span>
              </label>`;
        });
        html += `
            </div>
          </div>`;
      });
      html += `
          <div class="layer-indicators">
            <div class="layer-loading" id="layers-loading" style="display: none;">
              <span class="loading-spinner" aria-hidden="true">⏳</span>
              Chargement des POI...
            </div>
            <div class="layer-error" id="layers-error" style="display: none;" role="alert"></div>
            <div class="layer-info" id="layers-info" style="display: none;"></div>
            <div class="layer-info" id="layers-zoom-info" style="display: none;"></div>
          </div>
          <div class="layer-total" id="layers-total" style="display: none;">
            <strong>Total POI affichés :</strong>
            <span class="layer-count-value" id="layers-total-count">0</span>
          </div>
        </section>


`;
      return html;
    }

    function attachLayerEventHandlers() {
      const enableAllButton = document.getElementById('layers-enable-all');
      const disableAllButton = document.getElementById('layers-disable-all');
      if (enableAllButton) {
        enableAllButton.addEventListener('click', () => enableAllCategories());
      }
      if (disableAllButton) {
        disableAllButton.addEventListener('click', () => disableAllCategories());
      }
      if (presetSelectElement) {
        presetSelectElement.addEventListener('change', handlePresetChange);
      }
      document.querySelectorAll('.layer-group-header').forEach((header) => {
        header.addEventListener('click', () => {
          const groupId = header.getAttribute('data-group');
          toggleGroupExpanded(groupId);
        });
      });
      document.querySelectorAll('.layer-checkbox').forEach((checkbox) => {
        checkbox.addEventListener('change', handleCategoryCheckboxChange);
      });
    }

    function renderLayersSection() {
      const placeholder = document.getElementById('layers-section-placeholder');
      if (!placeholder) {
        return;
      }
      placeholder.outerHTML = generateLayersHTML();
      layersSectionElement = document.getElementById('layers-section');
      layersLoadingElement = document.getElementById('layers-loading');
      layersErrorElement = document.getElementById('layers-error');
      layersInfoElement = document.getElementById('layers-info');
      layersZoomInfoElement = document.getElementById('layers-zoom-info');
      layersTotalElement = document.getElementById('layers-total');
      layersTotalCountElement = document.getElementById('layers-total-count');
      presetSelectElement = document.getElementById('preset-select');
      attachLayerEventHandlers();
      hideLayersIndicators();
      updateAllPOICounts();
      updateTotalPOICount(0);
      updatePresetSelection();
    }

    function ensureLayerGroup(categoryId) {
      if (!poiManager.layerGroups.has(categoryId)) {
        poiManager.layerGroups.set(categoryId, L.layerGroup());
      }
      return poiManager.layerGroups.get(categoryId);
    }

    function setCategoryCheckboxState(categoryId, isChecked) {
      const checkbox = document.getElementById(`layer-${categoryId}`);
      if (checkbox) {
        checkbox.checked = Boolean(isChecked);
      }
    }

    function updateCategoryCountUI(categoryId, count) {
      const element = document.getElementById(`count-${categoryId}`);
      if (!element) {
        return;
      }
      if (count > 0) {
        element.textContent = `(${count})`;
        element.style.display = 'inline';
      } else {
        element.style.display = 'none';
      }
    }

    function updateAllPOICounts() {
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        const count = poiManager.counts.get(categoryId) || 0;
        updateCategoryCountUI(categoryId, count);
      });
    }

    function updateTotalPOICount(total) {
      if (!layersTotalElement || !layersTotalCountElement) {
        return;
      }
      if (total > 0) {
        layersTotalElement.style.display = 'flex';
        layersTotalCountElement.textContent = String(total);
      } else {
        layersTotalElement.style.display = 'none';
        layersTotalCountElement.textContent = '0';
      }
    }

    function hideLayersIndicators() {
      hideLayersLoading();
      hideLayersError();
      hideLayersInfo();
      hideLayersZoomInfo();
    }

    function showLayersLoading() {
      if (layersLoadingElement) {
        layersLoadingElement.style.display = 'flex';
      }
    }

    function hideLayersLoading() {
      if (layersLoadingElement) {
        layersLoadingElement.style.display = 'none';
      }
    }

    function showLayersError(message) {
      if (layersErrorElement) {
        layersErrorElement.textContent = `⚠️ ${message}`;
        layersErrorElement.style.display = 'block';
      }
    }

    function hideLayersError() {
      if (layersErrorElement) {
        layersErrorElement.style.display = 'none';
        layersErrorElement.textContent = '';
      }
    }

    function showLayersInfo(message) {
      if (layersInfoElement) {
        layersInfoElement.textContent = message;
        layersInfoElement.style.display = 'block';
      }
    }

    function hideLayersInfo() {
      if (layersInfoElement) {
        layersInfoElement.style.display = 'none';
        layersInfoElement.textContent = '';
      }
    }

    function showLayersZoomInfo(minZoom) {
      if (layersZoomInfoElement) {
        layersZoomInfoElement.textContent = `ℹ️ Zoomez davantage pour voir les POI (zoom ≥ ${minZoom})`;
        layersZoomInfoElement.style.display = 'block';
      }
    }

    function hideLayersZoomInfo() {
      if (layersZoomInfoElement) {
        layersZoomInfoElement.style.display = 'none';
        layersZoomInfoElement.textContent = '';
      }
    }

    function showPoiRefreshButton() {
      if (!poiRefreshButton) {
        return;
      }
      poiRefreshButton.style.display = 'inline-flex';
      poiRefreshButton.setAttribute('aria-hidden', 'false');
    }

    function hidePoiRefreshButton() {
      if (!poiRefreshButton) {
        return;
      }
      poiRefreshButton.style.display = 'none';
      poiRefreshButton.setAttribute('aria-hidden', 'true');
    }

    function toggleGroupExpanded(groupId) {
      if (!groupId || !POI_GROUPS[groupId]) {
        return;
      }
      if (poiManager.expandedGroups.has(groupId)) {
        poiManager.expandedGroups.delete(groupId);
      } else {
        poiManager.expandedGroups.add(groupId);
      }
      saveLayerPreferences();
      const groupElement = document.querySelector(`.layer-group[data-group="${groupId}"]`);
      if (groupElement) {
        const header = groupElement.querySelector('.layer-group-header');
        const expanded = poiManager.expandedGroups.has(groupId);
        groupElement.classList.toggle('expanded', expanded);
        if (header) {
          header.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        }
      }
    }

    function handleCategoryCheckboxChange(event) {
      const checkbox = event.target;
      const categoryId = checkbox.getAttribute('data-category');
      setCategoryEnabled(categoryId, checkbox.checked);
    }

    function handlePresetChange(event) {
      const presetId = event.target.value;
      if (!presetId) {
        updatePresetSelection();
        return;
      }
      applyPreset(presetId);
    }

    function updatePresetSelection() {
      if (!presetSelectElement || isApplyingPreset) {
        return;
      }
      const active = Array.from(poiManager.activeCategories).sort();
      let matched = '';
      Object.entries(LAYER_PRESETS).some(([presetId, preset]) => {
        const presetCategories = preset.categories.filter((id) => POI_CATEGORIES[id]).sort();
        if (
          presetCategories.length === active.length &&
          presetCategories.every((value, index) => value === active[index])
        ) {
          matched = presetId;
          return true;
        }
        return false;
      });
      presetSelectElement.value = matched;
    }

    function applyPreset(presetId) {
      const preset = LAYER_PRESETS[presetId];
      if (!preset) {
        return;
      }
      isApplyingPreset = true;
      cancelPendingPOILoad();
      disableAllCategories({ triggerLoad: false, persist: false, skipPresetSync: true });
      preset.categories.forEach((categoryId) => {
        if (POI_CATEGORIES[categoryId]) {
          setCategoryEnabled(categoryId, true, { triggerLoad: false, persist: false, skipPresetSync: true });
        }
      });
      saveLayerPreferences();
      isApplyingPreset = false;
      updatePresetSelection();
      loadPOIForCurrentView(true);
    }

    function enableAllCategories() {
      cancelPendingPOILoad();
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        setCategoryEnabled(categoryId, true, { triggerLoad: false, persist: false, skipPresetSync: true });
      });
      saveLayerPreferences();
      updatePresetSelection();
      loadPOIForCurrentView(true);
    }

    function disableAllCategories(options = {}) {
      const { triggerLoad = true, persist = true, skipPresetSync = false } = options;
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        setCategoryEnabled(categoryId, false, { triggerLoad: false, persist: false, skipPresetSync: true });
      });
      if (persist) {
        saveLayerPreferences();
      }
      if (!skipPresetSync) {
        updatePresetSelection();
      }
      if (triggerLoad) {
        clearAllPOILayers();
        hideLayersIndicators();
      }
    }

    function setCategoryEnabled(categoryId, enabled, options = {}) {
      const { triggerLoad = true, persist = true, skipPresetSync = false } = options;
      const category = POI_CATEGORIES[categoryId];
      if (!category) {
        return;
      }
      const isActive = poiManager.activeCategories.has(categoryId);
      if (enabled === isActive) {
        setCategoryCheckboxState(categoryId, enabled);
        return;
      }
      if (enabled) {
        poiManager.activeCategories.add(categoryId);
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
        poiManager.counts.set(categoryId, poiManager.counts.get(categoryId) || 0);
        setCategoryCheckboxState(categoryId, true);
      } else {
        poiManager.activeCategories.delete(categoryId);
        const layerGroup = poiManager.layerGroups.get(categoryId);
        if (layerGroup) {
          layerGroup.clearLayers();
          if (map.hasLayer(layerGroup)) {
            map.removeLayer(layerGroup);
          }
        }
        poiManager.counts.set(categoryId, 0);
        setCategoryCheckboxState(categoryId, false);
      }
      if (persist) {
        saveLayerPreferences();
      }
      if (!skipPresetSync) {
        updatePresetSelection();
      }
      updateCategoryCountUI(categoryId, poiManager.counts.get(categoryId) || 0);
      if (triggerLoad) {
        cancelPendingPOILoad();
        loadPOIForCurrentView(true);
      }
    }

    function clearAllPOILayers() {
      poiManager.layerGroups.forEach((layerGroup, categoryId) => {
        layerGroup.clearLayers();
        if (!poiManager.activeCategories.has(categoryId) && map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
      });
      poiManager.counts.clear();
      updateAllPOICounts();
      updateTotalPOICount(0);
    }

    function cancelPendingPOILoad() {
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
        poiManager.debounceTimer = null;
      }
      if (poiManager.abortController) {
        poiManager.abortController.abort();
        poiManager.abortController = null;
      }
      poiManager.loading = false;
      hideLayersLoading();
    }

    function getMinZoomForActiveCategories() {
      let minZoom = POI_SETTINGS.minZoomDefault;
      poiManager.activeCategories.forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (category && category.minZoom) {
          minZoom = Math.max(minZoom, category.minZoom);
        }
      });
      return minZoom;
    }

    function isBoundsTooLarge(bounds) {
      const north = bounds.getNorth();
      const south = bounds.getSouth();
      const east = bounds.getEast();
      const west = bounds.getWest();
      const latDiff = Math.abs(north - south);
      const lngDiff = Math.abs(east - west);
      return latDiff * lngDiff > POI_SETTINGS.areaLimitDegSq;
    }

    function handlePOIViewportChange() {
      if (!poiManager.enabled) {
        return;
      }
      if (poiManager.suppressRefreshPrompt) {
        poiManager.suppressRefreshPrompt = false;
        return;
      }
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
      }
      poiManager.debounceTimer = setTimeout(() => {
        if (poiManager.activeCategories.size === 0 || poiManager.loading) {
          poiManager.refreshPending = false;
          hidePoiRefreshButton();
          return;
        }
        poiManager.refreshPending = true;
        showPoiRefreshButton();
      }, POI_SETTINGS.debounceMs);
    }

    function buildCacheKey(bounds, activeCategories) {
      const precision = 3;
      const boundsKey = [
        bounds.getSouth().toFixed(precision),
        bounds.getWest().toFixed(precision),
        bounds.getNorth().toFixed(precision),
        bounds.getEast().toFixed(precision)
      ].join(',');
      const categoriesKey = Array.from(activeCategories).sort().join(',');
      return `${boundsKey}|${categoriesKey}`;
    }

    function buildMultiCategoryOverpassQuery(bounds, activeCategories) {
      if (!activeCategories || activeCategories.size === 0) {
        return null;
      }
      const south = bounds.getSouth();
      const west = bounds.getWest();
      const north = bounds.getNorth();
      const east = bounds.getEast();
      const bbox = `${south},${west},${north},${east}`;
      const queryParts = [];
      Array.from(activeCategories).forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          return;
        }
        const required = Object.entries(category.tags);
        const excludes = Object.entries(category.excludeTags || {});
        const filters = required
          .map(([key, value]) => `["${key}"="${value}"]`)
          .join('');
        const excludeFilters = excludes
          .map(([key, value]) => `["${key}"!="${value}"]`)
          .join('');
        ['node', 'way', 'relation'].forEach((type) => {
          queryParts.push(`${type}${filters}${excludeFilters};`);
        });
      });
      if (queryParts.length === 0) {
        return null;
      }
      return `
        [out:json][timeout:25][bbox:${bbox}];
        (
          ${queryParts.join('\n          ')}
        );
        out center;
      `.trim();
    }

    async function loadPOIForCurrentView(force = false) {
      if (!poiManager.enabled) {
        return;
      }
      if (poiManager.loading && !force) {
        return;
      }
      if (poiManager.activeCategories.size === 0) {
        clearAllPOILayers();
        hideLayersIndicators();
        return;
      }
      const bounds = map.getBounds();
      const minZoom = getMinZoomForActiveCategories();
      if (map.getZoom() < minZoom) {
        clearAllPOILayers();
        showLayersZoomInfo(minZoom);
        hideLayersLoading();
        return;
      }
      if (isBoundsTooLarge(bounds)) {
        clearAllPOILayers();
        showLayersError('Zone trop grande, veuillez zoomer davantage.');
        hideLayersLoading();
        return;
      }
      hideLayersZoomInfo();
      hideLayersError();
      hideLayersInfo();
      const cacheKey = buildCacheKey(bounds, poiManager.activeCategories);
      const cached = poiCache.get(cacheKey);
      if (cached) {
        displayMultiCategoryPOIs(cached);
        return;
      }
      const requestId = ++poiManager.currentRequestId;
      poiManager.loading = true;
      showLayersLoading();
      try {
        const pois = await fetchPOIsFromOverpass(bounds, poiManager.activeCategories);
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiCache.set(cacheKey, pois);
        poiCache.prune(POI_SETTINGS.maxCacheEntries);
        displayMultiCategoryPOIs(pois);
        poiManager.stats.totalLoaded += pois.length;
        poiManager.stats.requestCount += 1;
      } catch (error) {
        if (error && error.name === 'AbortError') {
          return;
        }
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiManager.stats.errorCount += 1;
        clearAllPOILayers();
        showLayersError(error?.message || 'Impossible de charger les POI.');
      } finally {
        if (poiManager.currentRequestId === requestId) {
          poiManager.loading = false;
          hideLayersLoading();
          poiManager.abortController = null;
        }
      }
    }

    async function enforceRequestThrottle() {
      const now = Date.now();
      const elapsed = now - poiRequestLimiter.lastRequest;
      if (elapsed < poiRequestLimiter.minInterval) {
        await new Promise((resolve) => setTimeout(resolve, poiRequestLimiter.minInterval - elapsed));
      }
      poiRequestLimiter.lastRequest = Date.now();
    }

    async function fetchPOIsFromOverpass(bounds, activeCategories) {
      const query = buildMultiCategoryOverpassQuery(bounds, activeCategories);
      if (!query) {
        return [];
      }
      let lastError = null;
      const activeSnapshot = new Set(activeCategories);
      for (let attempt = 0; attempt <= POI_SETTINGS.maxRetries; attempt++) {
        const endpoint = OVERPASS_ENDPOINTS[attempt % OVERPASS_ENDPOINTS.length];
        const controller = new AbortController();
        poiManager.abortController = controller;
        let timedOut = false;
        const timeoutId = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, POI_SETTINGS.requestTimeoutMs);
        try {
          await enforceRequestThrottle();
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `data=${encodeURIComponent(query)}`,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            if (response.status === 429) {
              lastError = new Error('Trop de requêtes. Veuillez patienter quelques instants.');
            } else if (response.status === 504) {
              lastError = new Error('Timeout du serveur. Essayez de zoomer davantage.');
            } else {
              lastError = new Error(`Erreur HTTP ${response.status}`);
            }
            continue;
          }
          const data = await response.json();
          const elements = Array.isArray(data?.elements) ? data.elements : [];
          const parsed = elements
            .map((element) => parseMultiCategoryPOI(element, activeSnapshot))
            .filter(Boolean);
          return parsed;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            if (timedOut) {
              lastError = new Error('Timeout de la requête');
              continue;
            }
            throw error;
          }
          lastError =
            error instanceof Error
              ? error
              : new Error('Erreur inconnue lors du chargement des POI.');
        } finally {
          if (poiManager.abortController === controller) {
            poiManager.abortController = null;
          }
        }
      }
      throw lastError || new Error('Impossible de récupérer les POI.');
    }

    function parseMultiCategoryPOI(element, activeCategoryIds) {
      if (!element || !element.tags) {
        return null;
      }
      const tags = element.tags;
      let lat;
      let lon;
      if (element.type === 'node') {
        lat = element.lat;
        lon = element.lon;
      } else if (element.center) {
        lat = element.center.lat;
        lon = element.center.lon;
      }
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }
      const orderedCategories = Array.from(activeCategoryIds).sort();
      for (const categoryId of orderedCategories) {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          continue;
        }
        const requiredEntries = Object.entries(category.tags);
        let matches = true;
        for (const [key, value] of requiredEntries) {
          if (tags[key] !== value) {
            matches = false;
            break;
          }
        }
        if (!matches) {
          continue;
        }
        const excludeEntries = Object.entries(category.excludeTags || {});
        let excluded = false;
        for (const [key, value] of excludeEntries) {
          if (tags[key] === value) {
            excluded = true;
            break;
          }
        }
        if (excluded) {
          continue;
        }
        const addressParts = [];
        if (tags['addr:housenumber'] && tags['addr:street']) {
          addressParts.push(`${tags['addr:housenumber']} ${tags['addr:street']}`);
        } else if (tags['addr:street']) {
          addressParts.push(tags['addr:street']);
        }
        if (tags['addr:city']) {
          addressParts.push(tags['addr:city']);
        }
        const metadata = {
          opening_hours: tags.opening_hours || null,
          phone: tags.phone || tags.contact_phone || null,
          website: tags.website || tags.contact_website || null,
          capacity: tags.capacity || null,
          fee: tags.fee || null,
          access: tags.access || null,
          drinking_water: tags.drinking_water || null,
          shower: tags.shower || null,
          toilets: tags.toilets || null,
          cuisine: tags.cuisine || null
        };
        return {
          id: element.id,
          osmType: element.type,
          lat,
          lon,
          categoryId,
          name: tags.name || 'Sans nom',
          address: addressParts.join(', ') || null,
          metadata
        };
      }
      return null;
    }

    function createMultiCategoryPOIMarker(poi, category) {
      if (!poi || !category) {
        return null;
      }
      const icon = L.divIcon({
        className: 'poi-marker',
        html: `
          <div class="poi-marker-inner" style="background-color: ${category.color};">
            <span class="poi-marker-icon">${category.icon}</span>
          </div>
        `,
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      });
      const marker = L.marker([poi.lat, poi.lon], {
        icon,
        opacity: 0.9,
        title: poi.name
      });
      marker.bindPopup(createMultiCategoryPOIPopup(poi, category), {
        maxWidth: 320,
        className: 'poi-popup-container'
      });
      if (poi.name) {
        marker.bindTooltip(poi.name, {
          direction: 'top',
          offset: [0, -14]
        });
      }
      return marker;
    }

    function createMultiCategoryPOIPopup(poi, category) {
      const meta = poi.metadata || {};
      let html = `
        <div class="poi-popup">
          <div class="poi-header">
            <span class="poi-icon" aria-hidden="true">${category.icon}</span>
            <strong class="poi-name">${escapeHtml(poi.name)}</strong>
          </div>
          <div class="poi-details">
            <div class="poi-row">
              <span class="poi-label">Type :</span>
              <span class="poi-value">${escapeHtml(category.label)}</span>
            </div>`;
      if (poi.address) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Adresse :</span>
              <span class="poi-value">${escapeHtml(poi.address)}</span>
            </div>`;
      }
      if (meta.opening_hours) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Horaires :</span>
              <span class="poi-value">${escapeHtml(meta.opening_hours)}</span>
            </div>`;
      }
      if (meta.phone) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Téléphone :</span>
              <span class="poi-value"><a href="tel:${escapeHtml(meta.phone)}">${escapeHtml(meta.phone)}</a></span>
            </div>`;
      }
      if (meta.website) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Site web :</span>
              <span class="poi-value"><a href="${escapeHtml(meta.website)}" target="_blank" rel="noopener">🔗</a></span>
            </div>`;
      }
      if (meta.capacity) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Capacité :</span>
              <span class="poi-value">${escapeHtml(meta.capacity)}</span>
            </div>`;
      }
      if (meta.fee) {
        const feeLabel = meta.fee === 'yes' ? 'Payant' : meta.fee === 'no' ? 'Gratuit' : escapeHtml(meta.fee);
        html += `
            <div class="poi-row">
              <span class="poi-label">Tarif :</span>
              <span class="poi-value">${feeLabel}</span>
            </div>`;
      }
      if (meta.access && meta.access !== 'yes') {
        html += `
            <div class="poi-row">
              <span class="poi-label">Accès :</span>
              <span class="poi-value">${escapeHtml(meta.access)}</span>
            </div>`;
      }
      if (meta.cuisine) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Cuisine :</span>
              <span class="poi-value">${escapeHtml(meta.cuisine)}</span>
            </div>`;
      }
      const services = [];
      if (meta.drinking_water === 'yes') services.push('💧 Eau potable');
      if (meta.shower === 'yes') services.push('🚿 Douches');
      if (meta.toilets === 'yes') services.push('🚻 Toilettes');
      if (services.length > 0) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Services :</span>
              <span class="poi-value">${services.join(' • ')}</span>
            </div>`;
      }
      html += `
          </div>
          <div class="poi-footer">
            <small>
              <a href="https://www.openstreetmap.org/${poi.osmType}/${poi.id}" target="_blank" rel="noopener noreferrer">
                Voir sur OpenStreetMap ↗
              </a>
            </small>
          </div>
        </div>`;
      return html;
    }

    function displayMultiCategoryPOIs(pois) {
      poiManager.counts.clear();
      poiManager.layerGroups.forEach((layerGroup, categoryId) => {
        if (poiManager.activeCategories.has(categoryId)) {
          layerGroup.clearLayers();
        } else if (map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
      });
      if (!Array.isArray(pois) || pois.length === 0) {
        updateAllPOICounts();
        updateTotalPOICount(0);
        hideLayersInfo();
        return;
      }
      let workingPois = pois.slice();
      let totalLimited = false;
      if (workingPois.length > POI_SETTINGS.maxTotalItems) {
        workingPois = workingPois.slice(0, POI_SETTINGS.maxTotalItems);
        totalLimited = true;
      }
      const grouped = new Map();
      workingPois.forEach((poi) => {
        if (!poi || !poiManager.activeCategories.has(poi.categoryId)) {
          return;
        }
        if (!grouped.has(poi.categoryId)) {
          grouped.set(poi.categoryId, []);
        }
        grouped.get(poi.categoryId).push(poi);
      });
      let categoryLimited = false;
      let total = 0;
      poiManager.activeCategories.forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          return;
        }
        const items = grouped.get(categoryId) || [];
        let limitedItems = items;
        if (items.length > POI_SETTINGS.maxItemsPerCategory) {
          limitedItems = items.slice(0, POI_SETTINGS.maxItemsPerCategory);
          categoryLimited = true;
        }
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
        layerGroup.clearLayers();
        limitedItems.forEach((poi) => {
          const marker = createMultiCategoryPOIMarker(poi, category);
          if (marker) {
            marker.poi = poi;
            layerGroup.addLayer(marker);
          }
        });
        poiManager.counts.set(categoryId, limitedItems.length);
        total += limitedItems.length;
      });
      updateAllPOICounts();
      updateTotalPOICount(total);
      if (total === 0) {
        hideLayersInfo();
      } else if (totalLimited) {
        showLayersInfo(
          `Trop de points d'intérêt (${pois.length}), limitation à ${POI_SETTINGS.maxTotalItems}. Zoomez pour plus de détails.`
        );
      } else if (categoryLimited) {
        showLayersInfo('Certaines catégories contiennent de nombreux POI. Zoomez pour plus de détails.');
      } else {
        hideLayersInfo();
      }
      poiManager.stats.currentDisplayed = total;
    }

    function initPOIManager() {
      const prefs = loadLayerPreferences();
      poiManager.expandedGroups = prefs ? new Set(prefs.expanded) : getDefaultExpandedGroups();
      poiManager.activeCategories = prefs ? new Set(prefs.active) : getDefaultActiveCategories();
      renderLayersSection();
      poiManager.activeCategories.forEach((categoryId) => {
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
      });
      updatePresetSelection();
      poiManager.enabled = true;
      map.on('moveend', handlePOIViewportChange);
      map.on('zoomend', handlePOIViewportChange);
      if (poiManager.activeCategories.size > 0) {
        loadPOIForCurrentView(true);
      } else {
        hideLayersIndicators();
      }
    }

    const map = L.map('map').setView([48.8566, 2.3522], 12);
  // Expose Leaflet map globally for style control
  window.map = map;


  // Initialiser le contrôle de style AVANT POI/GPX
  requestAnimationFrame(()=>{ if (window.initMapStyleControl) window.initMapStyleControl(); });

    map.zoomControl.setPosition('topright');

    // Couche de tuiles OpenStreetMap avec attribution obligatoire
    const fileInput = document.getElementById('file-input');
    const importButton = document.getElementById('import-button');
    const exportButton = document.getElementById('export-button');
    const gpxNameInput = document.getElementById('gpx-name-input');
    const messageBox = document.getElementById('message');
    const panelDropZone = document.getElementById('panel-drop-zone');
    const toolsPanel = document.getElementById('tools-panel');
    const menuToggle = document.getElementById('menu-toggle');
    const closePanel = document.getElementById('close-panel');
    const fileInfo = document.getElementById('file-info');
    const currentFilename = document.getElementById('current-filename');
    const traceFileNameLabel = document.getElementById('file-name');
    const waypointsSection = document.getElementById('waypoints-section');
    const waypointsList = document.getElementById('waypoints-list');
    const waypointCountLabel = document.getElementById('waypoint-count');
    const clearWaypointsButton = document.getElementById('clear-waypoints');
    const traceInfoSection = document.getElementById('trace-info-section');
    const traceNameLabel = document.getElementById('trace-name');
    const pointCountLabel = document.getElementById('point-count');
    const traceTypeLabel = document.getElementById('trace-type');
    const traceDistanceLabel = document.getElementById('trace-distance');
    const traceElevationGainLabel = document.getElementById('trace-elevation-gain');
    const traceElevationLossLabel = document.getElementById('trace-elevation-loss');
    const traceAltitudeRangeLabel = document.getElementById('trace-altitude-range');
    const ariaDistance = document.getElementById('aria-distance');
    const ariaDPlus = document.getElementById('aria-d-plus');
    const ariaMin = document.getElementById('aria-min');
    const ariaMax = document.getElementById('aria-max');
    const profileDistanceValue = document.getElementById('profile-distance');
    const profileElevationGainValue = document.getElementById('profile-elevation-gain');
    const profileElevationLossValue = document.getElementById('profile-elevation-loss');
    const elevationProfile = document.getElementById('elevation-profile');
    const elevationHeader = document.getElementById('elevation-header');
    const elevationCollapseButton = document.getElementById('elevation-collapse');
    const elevationContent = document.getElementById('elevation-content');
    const elevationCanvas = document.getElementById('elevation-canvas');
    const elevationTooltip = document.getElementById('elevation-tooltip');
    const poiRefreshButton = document.getElementById('poi-refresh-button');

    // Activer le bouton "Recharger les POI"
    if (poiRefreshButton) {
      poiRefreshButton.addEventListener('click', () => {
        // Réinitialise l'état et recharge les POI pour la vue courante
        poiManager.refreshPending = false;
        hidePoiRefreshButton();
        loadPOIForCurrentView(true);
      });
    }


    let backdropElement = null;

    const waypointLayerGroup = L.layerGroup().addTo(map);
// === PERSISTENCE WAYPOINTS — debounce & group hooks (defined early) ===
if (typeof window.__saveWpTimer === 'undefined') window.__saveWpTimer = null;
function saveTraceDebounced(delay = 120) {
  if (typeof saveTraceToLocalStorage !== 'function') return;
  clearTimeout(window.__saveWpTimer);
  window.__saveWpTimer = setTimeout(() => {
    try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); }
  }, delay);
}
function attachWaypointPersistence() {
  try {
    if (!waypointLayerGroup || typeof waypointLayerGroup.on !== 'function') return;
    waypointLayerGroup.off('layeradd', saveTraceDebounced);
    waypointLayerGroup.off('layerremove', saveTraceDebounced);
    waypointLayerGroup.on('layeradd', () => saveTraceDebounced());
    waypointLayerGroup.on('layerremove', () => saveTraceDebounced());
    saveTraceDebounced(10);
  } catch (e) { console.warn('attachWaypointPersistence:', e); }
}
// Attach once after map init
attachWaypointPersistence();
    let waypointCounter = 1;

let gpxLayerGroup = null;
let arrowLayerGroup = null;
let currentGpxDocument = null;
let currentGpxFileName = '';
let currentGeojson = null;
let currentTraceName = '';
let traceNameSource = '';

// Exposer les variables importantes sur window pour la sauvegarde
window.currentGpxDocument = null;
window.currentGpxFileName = '';
window.currentTraceName = '';
window.traceNameSource = '';
let currentElevationData = null;
let elevationHoverMarker = null;
let elevationMouseMoveHandler = null;
let elevationMouseLeaveHandler = null;


    setExportAvailability(false);
    updateWaypointsList();
    updateTraceInfo(null);

    /**
     * Affiche un message utilisateur discret.
     * @param {string} text
     * @param {boolean} isError
     */
    function showMessage(text, isError = false, isHtml = false) {
      if (!messageBox) {
        return;
      }
      const content = text == null ? '' : String(text);
      const trimmed = content.trim();
      if (!trimmed) {
        messageBox.classList.add('hidden');
        messageBox.textContent = '';
        messageBox.classList.remove('error');
        return;
      }
      if (isHtml) {
        messageBox.innerHTML = content;
      } else {
        messageBox.textContent = trimmed;
      }
      messageBox.classList.remove('hidden');
      messageBox.classList.toggle('error', Boolean(isError));
    }

    /**
     * Efface les couches GPX précédemment ajoutées.
     */
    function clearPreviousLayers() {
      if (gpxLayerGroup) {
        map.removeLayer(gpxLayerGroup);
        gpxLayerGroup = null;
      }
      if (arrowLayerGroup) {
        map.removeLayer(arrowLayerGroup);
        arrowLayerGroup = null;
      }
      waypointLayerGroup.clearLayers();
      waypointCounter = 1;
      currentGeojson = null;
      updateWaypointsList();
      updateTraceInfo(null);
      resetElevationDisplay();
    }

    function setExportAvailability(isEnabled) {
      if (!exportButton) {
        return;
      }
      exportButton.disabled = !isEnabled;
      if (!isEnabled) {
        if (gpxNameInput) {
          gpxNameInput.value = '';
        }
        if (fileInfo) {
          fileInfo.style.display = 'none';
        }
        if (currentFilename) {
          currentFilename.textContent = '—';
        }
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '—';
        }
        resetElevationDisplay();
      } else if (fileInfo) {
        fileInfo.style.display = 'block';
        if (traceFileNameLabel && currentGpxFileName) {
          traceFileNameLabel.textContent = currentGpxFileName;
        }
      }
    }

    function normalizeLatLngSegments(latlngs) {
      if (!Array.isArray(latlngs)) {
        return [];
      }
      if (latlngs.length === 0) {
        return [];
      }
      const first = latlngs[0];
      if (Array.isArray(first)) {
        return latlngs;
      }
      return [latlngs];
    }

    function computeBearingDegrees(startLatLng, endLatLng) {
      const toRadians = (value) => (value * Math.PI) / 180;
      const toDegrees = (value) => (value * 180) / Math.PI;
      const phi1 = toRadians(startLatLng.lat);
      const phi2 = toRadians(endLatLng.lat);
      const deltaLambda = toRadians(endLatLng.lng - startLatLng.lng);
      const y = Math.sin(deltaLambda) * Math.cos(phi2);
      const x =
        Math.cos(phi1) * Math.sin(phi2) -
        Math.sin(phi1) * Math.cos(phi2) * Math.cos(deltaLambda);
      const theta = Math.atan2(y, x);
      return (toDegrees(theta) + 360) % 360;
    }

    function escapeHtml(value) {
      if (value === null || value === undefined) {
        return '';
      }
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function sanitizeFileName(name) {
      if (!name) {
        return 'trace';
      }
      const sanitized =
        name
          .replace(/[<>:"/\\|?*]/g, '_')
          .replace(/\s+/g, '_')
          .replace(/_+/g, '_')
          .replace(/^_|_$/g, '')
          .substring(0, 100) || 'trace';
      return sanitized;
    }

    function extractTraceName(xmlDoc, fileName) {
      if (xmlDoc) {
        const trackNames = xmlDoc.querySelectorAll('trk > name');
        for (const trackName of trackNames) {
          const value = trackName.textContent && trackName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-track' };
          }
        }

        const routeNames = xmlDoc.querySelectorAll('rte > name');
        for (const routeName of routeNames) {
          const value = routeName.textContent && routeName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-route' };
          }
        }

        const metadataName = xmlDoc.querySelector('metadata > name');
        if (metadataName) {
          const value = metadataName.textContent && metadataName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-metadata' };
          }
        }
      }

      if (fileName) {
        const withoutExtension = fileName.replace(/\.gpx$/i, '');
        if (withoutExtension.trim()) {
          return { name: withoutExtension.trim(), source: 'filename' };
        }
      }

      return { name: 'Trace sans nom', source: 'default' };
    }

    function displayTraceName(traceName, source) {
      if (!traceNameLabel) {
        return;
      }
      const safeName = traceName || '—';
      traceNameLabel.textContent = safeName;
      let tooltip = '';
      switch (source) {
        case 'gpx-track':
        case 'gpx-route':
        case 'gpx-metadata':
          tooltip = 'Nom extrait du fichier GPX';
          break;
        case 'filename':
          tooltip = 'Nom basé sur le nom de fichier';
          break;
        case 'default':
        default:
          tooltip = 'Nom par défaut (aucune information disponible)';
          break;
      }
      traceNameLabel.setAttribute('title', tooltip);
      traceNameLabel.className = `trace-name trace-name--${source || 'default'}`;
    }

    function haversineDistance(pointA, pointB) {
      if (!pointA || !pointB) {
        return 0;
      }
      const R = 6371000;
      const lat1 = (pointA.lat * Math.PI) / 180;
      const lat2 = (pointB.lat * Math.PI) / 180;
      const dLat = ((pointB.lat - pointA.lat) * Math.PI) / 180;
      const dLng = ((pointB.lng - pointA.lng) * Math.PI) / 180;

      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function calculateElevationStats(points) {
      if (!Array.isArray(points) || points.length === 0) {
        return null;
      }

      let elevationGain = 0;
      let elevationLoss = 0;
      let minElevation = Infinity;
      let maxElevation = -Infinity;
      let sumElevation = 0;

      points.forEach((point, index) => {
        const elevation = point.elevation;
        if (elevation < minElevation) {
          minElevation = elevation;
        }
        if (elevation > maxElevation) {
          maxElevation = elevation;
        }
        sumElevation += elevation;

        if (index > 0) {
          const diff = elevation - points[index - 1].elevation;
          if (diff > 0) {
            elevationGain += diff;
          } else if (diff < 0) {
            elevationLoss += Math.abs(diff);
          }
        }
      });

      return {
        totalDistance: Math.round(points[points.length - 1].distance),
        elevationGain: Math.round(elevationGain),
        elevationLoss: Math.round(elevationLoss),
        minElevation: Math.round(minElevation),
        maxElevation: Math.round(maxElevation),
        avgElevation: Math.round(sumElevation / points.length)
      };
    }

    function simplifyElevationData(points, maxPoints = 1500) {
      if (!Array.isArray(points) || points.length <= maxPoints) {
        return points || [];
      }
      const step = Math.max(1, Math.floor(points.length / maxPoints));
      const simplified = [];
      for (let i = 0; i < points.length; i += step) {
        simplified.push(points[i]);
      }
      if (simplified[simplified.length - 1] !== points[points.length - 1]) {
        simplified.push(points[points.length - 1]);
      }
      return simplified;
    }

    function extractElevationData(geojson, gpxDoc) {
      if (!geojson || !Array.isArray(geojson.features) || !gpxDoc) {
        return null;
      }

      const trackPoints = Array.from(gpxDoc.querySelectorAll('trkpt, rtept'));
      const elevationMap = new Map();
      trackPoints.forEach((trkpt) => {
        const lat = parseFloat(trkpt.getAttribute('lat'));
        const lng = parseFloat(trkpt.getAttribute('lon'));
        const eleNode = trkpt.querySelector('ele');
        if (!Number.isFinite(lat) || !Number.isFinite(lng) || !eleNode) {
          return;
        }
        const elevation = parseFloat(eleNode.textContent);
        if (!Number.isFinite(elevation)) {
          return;
        }
        const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
        elevationMap.set(key, elevation);
      });

      if (elevationMap.size === 0) {
        return null;
      }

      const points = [];
      let previousPoint = null;
      let cumulativeDistance = 0;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
          const elevation = elevationMap.get(key);
          if (!Number.isFinite(elevation)) {
            previousPoint = { lat, lng };
            return;
          }

          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }

          points.push({
            distance: cumulativeDistance,
            elevation,
            lat,
            lng,
            index: points.length
          });

          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (points.length < 2) {
        return null;
      }

      const stats = calculateElevationStats(points);
      if (!stats) {
        return null;
      }

      const simplifiedPoints = simplifyElevationData(points);
      return { points: simplifiedPoints, stats };
    }

    function calculateDistanceOnly(geojson) {
      if (!geojson || !Array.isArray(geojson.features)) {
        return null;
      }
      let cumulativeDistance = 0;
      let previousPoint = null;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }
          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (cumulativeDistance === 0) {
        return null;
      }
      return { distance: cumulativeDistance };
    }

    function updateElevationStats(stats) {
      if (
        !traceDistanceLabel ||
        !traceElevationGainLabel ||
        !traceElevationLossLabel ||
        !traceAltitudeRangeLabel ||
        !profileDistanceValue ||
        !profileElevationGainValue ||
        !profileElevationLossValue
      ) {
        return;
      }

      if (!stats) {
        traceDistanceLabel.textContent = '—';
        traceElevationGainLabel.textContent = '—';
        traceElevationLossLabel.textContent = '—';
        traceAltitudeRangeLabel.textContent = '—';
        profileDistanceValue.textContent = '—';
        profileElevationGainValue.textContent = '—';
        profileElevationLossValue.textContent = '—';
        if (ariaDistance) ariaDistance.textContent = '—';
        if (ariaDPlus) ariaDPlus.textContent = '—';
        if (ariaMin) ariaMin.textContent = '—';
        if (ariaMax) ariaMax.textContent = '—';
        if (elevationProfile) {
          elevationProfile.classList.remove('visible');
          elevationProfile.setAttribute('aria-hidden', 'true');
        }
        return;
      }

      const distanceKm = stats.totalDistance / 1000;
      traceDistanceLabel.textContent = `${distanceKm.toFixed(2)} km`;
      traceElevationGainLabel.textContent = `${stats.elevationGain} m`;
      traceElevationLossLabel.textContent = `${stats.elevationLoss} m`;
      traceAltitudeRangeLabel.textContent = `${stats.minElevation} m - ${stats.maxElevation} m`;

      profileDistanceValue.textContent = `${distanceKm.toFixed(2)} km`;
      profileElevationGainValue.textContent = `${stats.elevationGain} m`;
      profileElevationLossValue.textContent = `${stats.elevationLoss} m`;

      if (ariaDistance) ariaDistance.textContent = `${distanceKm.toFixed(2)} km`;
      if (ariaDPlus) ariaDPlus.textContent = `${stats.elevationGain} m`;
      if (ariaMin) ariaMin.textContent = `${stats.minElevation} m`;
      if (ariaMax) ariaMax.textContent = `${stats.maxElevation} m`;

      if (elevationProfile) {
        elevationProfile.classList.add('visible');
        elevationProfile.setAttribute('aria-hidden', 'false');
      }
    }

    function resetElevationDisplay() {
      currentElevationData = null;
      if (elevationHoverMarker) {
        map.removeLayer(elevationHoverMarker);
        elevationHoverMarker = null;
      }
      removeElevationInteraction();
      updateElevationStats(null);
      if (elevationTooltip) {
        elevationTooltip.style.display = 'none';
      }
      if (elevationContent && elevationCanvas) {
        const ctx = elevationCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, elevationCanvas.width, elevationCanvas.height);
        }
      }
      if (elevationProfile) {
        elevationProfile.classList.remove('collapsed');
        elevationProfile.setAttribute('aria-hidden', 'true');
      }
      if (elevationCollapseButton) {
        elevationCollapseButton.setAttribute('aria-expanded', 'true');
        elevationCollapseButton.setAttribute('aria-label', 'Réduire le profil');
      }
      map.invalidateSize();
    }

    function drawElevationProfile(canvas, points, stats) {
      if (!canvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return;
      }

      const width = canvas.width;
      const height = canvas.height;

      ctx.clearRect(0, 0, width, height);

      const margin = { top: 20, right: 20, bottom: 40, left: 60 };
      const chartWidth = Math.max(10, width - margin.left - margin.right);
      const chartHeight = Math.max(10, height - margin.top - margin.bottom);
      const maxDistance = stats.totalDistance || 1;
      const minEle = stats.minElevation - 20;
      const maxEle = stats.maxElevation + 20;

      const xScale = (distance) =>
        margin.left + (Math.min(distance, maxDistance) / maxDistance) * chartWidth;
      const yScale = (elevation) =>
        margin.top + chartHeight - ((elevation - minEle) / (maxEle - minEle)) * chartHeight;

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.lineWidth = 1;

      const elevationStep = Math.max(10, Math.ceil((maxEle - minEle) / 5 / 50) * 50);
      for (let ele = Math.ceil(minEle / elevationStep) * elevationStep; ele <= maxEle; ele += elevationStep) {
        const y = yScale(ele);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(width - margin.right, y);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(`${Math.round(ele)} m`, margin.left - 5, y + 4);
      }

      const distanceStepRaw = Math.max(100, Math.ceil(maxDistance / 5 / 1000) * 1000);
      for (let dist = 0; dist <= maxDistance; dist += distanceStepRaw) {
        const x = xScale(dist);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, height - margin.bottom);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${(dist / 1000).toFixed(1)} km`, x, height - margin.bottom + 18);
      }

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.lineTo(xScale(points[points.length - 1].distance), height - margin.bottom);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, margin.top, 0, height - margin.bottom);
      gradient.addColorStop(0, 'rgba(25, 118, 210, 0.3)');
      gradient.addColorStop(1, 'rgba(25, 118, 210, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.strokeStyle = '#1976d2';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#424242';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Distance (km)', width / 2, height - 8);

      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Altitude (m)', 0, 0);
      ctx.restore();
    }

    function renderElevationProfile() {
      if (
        !currentElevationData ||
        !currentElevationData.points ||
        !currentElevationData.stats ||
        !elevationCanvas ||
        !elevationProfile
      ) {
        return;
      }
      if (
        elevationProfile.classList.contains('collapsed') ||
        !elevationProfile.classList.contains('visible')
      ) {
        return;
      }
      sizeCanvasToParent();
      drawElevationProfile(elevationCanvas, currentElevationData.points, currentElevationData.stats);
      setupElevationInteraction(currentElevationData.points, currentElevationData.stats);
    }

    function findClosestElevationPoint(canvas, points, stats, event) {
      if (!canvas || !points || !stats) {
        return null;
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const margin = { left: 60, right: 20 };
      const chartWidth = canvas.width - margin.left - margin.right;
      const relativeX = x - margin.left;
      if (relativeX < 0 || relativeX > chartWidth) {
        return null;
      }
      const distance = (relativeX / chartWidth) * stats.totalDistance;
      let closestPoint = points[0];
      let minDiff = Math.abs(points[0].distance - distance);
      for (let i = 1; i < points.length; i++) {
        const diff = Math.abs(points[i].distance - distance);
        if (diff < minDiff) {
          minDiff = diff;
          closestPoint = points[i];
        }
      }
      return { point: closestPoint, canvasX: x };
    }

    function removeElevationInteraction() {
      if (!elevationCanvas) {
        return;
      }
      if (elevationMouseMoveHandler) {
        elevationCanvas.removeEventListener('mousemove', elevationMouseMoveHandler);
      }
      if (elevationMouseLeaveHandler) {
        elevationCanvas.removeEventListener('mouseleave', elevationMouseLeaveHandler);
      }
      elevationMouseMoveHandler = null;
      elevationMouseLeaveHandler = null;
    }

    function setupElevationInteraction(points, stats) {
      if (!elevationCanvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      removeElevationInteraction();

      elevationMouseMoveHandler = (event) => {
        const result = findClosestElevationPoint(elevationCanvas, points, stats, event);
        if (!result) {
          if (elevationTooltip) {
            elevationTooltip.style.display = 'none';
          }
          if (elevationHoverMarker) {
            map.removeLayer(elevationHoverMarker);
            elevationHoverMarker = null;
          }
          return;
        }

        const { point, canvasX } = result;
        if (elevationTooltip) {
          const rect = elevationCanvas.getBoundingClientRect();
          elevationTooltip.style.display = 'block';
          elevationTooltip.style.left = `${canvasX + 15}px`;
          elevationTooltip.style.top = `${event.clientY - rect.top + 15}px`;
          const distanceElement = document.getElementById('tooltip-distance');
          const elevationElement = document.getElementById('tooltip-elevation');
          if (distanceElement) {
            distanceElement.textContent = `${(point.distance / 1000).toFixed(2)} km`;
          }
          if (elevationElement) {
            elevationElement.textContent = `${point.elevation.toFixed(0)} m`;
          }
        }

        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
        }
        elevationHoverMarker = L.circleMarker([point.lat, point.lng], {
          radius: 7,
          fillColor: '#ff5722',
          fillOpacity: 0.9,
          color: '#ffffff',
          weight: 2,
          interactive: false
        }).addTo(map);
      };

      elevationMouseLeaveHandler = () => {
        if (elevationTooltip) {
          elevationTooltip.style.display = 'none';
        }
        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
          elevationHoverMarker = null;
        }
      };

      elevationCanvas.addEventListener('mousemove', elevationMouseMoveHandler);
      elevationCanvas.addEventListener('mouseleave', elevationMouseLeaveHandler);
    }

    function setElevationCollapsed(collapsed) {
      if (!elevationProfile || !elevationCollapseButton) {
        return;
      }
      if (!elevationProfile.classList.contains('visible') && !collapsed) {
        return;
      }

      elevationProfile.classList.toggle('collapsed', collapsed);
      elevationCollapseButton.setAttribute('aria-expanded', String(!collapsed));
      elevationCollapseButton.setAttribute(
        'aria-label',
        collapsed ? 'Agrandir le profil' : 'Réduire le profil'
      );

      if (!collapsed) {
        requestAnimationFrame(() => {
          renderElevationProfile();
          map.invalidateSize();
        });
      } else {
        removeElevationInteraction();
        map.invalidateSize();
      }
    }

    function createWaypointPopupHtml(name) {
      const safeName = escapeHtml(name);
      return `
        <div class="waypoint-popup">
          <label for="waypoint-name-input">Nom du waypoint</label>
          <input id="waypoint-name-input" class="waypoint-name-input" type="text" value="${safeName}" />
          <div class="waypoint-popup-buttons">
            <button type="button" data-action="save">Enregistrer</button>
            <button type="button" data-action="delete">Supprimer</button>
          </div>
        </div>
      `;
    }

    function attachWaypointPopupHandlers(marker, popup) {
      const container = popup.getElement();
      if (!container) {
        return;
      }

      const input = container.querySelector('.waypoint-name-input');
      if (input) {
        input.value = marker.waypointName;
        input.focus();
        input.select();
      }

      const saveAction = () => {
        const newName = input && input.value.trim() ? input.value.trim() : marker.waypointName;
        marker.waypointName = newName;
        marker.setPopupContent(createWaypointPopupHtml(marker.waypointName));
        marker.openPopup();
        updateWaypointsList();
      };

      const deleteAction = () => {
        waypointLayerGroup.removeLayer(marker);
        map.closePopup(popup);
        updateWaypointsList();
      
        // Sauvegarde immédiate (sans debounce) pour figer l’état
        if (typeof saveTraceToLocalStorage === 'function') {
          try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); }
        }
      };

      if (input) {
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveAction();
          }
        });
      }

      const saveButton = container.querySelector('[data-action="save"]');
      if (saveButton) {
        saveButton.addEventListener('click', saveAction);
      }

      const deleteButton = container.querySelector('[data-action="delete"]');
      if (deleteButton) {
        deleteButton.addEventListener('click', deleteAction);
      }
    }

    
function createWaypointMarker(latlng, name = '') {
  const trimmedName = name && name.trim() ? name.trim() : '';
  const finalName = trimmedName || `Waypoint ${waypointCounter}`;
  waypointCounter += 1;

  // Créer l'icône personnalisée
  const icon = L.divIcon({
    className: 'waypoint-marker',
    html: `
      <div class="waypoint-marker-inner">
        <div class="waypoint-marker-pin">
          <span class="waypoint-marker-icon">📍</span>
        </div>
      </div>
    `,
    iconSize: [28, 36],
    iconAnchor: [14, 36],
    popupAnchor: [0, -36]
  });

  const marker = L.marker(latlng, { 
    icon: icon,
    draggable: false, 
    bubblingMouseEvents: false,
    riseOnHover: true
  });
  
  marker.waypointName = finalName;
  marker.bindPopup(createWaypointPopupHtml(finalName));
  marker.on('popupopen', (event) => {
    attachWaypointPopupHandlers(marker, event.popup);
  });
  marker.bindTooltip(
    () => marker.waypointName,
    {
      direction: 'top',
      offset: [0, -36]
    }
  );

  waypointLayerGroup.addLayer(marker);
  updateWaypointsList();
  
  if (typeof marker.on === 'function') {
    marker.on('remove', () => { if (typeof saveTraceDebounced === 'function') saveTraceDebounced(50); });
  }
// Auto-save right after waypoint creation
  if (typeof saveTraceToLocalStorage === 'function') {
    setTimeout(() => saveTraceToLocalStorage(), 50);
  }
  return marker;
}


    function addWaypointsFromFeatures(features) {
      if (!Array.isArray(features)) {
        return;
      }
      features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const properties = feature.properties || {};
        const baseName = properties.name || properties.description || '';

        if (feature.geometry.type === 'Point') {
          const coords = feature.geometry.coordinates;
          if (Array.isArray(coords) && coords.length >= 2) {
            createWaypointMarker(L.latLng(coords[1], coords[0]), baseName);
          }
        } else if (feature.geometry.type === 'MultiPoint') {
          const points = feature.geometry.coordinates || [];
          points.forEach((coords, index) => {
            if (Array.isArray(coords) && coords.length >= 2) {
              const name = baseName ? `${baseName} (${index + 1})` : '';
              createWaypointMarker(L.latLng(coords[1], coords[0]), name);
            }
          });
        }
      });
    }

    function handleAddWaypointFromTrack(latlng) {
      const suggestedName = `Waypoint ${waypointCounter}`;
      const userInput = prompt('Nom du waypoint ?', suggestedName);
      if (userInput === null) {
        return;
      }
      const finalName = userInput.trim() ? userInput.trim() : suggestedName;
      const marker = createWaypointMarker(latlng, finalName);
      marker.openPopup();
    }

    function getWaypointMarkers() {
      const markers = [];
      waypointLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          markers.push(layer);
        } else if (layer && typeof layer.getLayers === 'function') {
          layer.getLayers().forEach((child) => {
            if (child instanceof L.Marker) {
              markers.push(child);
            }
          });
        }
      });
      return markers;
    }

    function updateWaypointsList() {
if (!waypointsList || !waypointCountLabel || !waypointsSection) {
        return;
      }

      const markers = getWaypointMarkers();
      waypointCountLabel.textContent = markers.length;
      waypointsSection.style.display = markers.length > 0 ? 'block' : 'none';
      waypointsList.innerHTML = '';

      markers.forEach((marker) => {
        const item = document.createElement('div');
        item.className = 'waypoint-item';
        item.innerHTML = `
          <span class="waypoint-icon" aria-hidden="true">📍</span>
          <span class="waypoint-name">${escapeHtml(marker.waypointName)}</span>
          <button class="btn-icon-small" data-action="center" title="Centrer">🎯</button>
          <button class="btn-icon-small" data-action="delete" title="Supprimer">🗑️</button>
        `;

        const centerButton = item.querySelector('[data-action="center"]');
        if (centerButton) {
          centerButton.addEventListener('click', () => {
            const latlng = marker.getLatLng();
            if (latlng) {
              map.setView(latlng, Math.max(map.getZoom(), 16));
              marker.openPopup();
            }
          });
        }

        const deleteButton = item.querySelector('[data-action="delete"]');
        if (deleteButton) {
          deleteButton.addEventListener('click', () => {
            waypointLayerGroup.removeLayer(marker);
            updateWaypointsList();
          
        
    
        // Persist deletion (debounced + immediate safeguard)
        if (typeof saveTraceDebounced === 'function') saveTraceDebounced(60);
        if (typeof saveTraceToLocalStorage === 'function') { try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); } }
if (typeof saveTraceDebounced === 'function') saveTraceDebounced(50);
// Persist deletion
        if (typeof saveTraceDebounced === 'function') saveTraceDebounced(50);
    });
        }

        
waypointsList.appendChild(item);
      });
    }

    function updateTraceInfo(info) {
      if (!traceInfoSection || !traceNameLabel || !pointCountLabel || !traceTypeLabel) {
        return;
      }

      if (!info) {
        traceInfoSection.style.display = 'none';
        displayTraceName('—', 'default');
        pointCountLabel.textContent = '—';
        traceTypeLabel.textContent = '—';
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '—';
        }
        return;
      }

      traceInfoSection.style.display = 'block';
      displayTraceName(currentTraceName || info.name || '—', traceNameSource || 'default');
      pointCountLabel.textContent = Number.isFinite(info.pointCount) ? info.pointCount : '—';
      traceTypeLabel.textContent = info.type || '—';
      if (traceFileNameLabel) {
        traceFileNameLabel.textContent = currentGpxFileName || '—';
      }
    }

    function createArrowIconHtml(bearing) {
      const rotation = ((bearing - 90) + 360) % 360;
      return `<span class="direction-arrow" style="display:inline-block; color:#ff5722; font-size:1rem; line-height:1; text-shadow:0 0 2px rgba(0,0,0,0.5); transform-origin:center; transform: rotate(${rotation}deg);">➤</span>`;
    }

    function createArrowMarker(point, bearing) {
      return L.marker(point, {
        icon: L.divIcon({
          className: '',
          html: createArrowIconHtml(bearing),
          iconSize: [16, 16],
          iconAnchor: [8, 8]
        }),
        interactive: false,
        keyboard: false
      });
    }

    function createArrowMarkers(layer) {
      const arrowMarkers = [];
      const latLngs = normalizeLatLngSegments(layer.getLatLngs());
      const arrowSpacingMeters = 2500;

      latLngs.forEach((segment) => {
        if (!Array.isArray(segment) || segment.length < 2) {
          return;
        }

        let previousPoint = L.latLng(segment[0]);
        let distanceFromLastArrow = 0;
        let totalSegmentDistance = 0;
        const segmentMarkers = [];

        for (let i = 1; i < segment.length; i++) {
          const currentPoint = L.latLng(segment[i]);
          let segmentDistance = map.distance(previousPoint, currentPoint);
          let segmentStart = previousPoint;

          if (segmentDistance === 0) {
            previousPoint = currentPoint;
            continue;
          }

          totalSegmentDistance += segmentDistance;

          while (distanceFromLastArrow + segmentDistance >= arrowSpacingMeters) {
            const distanceNeeded = arrowSpacingMeters - distanceFromLastArrow;
            const ratio = distanceNeeded / segmentDistance;
            const interpolatedLat =
              segmentStart.lat + (currentPoint.lat - segmentStart.lat) * ratio;
            const interpolatedLng =
              segmentStart.lng + (currentPoint.lng - segmentStart.lng) * ratio;
            const arrowPoint = L.latLng(interpolatedLat, interpolatedLng);
            const bearing = computeBearingDegrees(segmentStart, currentPoint);

            const marker = createArrowMarker(arrowPoint, bearing);

            arrowMarkers.push(marker);
            segmentMarkers.push(marker);

            segmentStart = arrowPoint;
            segmentDistance = map.distance(segmentStart, currentPoint);
            if (segmentDistance === 0) {
              break;
            }
            distanceFromLastArrow = 0;
          }

          distanceFromLastArrow += segmentDistance;
          previousPoint = currentPoint;
        }

        if (segmentMarkers.length === 0 && totalSegmentDistance > 0) {
          const targetDistance = totalSegmentDistance / 2;
          let accumulated = 0;
          for (let i = 1; i < segment.length; i++) {
            const start = L.latLng(segment[i - 1]);
            const end = L.latLng(segment[i]);
            const distance = map.distance(start, end);
            if (distance === 0) {
              continue;
            }
            if (accumulated + distance >= targetDistance) {
              const ratio = (targetDistance - accumulated) / distance;
              const lat = start.lat + (end.lat - start.lat) * ratio;
              const lng = start.lng + (end.lng - start.lng) * ratio;
              const point = L.latLng(lat, lng);
              const bearing = computeBearingDegrees(start, end);
              const marker = createArrowMarker(point, bearing);
              arrowMarkers.push(marker);
              segmentMarkers.push(marker);
              break;
            }
            accumulated += distance;
          }
        }
      });

      return arrowMarkers;
    }

    function computeTraceInfo(lineFeatures, geojson) {
      if (!Array.isArray(lineFeatures) || lineFeatures.length === 0) {
        return null;
      }

      const first = lineFeatures[0];
      const properties = first.properties || {};
      const name = properties.name || properties.description || (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : 'Trace');
      let pointCount = 0;
      let type = properties.kind || first.geometry?.type || '—';

      lineFeatures.forEach((feature) => {
        if (!feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        if (geometry.type === 'LineString') {
          pointCount += Array.isArray(geometry.coordinates) ? geometry.coordinates.length : 0;
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            pointCount += Array.isArray(segment) ? segment.length : 0;
          });
        }
        if (!type && geometry.type) {
          type = geometry.type;
        }
        if (!properties.kind && feature.properties && feature.properties.kind) {
          type = feature.properties.kind;
        }
      });

      if (!type && geojson && Array.isArray(geojson.features)) {
        const kinds = geojson.features
          .map((feature) => feature?.properties?.kind)
          .filter(Boolean);
        if (kinds.length > 0) {
          type = kinds[0];
        }
      }

      return {
        name,
        pointCount,
        type: type || '—'
      };
    }

    function displayGeoJSON(geojsonData) {
      clearPreviousLayers();

      currentGeojson = geojsonData;

      const lineFeatures = [];
      const pointFeatures = [];

      if (geojsonData && Array.isArray(geojsonData.features)) {
        geojsonData.features.forEach((feature) => {
          const geometryType = feature && feature.geometry && feature.geometry.type;
          if (geometryType === 'LineString' || geometryType === 'MultiLineString') {
            lineFeatures.push(feature);
          } else if (geometryType === 'Point' || geometryType === 'MultiPoint') {
            pointFeatures.push(feature);
          }
        });
      }

      const linesFeatureCollection = {
        type: 'FeatureCollection',
        features: lineFeatures
      };

      gpxLayerGroup = L.geoJSON(linesFeatureCollection, {
        style: function () {
          return {
            color: '#ff5722',
            weight: 3,
            opacity: 0.9
          };
        }
      }).addTo(map);

      const arrowLayers = [];
      gpxLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
          layer.on('click', (event) => {
            if (event.originalEvent) {
              event.originalEvent.preventDefault();
              event.originalEvent.stopPropagation();
            }
            handleAddWaypointFromTrack(event.latlng);
          });

          if (
            typeof L.polylineDecorator === 'function' &&
            L.Symbol &&
            typeof L.Symbol.arrowHead === 'function'
          ) {
            const decorator = L.polylineDecorator(layer, {
              patterns: [
                {
                  offset: '5%',
                  repeat: '50%',
                  symbol: L.Symbol.arrowHead({
                    pixelSize: 10,
                    headAngle: 60,
                    polygon: false,
                    pathOptions: {
                      stroke: true,
                      color: '#ff5722',
                      weight: 2,
                      opacity: 0.9
                    }
                  })
                }
              ]
            });
            arrowLayers.push(decorator);
          } else {
            const markers = createArrowMarkers(layer);
            if (markers.length > 0) {
              arrowLayers.push(L.layerGroup(markers));
            }
          }
        }
      });

      if (arrowLayers.length > 0) {
        arrowLayerGroup = L.layerGroup(arrowLayers).addTo(map);
      }

      if (pointFeatures.length > 0) {
        addWaypointsFromFeatures(pointFeatures);
      } else {
        updateWaypointsList();
      }

      let bounds = null;
      if (gpxLayerGroup.getLayers().length > 0) {
        bounds = gpxLayerGroup.getBounds();
      }
      waypointLayerGroup.eachLayer((layer) => {
        if (typeof layer.getLatLng !== 'function') {
          return;
        }
        const latlng = layer.getLatLng();
        if (!latlng) {
          return;
        }
        if (!bounds) {
          bounds = L.latLngBounds(latlng, latlng);
        } else {
          bounds.extend(latlng);
        }
      });

      if (bounds && typeof bounds.isValid === 'function' && bounds.isValid()) {
        map.fitBounds(bounds.pad(0.1));
      }

      updateTraceInfo(computeTraceInfo(lineFeatures, geojsonData));
      currentGeojson = geojsonData;
    }

    /**
     * Traite le fichier GPX sélectionné.
     * @param {File} file
     */
    async function handleFile(file) {
      if (!file) {
        return;
      }

      setExportAvailability(false);
      currentGpxDocument = null;
      currentGpxFileName = '';
      currentTraceName = '';
      traceNameSource = '';
      displayTraceName('—', 'default');
      updateTraceInfo(null);

      if (gpxNameInput) {
        gpxNameInput.value = file && file.name ? file.name.replace(/\.gpx$/i, '') : '';
      }

      if (!file.name.toLowerCase().endsWith('.gpx')) {
        showMessage('Veuillez sélectionner un fichier .gpx.', true);
        return;
      }

      const reader = new FileReader();

      reader.onload = async function (event) {
        try {
          showMessage('Chargement de la trace GPX…');
          const parser = new DOMParser();
          const xml = parser.parseFromString(event.target.result, 'application/xml');
          const parseError = xml.querySelector('parsererror');
          if (parseError) {
            throw new Error('Fichier GPX invalide.');
          }

          currentGpxDocument = window.currentGpxDocument = xml;
          currentGpxFileName = window.currentGpxFileName = file.name;
          if (currentFilename) {
            currentFilename.textContent = file.name;
          }
          if (traceFileNameLabel) {
            traceFileNameLabel.textContent = file.name;
          }

          const extractedTrace = extractTraceName(xml, file.name);
          currentTraceName = window.currentTraceName = extractedTrace.name;
          traceNameSource = window.traceNameSource = extractedTrace.source;
          if (gpxNameInput) {
            gpxNameInput.value = currentTraceName;
          }
          displayTraceName(currentTraceName, traceNameSource);

          const geojson = convertGpxToGeoJSON(xml);

          if (!geojson || !geojson.features || geojson.features.length === 0) {
            throw new Error('La trace GPX est vide ou invalide.');
          }

          setExportAvailability(true);
          displayGeoJSON(geojson);
    if (typeof attachWaypointPersistence === 'function') attachWaypointPersistence();
          // Guarded elevation render after import
          if (typeof ensureElevationRendered === 'function') ensureElevationRendered(12);

          currentElevationData = currentElevationData = window.currentElevationData = extractElevationData(geojson, xml);
      let noElevationData = false;
          if (currentElevationData) {
            updateElevationStats(currentElevationData.stats);
            setElevationCollapsed(false);
            requestAnimationFrame(() => renderElevationProfile());
          } else {
            updateElevationStats(null);
            const distanceOnly = calculateDistanceOnly(geojson);
            if (distanceOnly && traceDistanceLabel) {
              traceDistanceLabel.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
              if (profileDistanceValue) {
                profileDistanceValue.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
              }
              if (ariaDistance) {
                ariaDistance.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
              }
            }
            if (traceElevationGainLabel) {
              traceElevationGainLabel.textContent = 'N/A';
            }
            if (traceElevationLossLabel) {
              traceElevationLossLabel.textContent = 'N/A';
            }
            if (traceAltitudeRangeLabel) {
              traceAltitudeRangeLabel.textContent = 'N/A';
            }
            if (profileElevationGainValue) {
              profileElevationGainValue.textContent = 'N/A';
            }
            if (profileElevationLossValue) {
              profileElevationLossValue.textContent = 'N/A';
            }
            if (ariaDPlus) {
              ariaDPlus.textContent = 'N/A';
            }
            if (ariaMin) {
              ariaMin.textContent = 'N/A';
            }
            if (ariaMax) {
              ariaMax.textContent = 'N/A';
            }
            if (elevationProfile) {
              elevationProfile.setAttribute('aria-hidden', 'true');
            }
            noElevationData = true;
          }

          let successMessage = '';
          switch (traceNameSource) {
            case 'gpx-track':
            case 'gpx-route':
            case 'gpx-metadata':
              successMessage = `Trace "<strong>${escapeHtml(currentTraceName)}</strong>" chargée avec succès.`;
              break;
            case 'filename':
              successMessage = `Fichier "<strong>${escapeHtml(currentTraceName)}</strong>" chargé (aucun nom dans le GPX).`;
              break;
            case 'default':
            default:
              successMessage = 'Trace chargée (aucun nom disponible).';
              break;
          }
          if (noElevationData) {
            successMessage += '<br><small>Cette trace ne contient pas de données d\'élévation.</small>';
          }
          showMessage(successMessage, false, true);
          
          // Sauvegarder la trace après chargement réussi
          setTimeout(() => {
            if (typeof saveTraceToLocalStorage === 'function') {
              saveTraceToLocalStorage();
              console.log('Trace sauvegardée après import');
            }
          }, 200);

          
          // Sauvegarder automatiquement la trace chargée
setTimeout(() => { if (typeof saveTraceToLocalStorage === 'function') saveTraceToLocalStorage(); }, 500);
        } catch (error) {
          console.error(error);
          showMessage(error.message || 'Impossible de lire ce fichier GPX.', true);
          clearPreviousLayers();
          currentGpxDocument = null;
          currentGpxFileName = '';
          currentTraceName = '';
          traceNameSource = '';
          displayTraceName('—', 'default');
          setExportAvailability(false);
        }
      };

      reader.onerror = function () {
        showMessage('Erreur de lecture du fichier.', true);
        currentGpxDocument = null;
        currentGpxFileName = '';
        currentTraceName = '';
        traceNameSource = '';
        displayTraceName('—', 'default');
        setExportAvailability(false);
      };

      reader.readAsText(file);
    }

    function exportUpdatedGpx() {
      if (!currentGpxDocument) {
        showMessage('Aucune trace GPX à exporter.', true);
        return;
      }

      const xmlDoc = currentGpxDocument.cloneNode(true);
      const gpxRoot = xmlDoc && xmlDoc.documentElement ? xmlDoc.documentElement : null;

      if (!gpxRoot) {
        showMessage('Impossible de préparer le fichier GPX.', true);
        return;
      }

      const existingWaypoints = xmlDoc.querySelectorAll('wpt');
      existingWaypoints.forEach((node) => {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });

      const markers = getWaypointMarkers();
      markers.forEach((marker) => {
        if (typeof marker.getLatLng !== 'function') {
          return;
        }
        const latlng = marker.getLatLng();
        if (!latlng) {
          return;
        }

        const wptNode = xmlDoc.createElement('wpt');
        wptNode.setAttribute('lat', latlng.lat.toFixed(6));
        wptNode.setAttribute('lon', latlng.lng.toFixed(6));

        if (marker.waypointName) {
          const nameNode = xmlDoc.createElement('name');
          nameNode.textContent = marker.waypointName;
          wptNode.appendChild(nameNode);
        }

        gpxRoot.appendChild(wptNode);
      });

      const serializer = new XMLSerializer();
      let gpxString = serializer.serializeToString(xmlDoc);
      if (!gpxString.startsWith('<?xml')) {
        gpxString = `<?xml version="1.0" encoding="UTF-8"?>\n${gpxString}`;
      }

      const blob = new Blob([gpxString], { type: 'application/gpx+xml' });
      const url = URL.createObjectURL(blob);

      const explicitName = gpxNameInput && gpxNameInput.value.trim() ? gpxNameInput.value.trim() : '';
      const baseName =
        explicitName ||
        currentTraceName ||
        (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : '') ||
        'trace';
      const sanitizedName = sanitizeFileName(baseName);
      const downloadName = `${sanitizedName}_with_waypoints.gpx`;

      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = downloadName;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);

      setTimeout(() => {
        URL.revokeObjectURL(url);
      }, 0);

      showMessage(`Fichier "${downloadName}" exporté.`);
    }

    function togglePanel(open) {
      if (!toolsPanel) {
        return;
      }
      const shouldOpen = open !== undefined ? open : !toolsPanel.classList.contains('open');
      if (shouldOpen) {
        toolsPanel.classList.add('open');
        menuToggle?.setAttribute('aria-expanded', 'true');
        if (!backdropElement) {
          backdropElement = document.createElement('div');
          backdropElement.className = 'panel-backdrop';
          backdropElement.addEventListener('click', () => {
            togglePanel(false);
          });
          document.body.appendChild(backdropElement);
        }
      } else {
        toolsPanel.classList.remove('open');
        menuToggle?.setAttribute('aria-expanded', 'false');
        if (backdropElement) {
          backdropElement.remove();
          backdropElement = null;
        }
      }
      map.invalidateSize();
    }

    initPOIManager();

    // Gestion du clic sur le bouton pour ouvrir le sélecteur de fichier
    importButton.addEventListener('click', () => fileInput.click());

    if (typeof attachWaypointPersistence === 'function') attachWaypointPersistence();
    if (exportButton) {
    // Ensure local saved trace is loaded AFTER map & layers are ready
    setTimeout(() => {
      if (typeof loadTraceFromLocalStorage === 'function') {
        loadTraceFromLocalStorage();
      }
    }, 300);

      exportButton.addEventListener('click', exportUpdatedGpx);
    }

    if (menuToggle) {
      menuToggle.addEventListener('click', () => togglePanel(true));
    }

    if (closePanel) {
      closePanel.addEventListener('click', () => togglePanel(false));
    }

    if (elevationHeader && elevationProfile) {
      elevationHeader.addEventListener('click', (event) => {
        if (event.target === elevationCollapseButton) {
          return;
        }
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    if (elevationCollapseButton && elevationProfile) {
      elevationCollapseButton.addEventListener('click', (event) => {
        event.stopPropagation();
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    // Gestion du changement de fichier via le sélecteur
    fileInput.addEventListener('change', (event) => {
      const selectedFile = event.target.files && event.target.files[0];
      handleFile(selectedFile);
      fileInput.value = '';
    });

    if (clearWaypointsButton) {
      clearWaypointsButton.addEventListener('click', () => {
        waypointLayerGroup.clearLayers();
        updateWaypointsList();
      
      if (typeof saveTraceDebounced === 'function') saveTraceDebounced(60);
      if (typeof saveTraceToLocalStorage === 'function') { try { saveTraceToLocalStorage(); } catch(e) {} }
  // FINAL SAFETY: persist the current state after any list refresh
  if (window.currentGpxDocument && typeof saveTraceDebounced === 'function') saveTraceDebounced(80);

});
    }

    function handleDragEnter(zone, event) {
      event.preventDefault();
      event.stopPropagation();
      zone.classList.add('dragover');
    }

    function handleDragLeave(zone, event) {
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
    }

    function handleDrop(zone, event) {
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
      const files = event.dataTransfer && event.dataTransfer.files;
      if (files && files.length > 0) {
        handleFile(files[0]);
      }
    }

    if (panelDropZone) {
      ['dragenter', 'dragover'].forEach((eventName) => {
        panelDropZone.addEventListener(eventName, (event) => handleDragEnter(panelDropZone, event));
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        panelDropZone.addEventListener(eventName, (event) => {
          if (eventName === 'drop') {
            handleDrop(panelDropZone, event);
          } else {
            handleDragLeave(panelDropZone, event);
          }
        });
      });
    }

    // Gestion du drag & drop sur la carte
    const mapContainer = document.querySelector('#map');
    if (mapContainer) {
      ['dragenter', 'dragover'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
        });
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (eventName === 'drop') {
            const droppedFiles = event.dataTransfer && event.dataTransfer.files;
            if (droppedFiles && droppedFiles.length > 0) {
              handleFile(droppedFiles[0]);
            }
          }
        });
      });
    }

    // Empêche le navigateur d'ouvrir le fichier en dehors de la zone prévue
    document.addEventListener('dragover', (event) => {
      event.preventDefault();
    });
    document.addEventListener('drop', (event) => {
      event.preventDefault();
    });

    // S'assure que la carte s'ajuste lors des changements de taille de fenêtre
    window.addEventListener('resize', () => {
      map.invalidateSize();
      requestAnimationFrame(() => renderElevationProfile());
    });

    // Fermer le panneau avec la touche Échap sur mobile
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        togglePanel(false);
      }
    });
  </script>

<script>
// === Géolocalisation : manager & fonctions ===
const geolocationManager = {
  enabled: false,
  watchId: null,
  currentPosition: null,
  marker: null,
  accuracyCircle: null,
  lastUpdate: null,
  refreshInterval: 30000,
  refreshTimer: null,
  // DOM
  toggleCheckbox: null,
  statusElement: null,
  infoContainer: null,
  errorContainer: null,
  centerButton: null,
  // Options
  options: { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 },
};

function initGeolocation() {
  geolocationManager.toggleCheckbox = document.getElementById('geolocation-toggle');
  geolocationManager.statusElement = document.getElementById('geolocation-status');
  geolocationManager.infoContainer = document.getElementById('geolocation-info');
  geolocationManager.errorContainer = document.getElementById('geolocation-error');
  geolocationManager.centerButton = document.getElementById('center-on-position');

  if (!navigator.geolocation) {
    showGeolocationError('Votre navigateur ne supporte pas la géolocalisation.');
    if (geolocationManager.toggleCheckbox) geolocationManager.toggleCheckbox.disabled = true;
    return;
  }

  const savedPreference = loadGeolocationPreference();
  if (savedPreference && geolocationManager.toggleCheckbox) {
    geolocationManager.toggleCheckbox.checked = true;
    enableGeolocation();
  }

  attachGeolocationHandlers();
}

function enableGeolocation() {
  if (!navigator.geolocation) return;
  geolocationManager.enabled = true;
  if (geolocationManager.infoContainer) geolocationManager.infoContainer.style.display = 'block';
  if (geolocationManager.errorContainer) geolocationManager.errorContainer.style.display = 'none';
  updateGeolocationStatus('Recherche de position...', 'searching');
  getCurrentPosition();
  startGeolocationRefresh();
  saveGeolocationPreference(true);
}

function disableGeolocation() {
  geolocationManager.enabled = false;
  stopGeolocationRefresh();
  removeGeolocationMarker();
  if (geolocationManager.infoContainer) geolocationManager.infoContainer.style.display = 'none';
  if (geolocationManager.errorContainer) geolocationManager.errorContainer.style.display = 'none';
  saveGeolocationPreference(false);
}

function getCurrentPosition() {
  if (!navigator.geolocation || !geolocationManager.enabled) return;
  navigator.geolocation.getCurrentPosition(
    handleGeolocationSuccess,
    handleGeolocationError,
    geolocationManager.options
  );
}

function handleGeolocationSuccess(position) {
  if (!geolocationManager.enabled) return;
  const { latitude, longitude, accuracy } = position.coords;
  geolocationManager.currentPosition = { lat: latitude, lng: longitude, accuracy, timestamp: position.timestamp };
  geolocationManager.lastUpdate = Date.now();
  updateGeolocationMarker(latitude, longitude, accuracy);
  const accuracyText = accuracy < 50 ? 'précise' : accuracy < 100 ? 'moyenne' : 'approximative';
  updateGeolocationStatus(`Position obtenue (précision ${accuracyText}: ±${Math.round(accuracy)}m)`, 'active');
  if (geolocationManager.centerButton) geolocationManager.centerButton.disabled = false;
  hideGeolocationError();

  // Centrage automatique à chaque mise à jour
  centerOnUserPosition();
}

function handleGeolocationError(error) {
  if (!geolocationManager.enabled) return;
  let message = '';
  switch (error.code) {
    case error.PERMISSION_DENIED: message = 'Permission de localisation refusée. Veuillez autoriser l\'accès dans les paramètres de votre navigateur.'; break;
    case error.POSITION_UNAVAILABLE: message = 'Position indisponible. Vérifiez votre connexion et vos paramètres de localisation.'; break;
    case error.TIMEOUT: message = 'Délai d\'attente dépassé. Réessayez dans quelques instants.'; break;
    default: message = 'Erreur de géolocalisation inconnue.';
  }
  updateGeolocationStatus('Erreur de localisation', 'error');
  showGeolocationError(message);
  if (geolocationManager.centerButton) geolocationManager.centerButton.disabled = true;
}

function updateGeolocationMarker(lat, lng, accuracy) {
  // Réutilisation si existant
  if (geolocationManager.accuracyCircle) {
    geolocationManager.accuracyCircle.setLatLng([lat,lng]).setRadius(Math.min(accuracy || 0, 1000));
  } else if (accuracy && accuracy < 1000) {
    geolocationManager.accuracyCircle = L.circle([lat, lng], {
      radius: accuracy, className: 'user-location-accuracy', interactive: false
    }).addTo(map);
  }

  const icon = L.divIcon({
    className: 'user-location-marker',
    html: '<div class="user-location-marker-inner"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });

  if (geolocationManager.marker) {
    geolocationManager.marker.setLatLng([lat,lng]).setIcon(icon);
  } else {
    geolocationManager.marker = L.marker([lat, lng], { icon, zIndexOffset: 1000, title: 'Ma position' }).addTo(map);
  }

  const popupContent = '<div style="text-align:center;"><strong>📍 Ma position</strong><br><small>Précision: ±' + Math.round(accuracy) + 'm</small><br><small>' + new Date().toLocaleTimeString('fr-FR') + '</small></div>';
  geolocationManager.marker.bindPopup(popupContent);
}

function removeGeolocationMarker() {
  if (geolocationManager.marker) { try { map.removeLayer(geolocationManager.marker); } catch(e){} geolocationManager.marker = null; }
  if (geolocationManager.accuracyCircle) { try { map.removeLayer(geolocationManager.accuracyCircle); } catch(e){} geolocationManager.accuracyCircle = null; }
}

function startGeolocationRefresh() {
  stopGeolocationRefresh();
  geolocationManager.refreshTimer = setInterval(() => {
    if (geolocationManager.enabled) getCurrentPosition();
  }, geolocationManager.refreshInterval);
}

function stopGeolocationRefresh() {
  if (geolocationManager.refreshTimer) { clearInterval(geolocationManager.refreshTimer); geolocationManager.refreshTimer = null; }
}

function centerOnUserPosition() {
  if (!geolocationManager.currentPosition) return;
  const { lat, lng, accuracy } = geolocationManager.currentPosition;
  let zoom = 16;
  if (accuracy > 500) zoom = 13; else if (accuracy > 100) zoom = 15;
  map.setView([lat, lng], zoom);
  if (geolocationManager.marker) geolocationManager.marker.openPopup();
}

function updateGeolocationStatus(text, state) {
  if (!geolocationManager.statusElement) return;
  const statusText = geolocationManager.statusElement.querySelector('.status-text');
  if (statusText) statusText.textContent = text;
  geolocationManager.statusElement.className = 'geolocation-status ' + state;
}

function showGeolocationError(message) {
  if (!geolocationManager.errorContainer) return;
  geolocationManager.errorContainer.textContent = '⚠️ ' + message;
  geolocationManager.errorContainer.style.display = 'block';
}

function hideGeolocationError() {
  if (!geolocationManager.errorContainer) return;
  geolocationManager.errorContainer.style.display = 'none';
  geolocationManager.errorContainer.textContent = '';
}

function attachGeolocationHandlers() {
  if (geolocationManager.toggleCheckbox) {
    geolocationManager.toggleCheckbox.addEventListener('change', (e) => {
      if (e.target.checked) enableGeolocation();
      else disableGeolocation();
    });
  }
  if (geolocationManager.centerButton) geolocationManager.centerButton.addEventListener('click', centerOnUserPosition);
}

function saveGeolocationPreference(enabled) {
  try { localStorage.setItem('gpx_geolocation_enabled', JSON.stringify(enabled)); } catch(e){}
}
function loadGeolocationPreference() {
  try { const saved = localStorage.getItem('gpx_geolocation_enabled'); return saved ? JSON.parse(saved) : false; } catch(e){ return false; }
}

// ---- Bootstrapping (après que la carte soit prête) ----
(function bootGeolocWhenReady(){
  function ready() {
    // S'assure que map & L existent
    if (typeof L === 'undefined' || typeof map === 'undefined' || !map) {
      // réessaie au prochain tick
      return void requestAnimationFrame(ready);
    }
    initGeolocation();
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ready);
  } else {
    ready();
  }
})();

// Nettoyage
window.addEventListener('beforeunload', () => { stopGeolocationRefresh(); });

// Économie de batterie
document.addEventListener('visibilitychange', () => {
  if (document.hidden) stopGeolocationRefresh();
  else if (geolocationManager.enabled) { getCurrentPosition(); startGeolocationRefresh(); }
});


// === SAUVEGARDE LOCALE DE LA TRACE GPX ===

const GPX_STORAGE_KEY = 'gpx_saved_trace';
const GPX_WAYPOINTS_KEY = 'gpx_saved_waypoints';
const clearTraceButton = document.getElementById('clear-trace-button');

/**
 * Sauvegarde la trace GPX et les waypoints dans localStorage
 */

function saveTraceToLocalStorage() {
  console.log('saveTraceToLocalStorage appelée');
  console.log('currentGpxDocument:', window.currentGpxDocument);
  console.log('currentGpxFileName:', window.currentGpxFileName);
  
  if (!window.currentGpxDocument || !window.currentGpxFileName) {
    console.warn('Pas de trace à sauvegarder');
    return;
  }

  try {
    // Sérialiser le document XML
    const serializer = new XMLSerializer();
    let gpxString = serializer.serializeToString(window.currentGpxDocument);
    if (!gpxString.startsWith('<?xml')) {
      gpxString = `<?xml version="1.0" encoding="UTF-8"?>
${gpxString}`;
    }

        // Collecter les waypoints affichés sur la carte (tous, GPX + personnalisés)
    const waypoints = [];
    const seen = new Set(); // anti-doublons lat/lng+nom
    const markers = (typeof getWaypointMarkers === 'function') ? getWaypointMarkers() : [];
    (markers || []).forEach((marker) => {
      const latlng = marker.getLatLng && marker.getLatLng();
      if (!latlng) return;
      const key = latlng.lat.toFixed(6) + ',' + latlng.lng.toFixed(6);
      const nameKey = (marker.waypointName || '').trim();
      const dedupKey = key + '|' + nameKey;
      if (seen.has(dedupKey)) return;
      seen.add(dedupKey);
      waypoints.push({ lat: latlng.lat, lng: latlng.lng, name: marker.waypointName || '' });
    });

    // Préparer les données à sauvegarder
    const traceData = {
      fileName: window.currentGpxFileName,
      traceName: window.currentTraceName || '',
      traceNameSource: window.traceNameSource || 'default',
      gpxContent: gpxString,
      waypoints: waypoints,
      timestamp: Date.now()
    };

    // Sauvegarder dans localStorage
    localStorage.setItem(GPX_STORAGE_KEY, JSON.stringify(traceData));
    console.log('📝 localStorage updated (waypoints:', waypoints.length, ')');
    
    console.log('✅ Trace sauvegardée avec succès:', window.currentGpxFileName);
    console.log('Waypoints sauvegardés:', waypoints.length);
    
    // Afficher le bouton "Effacer"
    if (clearTraceButton) {
      clearTraceButton.style.display = 'inline-flex';
    }

  } catch (error) {
    console.error('❌ Erreur sauvegarde:', error);
    
    // Si erreur de quota, informer l'utilisateur
    if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
      if (typeof showMessage === 'function') {
        showMessage('Trace trop volumineuse pour être sauvegardée localement.', true);
      }
    }
  }
}


/**
 * Charge la trace sauvegardée depuis localStorage
 */

function loadTraceFromLocalStorage() {
  try {
    const savedData = localStorage.getItem(GPX_STORAGE_KEY);
    if (!savedData) return false;

    const traceData = JSON.parse(savedData);
    if (!traceData || !traceData.gpxContent || !traceData.fileName) return false;

    if (typeof showMessage === 'function') {
      showMessage('Chargement de la trace sauvegardée...', false);
    }

    // Parse GPX
    const parser = new DOMParser();
    const xml = parser.parseFromString(traceData.gpxContent, 'application/xml');
    const parseError = xml.querySelector('parsererror');
    if (parseError) throw new Error('Fichier GPX sauvegardé invalide.');

    // Restore basic state
    window.currentGpxDocument = currentGpxDocument = xml;
    window.currentGpxFileName = currentGpxFileName = traceData.fileName;
    window.currentTraceName = currentTraceName = traceData.traceName || '';
    window.traceNameSource = traceNameSource = traceData.traceNameSource || 'default';

    if (typeof currentFilename !== 'undefined' && currentFilename) {
      currentFilename.textContent = traceData.fileName;
    }
    if (typeof traceFileNameLabel !== 'undefined' && traceFileNameLabel) {
      traceFileNameLabel.textContent = traceData.fileName;
    }
    if (typeof gpxNameInput !== 'undefined' && gpxNameInput) {
      gpxNameInput.value = window.currentTraceName;
    }
    if (typeof displayTraceName === 'function') {
      displayTraceName(window.currentTraceName, window.traceNameSource);
    }

    // Convert GPX to GeoJSON
    const geojson = (typeof convertGpxToGeoJSON === 'function') ? convertGpxToGeoJSON(xml) : null;
    const hasStoredWaypoints = Array.isArray(traceData.waypoints) && traceData.waypoints.length > 0;
    if (hasStoredWaypoints && geojson && Array.isArray(geojson.features)) {
      geojson.features = geojson.features.filter(f => {
        const t = f && f.geometry && f.geometry.type;
        return t !== 'Point' && t !== 'MultiPoint';
      });
    }
    if (!geojson || !geojson.features || geojson.features.length === 0) {
      throw new Error('La trace sauvegardée est vide.');
    }

    if (typeof setExportAvailability === 'function') setExportAvailability(true);
    if (typeof displayGeoJSON === 'function') displayGeoJSON(geojson);
    if (typeof attachWaypointPersistence === 'function') attachWaypointPersistence();

    // Restore saved waypoints (dedup against any existing markers)
    if (hasStoredWaypoints) {
      if (typeof waypointCounter !== 'undefined') window.waypointCounter = 1;
      const existing = (typeof getWaypointMarkers === 'function') ? (getWaypointMarkers() || []) : [];
      traceData.waypoints.forEach((wp) => {
        if (!wp || !wp.lat || !wp.lng || typeof createWaypointMarker !== 'function') return;
        const lat = parseFloat(wp.lat), lng = parseFloat(wp.lng);
        const nameKey = (wp.name || '').trim();
        let duplicate = false;
        existing.forEach(m => {
          const ll = m && m.getLatLng && m.getLatLng();
          if (!ll) return;
          const mkName = (m.waypointName || '').trim();
          if (Math.abs(ll.lat - lat) < 1e-5 && Math.abs(ll.lng - lng) < 1e-5) {
            if (mkName === nameKey || !nameKey || !mkName) duplicate = true;
          }
        });
        if (!duplicate) createWaypointMarker(L.latLng(lat, lng), wp.name);
      });
    }

    // Elevation data
    if (typeof extractElevationData === 'function') {
      window.currentElevationData = currentElevationData = extractElevationData(geojson, xml);
      if (window.currentElevationData) {
        if (typeof updateElevationStats === 'function') updateElevationStats(window.currentElevationData.stats);
        if (typeof elevationProfile !== 'undefined' && elevationProfile) {
          elevationProfile.classList.add('visible');
          elevationProfile.setAttribute('aria-hidden', 'false');
          elevationProfile.classList.remove('collapsed');
          sizeCanvasToParent();
          if (typeof renderElevationProfile === 'function') renderElevationProfile();
        }
        if (typeof setElevationCollapsed === 'function') setElevationCollapsed(false);
        if (typeof renderElevationProfile === 'function') {
          requestAnimationFrame(() => {
            renderElevationProfile();
            setTimeout(() => { renderElevationProfile(); }, 200);
          });
          if (typeof ensureElevationRendered === 'function') ensureElevationRendered(12);
        }
      } else {
        if (typeof updateElevationStats === 'function') updateElevationStats(null);
        if (typeof calculateDistanceOnly === 'function') {
          const distanceOnly = calculateDistanceOnly(geojson);
          if (distanceOnly && typeof traceDistanceLabel !== 'undefined' && traceDistanceLabel) {
            traceDistanceLabel.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
          }
        }
      }
    }

    // UX message
    const elapsed = Date.now() - (traceData.timestamp || Date.now());
    const minutes = Math.max(0, Math.floor(elapsed / 60000));
    const timeAgo = minutes < 1 ? "à l'instant" : minutes < 60 ? `il y a ${minutes} min` : `il y a ${Math.floor(minutes / 60)}h`;
    if (typeof showMessage === 'function' && typeof escapeHtml === 'function') {
      showMessage(`Trace "<strong>${escapeHtml(window.currentTraceName || traceData.fileName)}</strong>" rechargée (sauvegardée ${timeAgo}).`, false, true);
    } else {
      console.log(`Trace "${window.currentTraceName || traceData.fileName}" rechargée (sauvegardée ${timeAgo}).`);
    }

    // Show clear button
    if (typeof clearTraceButton !== 'undefined' && clearTraceButton) {
      clearTraceButton.style.display = 'inline-flex';
    }

    return true;
  } catch (error) {
    console.error('Erreur lors du chargement de la trace sauvegardée :', error);
    try { localStorage.removeItem(GPX_STORAGE_KEY); } catch(_) {}
    return false;
  }
}

function clearSavedTrace() {
  try {
    currentGpxDocument = null;
    currentGpxFileName = '';
    currentTraceName = '';
    traceNameSource = 'default';
    currentGeojson = null;
  } catch (_){}

  try {
    if (typeof setExportAvailability === 'function') setExportAvailability(false);
    if (typeof updateWaypointsList === 'function') updateWaypointsList();
    if (typeof updateTraceInfo === 'function') updateTraceInfo(null);
    if (typeof displayTraceName === 'function') displayTraceName('—', 'default');
    if (typeof gpxNameInput !== 'undefined' && gpxNameInput) gpxNameInput.value = '';
    if (typeof currentFilename !== 'undefined' && currentFilename) currentFilename.textContent = '—';
    if (typeof traceFileNameLabel !== 'undefined' && traceFileNameLabel) traceFileNameLabel.textContent = '—';
    if (typeof resetElevationDisplay === 'function') resetElevationDisplay();
  } catch (_){}

  if (typeof showMessage === 'function') showMessage('Trace sauvegardée effacée et carte nettoyée.', false);

  try {
    localStorage.removeItem(GPX_STORAGE_KEY);
    localStorage.removeItem(GPX_WAYPOINTS_KEY);
  } catch (error) {
    console.error('Erreur lors de la suppression du stockage local :', error);
  }

  try {
    if (typeof clearPreviousLayers === 'function') clearPreviousLayers();
    if (typeof waypointLayerGroup !== 'undefined' && waypointLayerGroup && typeof waypointLayerGroup.clearLayers === 'function') waypointLayerGroup.clearLayers();
    if (typeof gpxLayerGroup !== 'undefined' && gpxLayerGroup && typeof gpxLayerGroup.clearLayers === 'function') gpxLayerGroup.clearLayers();
    if (typeof arrowLayerGroup !== 'undefined' && arrowLayerGroup && typeof arrowLayerGroup.clearLayers === 'function') arrowLayerGroup.clearLayers();
  } catch (error) {
    console.warn('Nettoyage des calques :', error);
  }

  try {
    window.currentGpxDocument = null;
    window.currentGpxFileName = '';
    window.currentTraceName = '';
    window.traceNameSource = 'default';
    if (typeof currentGpxDocument !== 'undefined') currentGpxDocument = null;
    if (typeof currentGpxFileName !== 'undefined') currentGpxFileName = '';
    if (typeof currentTraceName !== 'undefined') currentTraceName = '';
    if (typeof traceNameSource !== 'undefined') traceNameSource = 'default';
    if (typeof currentGeojson !== 'undefined') currentGeojson = null;
  } catch (error) {
    console.warn('Réinit variables :', error);
  }
}


// Événement du bouton "Effacer la trace" - Attachement différé
function attachClearTraceButton() {
  const btn = document.getElementById('clear-trace-button');
  if (btn && !btn.__listenerAttached) {
    btn.__listenerAttached = true;
    btn.addEventListener('click', () => {
      if (confirm('Voulez-vous vraiment effacer la trace sauvegardée localement ?')) {
        clearSavedTrace();
      }
    });
  }
}

// Charger automatiquement au démarrage
window.addEventListener('DOMContentLoaded', () => {
  // Attacher le bouton d'effacement
  attachClearTraceButton();
  
  // Attendre que la carte soit initialisée
  setTimeout(() => {
    loadTraceFromLocalStorage();
  }, 500);
});
// === Robust elevation render helper (enhanced) ===
function ensureElevationRendered(retries = 8) {
  try {
    const hasData = typeof currentElevationData !== 'undefined' && currentElevationData;
    const hasPoints = hasData && Array.isArray(currentElevationData.points) && currentElevationData.points.length > 1;
    const hasStats = hasData && currentElevationData.stats;
    const hasCanvas = typeof elevationCanvas !== 'undefined' && elevationCanvas;
    const hasProfile = typeof elevationProfile !== 'undefined' && elevationProfile;

    if (!(hasPoints && hasStats && hasCanvas && hasProfile)) {
      // Attempt self-heal: recompute elevation if geojson exists
      if ((!hasData || !hasPoints || !hasStats) && typeof extractElevationData === 'function' && typeof currentGeojson !== 'undefined' && currentGeojson) {
        try {
          const xml = window.currentGpxDocument || null;
          const recomputed = extractElevationData(currentGeojson, xml);
          if (recomputed) {
            window.currentElevationData = recomputed;
            if (typeof updateElevationStats === 'function') updateElevationStats(recomputed.stats);
          }
        } catch (e) {
          console.warn('Recompute elevation failed:', e);
        }
      }

      if (retries > 0) {
        setTimeout(() => ensureElevationRendered(retries - 1), 200);
      } else {
        console.warn('Elevation not ready after retries.', {
          hasData: !!hasData, hasPoints: !!hasPoints, hasStats: !!hasStats,
          hasCanvas: !!hasCanvas, hasProfile: !!hasProfile,
          pointsLen: hasData && currentElevationData.points ? currentElevationData.points.length : 0,
          canvasW: hasCanvas ? elevationCanvas.offsetWidth : null,
          canvasH: hasCanvas ? elevationCanvas.offsetHeight : null
        });
      }
      return;
    }

    // Ensure panel visible and not collapsed
    elevationProfile.classList.add('visible');
    elevationProfile.classList.remove('collapsed');
    elevationProfile.setAttribute('aria-hidden', 'false');

    // Ensure canvas has a non-zero size
    if (elevationCanvas && (elevationCanvas.offsetHeight === 0 || elevationCanvas.offsetWidth === 0)) {
      elevationCanvas.style.height = '240px';
      elevationCanvas.style.width = '100%';
    }

    // Render now
    if (typeof renderElevationProfile === 'function') {
      if (typeof fitElevationToViewport === 'function') fitElevationToViewport();
      renderElevationProfile();
      setTimeout(() => { if (typeof fitElevationToViewport === 'function') fitElevationToViewport(); renderElevationProfile(); }, 200);
    }
  } catch (e) {
    console.warn('ensureElevationRendered error:', e);
  }
}

// Re-render on resize as a safety net
window.addEventListener('resize', () => {
  if (typeof renderElevationProfile === 'function') {
    renderElevationProfile();
  }
});


// --- Responsive elevation canvas sizing ---
function resizeElevationCanvas() {
  if (!elevationCanvas || !elevationProfile) return;
  // Reserve a fraction of the viewport height while accounting for the panel header
  const viewportH = window.innerHeight || 800;
  const header = elevationProfile.querySelector('.elevation-header');
  const headerH = header ? header.offsetHeight : 48;
  // Target 28% of viewport, min 160px, max 420px
  const target = Math.max(160, Math.min(420, Math.floor(viewportH * 0.28)));
  // Apply height only if different to avoid layout thrash
  const targetPx = target + 'px';
  if (elevationCanvas.style.height !== targetPx) {
    elevationCanvas.style.height = targetPx;
  }
  elevationCanvas.style.width = '100%';
}

window.addEventListener('resize', () => {
  resizeElevationCanvas();
  if (typeof renderElevationProfile === 'function') {
    renderElevationProfile();
  }
});



// --- Viewport-aware elevation fit (strong) ---
function fitElevationToViewport() {
  try {
    if (typeof elevationProfile === 'undefined' || typeof elevationCanvas === 'undefined') return;
    if (!elevationProfile || !elevationCanvas) return;

    const rect = elevationProfile.getBoundingClientRect();
    const viewportH = window.innerHeight || document.documentElement.clientHeight || 800;

    // Account for bottom UI (dock, browser UI). Tune this if needed.
    const safeBottom = 40;
    let available = Math.floor(viewportH - rect.top - safeBottom);
    const minH = 180, maxH = 360; // tighter to avoid overflow

    if (!Number.isFinite(available) || available <= 0) available = 240;
    const target = Math.max(minH, Math.min(maxH, available));

    // Apply CSS size
    const targetPx = target + 'px';
    if (elevationCanvas.style.height !== targetPx) {
      elevationCanvas.style.height = targetPx;
    }
    elevationCanvas.style.width = '100%';

    // Sync intrinsic canvas size with DPR to avoid blurriness/clipping mismatch
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const cssW = elevationCanvas.clientWidth || elevationCanvas.offsetWidth || 800;
    const cssH = target;
    const wantW = Math.floor(cssW * dpr);
    const wantH = Math.floor(cssH * dpr);
    if (elevationCanvas.width !== wantW) elevationCanvas.width = wantW;
    if (elevationCanvas.height !== wantH) elevationCanvas.height = wantH;
  } catch (e) {
    console.warn('fitElevationToViewport error:', e);
  }
}

// (removed dynamic observers to prevent loops)
// === Elevation render scheduler (prevents tight loops) ===
let __elevRenderScheduled = false;
function scheduleElevationRender(reason) {
  try {
    if (__elevRenderScheduled) return;
    __elevRenderScheduled = true;
    requestAnimationFrame(() => {
      __elevRenderScheduled = false;
      if (typeof fitElevationToViewport === 'function') fitElevationToViewport();
      if (typeof renderElevationProfile === 'function') renderElevationProfile();
    });
  } catch (e) {
    console.warn('scheduleElevationRender error:', e);
    // Fallback direct render
    if (typeof renderElevationProfile === 'function') renderElevationProfile();
  }
}


// --- Minimal elevation canvas sizing (fixed height) ---
const ELEV_CANVAS_FIXED_H = 260; // px; change if you want bigger/smaller
function setElevationCanvasSize() {
  if (!window.elevationCanvas || !window.elevationProfile) return;
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const cssW = elevationProfile.clientWidth || elevationCanvas.parentElement?.clientWidth || elevationCanvas.clientWidth || 800;
  const cssH = ELEV_CANVAS_FIXED_H;
  elevationCanvas.style.width = '100%';
  elevationCanvas.style.height = cssH + 'px';
  const wantW = Math.max(1, Math.floor(cssW * dpr));
  const wantH = Math.max(1, Math.floor(cssH * dpr));
  if (elevationCanvas.width !== wantW) elevationCanvas.width = wantW;
  if (elevationCanvas.height !== wantH) elevationCanvas.height = wantH;
}


// --- Keep elevation container sized to canvas ---
function syncElevationContainer() {
  try {
    if (typeof elevationCanvas === 'undefined' || typeof elevationProfile === 'undefined') return;
    const content = document.getElementById('elevation-content');
    if (!content || !elevationCanvas) return;
    // Read actual canvas CSS height (not intrinsic pixels)
    const h = elevationCanvas.getBoundingClientRect().height;
    if (h && Math.abs((content.getBoundingClientRect().height || 0) - h) > 1) {
      content.style.height = h + 'px';
    }
  } catch (e) {
    console.warn('syncElevationContainer error:', e);
  }
}


// --- Canvas == parent size (with DPR) ---
function sizeCanvasToParent() {
  const parent = document.getElementById('elevation-content');
  const canvas = typeof elevationCanvas !== 'undefined' ? elevationCanvas : document.getElementById('elevation-canvas');
  if (!parent || !canvas) return;
  const rect = parent.getBoundingClientRect();
  // If parent is hidden/collapsed, skip (will be re-called later)
  if (!rect.width || !rect.height) return;

  // CSS size already set via width/height:100%; sync intrinsic pixels for crisp rendering
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const wantW = Math.max(1, Math.floor(rect.width * dpr));
  const wantH = Math.max(1, Math.floor(rect.height * dpr));
  if (canvas.width !== wantW) canvas.width = wantW;
  if (canvas.height !== wantH) canvas.height = wantH;
}

// Observe parent size changes
(function observeParentForCanvas(){
  try {
    const parent = document.getElementById('elevation-content');
    if (!parent) return;
    const ro = new ResizeObserver(() => sizeCanvasToParent());
    ro.observe(parent);
    // First sizing attempt
    sizeCanvasToParent();
  } catch (e) {
    console.warn('ResizeObserver not available or failed:', e);
    // Fallback: size once on load
    setTimeout(sizeCanvasToParent, 100);
  }
})();


// === PERSISTENCE WAYPOINTS — debounce & group hooks ===
if (typeof window.__saveWpTimer === 'undefined') window.__saveWpTimer = null;
function saveTraceDebounced(delay = 120) {
  if (typeof saveTraceToLocalStorage !== 'function') return;
  clearTimeout(window.__saveWpTimer);
  window.__saveWpTimer = setTimeout(() => {
    try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); }
  }, delay);
}

function attachWaypointPersistence() {
  try {
    if (typeof waypointLayerGroup === 'undefined' || !waypointLayerGroup || typeof waypointLayerGroup.on !== 'function') return;
    waypointLayerGroup.off('layeradd', saveTraceDebounced);
    waypointLayerGroup.off('layerremove', saveTraceDebounced);
    waypointLayerGroup.on('layeradd', () => saveTraceDebounced());
    waypointLayerGroup.on('layerremove', () => saveTraceDebounced());
    // initial sync
    saveTraceDebounced(10);
  } catch (e) { console.warn('attachWaypointPersistence:', e); }
}

</script>

</body>
</html>