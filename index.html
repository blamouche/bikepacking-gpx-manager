<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lecteur GPX - Carte OpenStreetMap</title>
  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    :root {
      --color-primary: #1976d2;
      --color-primary-hover: #1565c0;
      --color-secondary: #f5f5f5;
      --color-secondary-hover: #eeeeee;
      --color-danger: #f44336;
      --color-background: #ffffff;
      --color-background-alt: #f8f9fa;
      --color-text-primary: #212121;
      --color-text-secondary: #424242;
      --color-text-muted: #757575;
      --color-border: #e0e0e0;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--color-background-alt);
      color: var(--color-text-primary);
    }

    body {
      overflow: hidden;
    }

    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .hidden {
      display: none !important;
    }

    .tools-panel {
      width: 320px;
      min-width: 320px;
      height: 100vh;
      background: var(--color-background);
      border-right: 1px solid var(--color-border);
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .panel-header {
      padding: 1.5rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .panel-title {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem 1.5rem;
    }

    .panel-section {
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid var(--color-border);
    }

    .panel-section:last-child {
      border-bottom: none;
      padding-bottom: 0;
      margin-bottom: 0;
    }

    /* Calques POI */
    .layer-section {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .layer-global-actions {
      display: flex;
      gap: 0.5rem;
    }

    .layer-global-actions .btn {
      flex: 1;
    }

    .layer-presets {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .layer-presets label {
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .preset-select {
      flex: 1;
      padding: 0.45rem 0.6rem;
      border-radius: 6px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
      background: #fff;
    }

    .layer-group {
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: #fff;
      overflow: hidden;
      margin-bottom: 0.5rem;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
    }

    .layer-group-header {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem;
      background: var(--color-background-alt);
      border: none;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }

    .layer-group-header:hover {
      background: rgba(0, 0, 0, 0.03);
    }

    .layer-group-icon {
      font-size: 1.1rem;
    }

    .layer-group-label {
      flex: 1;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--color-text-primary);
      text-align: left;
    }

    .layer-group-count {
      font-size: 0.85rem;
      color: var(--color-text-muted);
    }

    .layer-group-chevron {
      font-size: 0.8rem;
      color: var(--color-text-muted);
      transition: transform 0.3s ease;
    }

    .layer-group.expanded .layer-group-chevron {
      transform: rotate(180deg);
    }

    .layer-group-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
      padding: 0 0.75rem;
    }

    .layer-group.expanded .layer-group-content {
      max-height: 1000px;
      padding: 0.75rem;
    }

    .layer-toggle {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
      user-select: none;
      padding: 0.4rem 0.25rem;
    }

    .layer-toggle + .layer-toggle {
      border-top: 1px dashed rgba(0, 0, 0, 0.05);
    }

    .toggle-input {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      background: #ccc;
      border-radius: 12px;
      transition: background 0.3s ease;
      flex-shrink: 0;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      top: 3px;
      left: 3px;
      transition: transform 0.3s ease;
    }

    .toggle-input:checked + .toggle-switch {
      background: var(--color-primary);
    }

    .toggle-input:checked + .toggle-switch::after {
      transform: translateX(20px);
    }

    .toggle-input:focus + .toggle-switch {
      outline: 2px solid var(--color-primary);
      outline-offset: 2px;
    }

    .toggle-text {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--color-text-primary);
      flex: 1;
    }

    .toggle-icon {
      font-size: 1.1rem;
    }

    .toggle-count {
      font-size: 0.85rem;
      color: var(--color-text-muted);
      font-weight: 600;
    }

    .layer-indicators {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .layer-loading,
    .layer-error,
    .layer-info,
    .layer-total {
      padding: 0.6rem 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      display: none;
    }

    .layer-loading {
      background: #e3f2fd;
      color: #1976d2;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .layer-error {
      background: #ffebee;
      color: #c62828;
      border: 1px solid rgba(198, 40, 40, 0.2);
    }

    .layer-info {
      background: #fff8e1;
      color: #f57f17;
      border: 1px solid rgba(245, 127, 23, 0.2);
    }

    .layer-total {
      background: var(--color-background-alt);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
    }

    .layer-count-value {
      color: var(--color-primary);
      font-weight: 700;
      font-size: 1rem;
    }

    .layer-loading .loading-spinner {
      display: inline-block;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .section-title {
      margin: 0 0 1rem 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 1.75rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: var(--color-primary);
      color: #fff;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      width: 100%;
      border: none;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      transition: box-shadow 0.2s ease, transform 0.1s ease;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    .btn-primary {
      background: var(--color-primary);
      color: #ffffff;
    }

    .btn-primary:not(:disabled):hover,
    .btn-primary:not(:disabled):focus {
      background: var(--color-primary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-secondary {
      background: var(--color-secondary);
      color: var(--color-text-secondary);
    }

    .btn-secondary:hover,
    .btn-secondary:focus {
      background: var(--color-secondary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-small {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
    }

    .btn-icon-small {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 1rem;
      padding: 0.25rem;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .btn-icon-small:hover,
    .btn-icon-small:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .import-actions {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .file-info {
      margin-top: 1rem;
      padding: 0.75rem;
      border-radius: 6px;
      background: var(--color-background-alt);
      border: 1px solid var(--color-border);
    }

    .file-info small {
      display: block;
      color: var(--color-text-muted);
      margin-bottom: 0.25rem;
    }

    .filename {
      margin: 0;
      font-weight: 600;
      color: var(--color-text-primary);
      word-break: break-all;
    }

    .file-name-input {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
      margin-top: 0.75rem;
    }

    .drop-zone {
      margin-top: 1rem;
      padding: 1rem;
      border: 2px dashed var(--color-border);
      border-radius: 8px;
      text-align: center;
      color: var(--color-text-muted);
      background: #fff;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .drop-zone.dragover {
      border-color: var(--color-primary);
      background: rgba(25, 118, 210, 0.08);
      color: var(--color-text-primary);
    }

    .waypoints-list {
      max-height: 240px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .waypoint-item {
      display: grid;
      grid-template-columns: auto 1fr auto auto;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.6rem;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: #fff;
      box-shadow: var(--shadow-sm);
    }

    .waypoint-popup {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 200px;
    }

    .waypoint-popup label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .waypoint-popup input {
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
    }

    .waypoint-popup-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .waypoint-popup-buttons button {
      flex: 1;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: var(--color-secondary);
    }

    .waypoint-popup-buttons button[data-action="save"] {
      background: var(--color-primary);
      color: #fff;
    }

    .waypoint-popup-buttons button[data-action="delete"] {
      background: var(--color-danger);
      color: #fff;
    }

    .waypoint-name {
      font-size: 0.95rem;
      color: var(--color-text-primary);
    }

    .waypoint-icon {
      font-size: 1.1rem;
    }

    .info-list {
      margin: 0;
      display: grid;
      grid-template-columns: auto 1fr;
      row-gap: 0.75rem;
      column-gap: 1rem;
      font-size: 0.95rem;
    }

    .info-list dt {
      font-weight: 600;
      color: var(--color-text-secondary);
    }

    .info-list dd {
      margin: 0;
      color: var(--color-text-primary);
    }

    .text-muted {
      color: var(--color-text-muted);
    }

    .trace-name {
      font-weight: 600;
      font-size: 1rem;
      word-break: break-word;
    }

    .trace-name--gpx-track,
    .trace-name--gpx-route,
    .trace-name--gpx-metadata {
      color: var(--color-primary);
    }

    .trace-name--filename {
      color: var(--color-text-muted);
      font-style: italic;
    }

    .trace-name--default {
      color: #9e9e9e;
      font-style: italic;
    }

    .file-name {
      font-family: "Courier New", Courier, monospace;
      font-size: 0.9rem;
      color: var(--color-text-muted);
      word-break: break-all;
    }

    .trace-name-help {
      font-size: 1rem;
      cursor: help;
      color: var(--color-text-muted);
      display: inline-block;
      margin-left: 0.35rem;
    }

    .stat-highlight {
      font-weight: 600;
      color: var(--color-primary);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .elevation-profile {
      position: relative;
      width: 100%;
      background: var(--color-background);
      border-top: 2px solid var(--color-primary);
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
      display: none;
      flex-direction: column;
      z-index: 500;
      transition: height 0.3s ease;
      height: 200px;
    }

    .elevation-profile.visible {
      display: flex;
    }

    .elevation-profile.collapsed {
      height: 40px;
    }

    .elevation-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.75rem 1rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      cursor: pointer;
      user-select: none;
      min-height: 40px;
    }

    .elevation-header:hover {
      background: rgba(0, 0, 0, 0.02);
    }

    .elevation-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .elevation-title h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .elevation-icon {
      font-size: 1.25rem;
    }

    .elevation-stats-quick {
      display: flex;
      gap: 1.5rem;
      flex: 1;
      justify-content: center;
    }

    .stat-item {
      display: flex;
      gap: 0.25rem;
      font-size: 0.9rem;
    }

    .stat-label {
      color: var(--color-text-muted);
    }

    .stat-value {
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .btn-collapse {
      border: none;
      background: transparent;
      font-size: 1rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .btn-collapse:hover,
    .btn-collapse:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .elevation-profile.collapsed .btn-collapse span {
      transform: rotate(180deg);
      display: inline-block;
    }

    .elevation-content {
      flex: 1;
      position: relative;
      overflow: hidden;
      padding: 1rem;
      display: none;
    }

    .elevation-profile:not(.collapsed) .elevation-content {
      display: block;
    }

    #elevation-canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .elevation-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .tooltip-row {
      display: flex;
      gap: 0.5rem;
      white-space: nowrap;
    }

    /* Marqueurs POI OSM */
    .poi-marker {
      border: none !important;
      background: transparent !important;
    }

    .poi-marker-inner {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      border: 2px solid #fff;
      transition: transform 0.2s ease;
    }

    .poi-marker:hover .poi-marker-inner {
      transform: scale(1.15);
    }

    .poi-marker-icon {
      font-size: 14px;
      line-height: 1;
      filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
    }

    .poi-popup-container .leaflet-popup-content-wrapper {
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .poi-popup {
      font-family: inherit;
      min-width: 220px;
    }

    .poi-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--color-border);
      margin-bottom: 0.75rem;
    }

    .poi-header .poi-icon {
      font-size: 1.5rem;
    }

    .poi-name {
      font-size: 1rem;
      color: var(--color-text-primary);
    }

    .poi-details {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .poi-row {
      display: flex;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .poi-label {
      color: var(--color-text-muted);
      min-width: 70px;
    }

    .poi-value {
      color: var(--color-text-primary);
      font-weight: 500;
    }

    .poi-footer {
      padding-top: 0.5rem;
      border-top: 1px solid var(--color-border);
    }

    .poi-footer a {
      color: var(--color-primary);
      text-decoration: none;
      font-size: 0.85rem;
    }

    .poi-footer a:hover {
      text-decoration: underline;
    }

    .tooltip-label {
      color: rgba(255, 255, 255, 0.7);
    }

    .tooltip-value {
      font-weight: 600;
    }

    @media (max-width: 767px) {
      .layer-global-actions {
        flex-direction: column;
      }

      .layer-presets {
        flex-direction: column;
        align-items: stretch;
        gap: 0.35rem;
      }

      .layer-presets label {
        font-size: 0.85rem;
      }

      .elevation-profile {
        height: 150px;
      }

      .elevation-stats-quick {
        display: none;
      }

      .elevation-header {
        padding: 0.5rem 0.75rem;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .elevation-stats-quick {
        gap: 1rem;
        font-size: 0.85rem;
      }
    }

    .panel-messages {
      padding: 0;
    }

    .message {
      min-height: 3rem;
      padding: 0.75rem 1rem;
      border-radius: 6px;
      border: 1px solid transparent;
      background: #f1f8ff;
      color: #0d47a1;
    }

    .message.hidden {
      display: none;
    }

    .message.error {
      background: #ffebee;
      border-color: rgba(244, 67, 54, 0.3);
      color: #c62828;
    }

    .map-container {
      flex: 1;
      position: relative;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .map-main {
      position: relative;
      flex: 1;
      min-height: 0;
    }

    .poi-refresh-button {
      position: absolute;
      z-index: 900;
      top: 1rem;
      display: none;
      align-items: center;
      gap: 0.4rem;
      padding: 0.6rem 0.85rem;
      background: rgba(25, 118, 210, 0.95);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      box-shadow: var(--shadow-md);
      cursor: pointer;
      transition: background 0.2s ease, transform 0.1s ease;
    
      left: 50%;
      transform: translateX(-50%);}

    .poi-refresh-button:hover,
    .poi-refresh-button:focus {
      background: rgba(21, 101, 192, 0.95);
      transform: translateX(-50%) translateY(-1px);
      outline: none;
    }

    .poi-refresh-button span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .btn-menu {
      display: none;
      position: absolute;
      top: 1rem;
      left: 1rem;
      z-index: 1000;
      background: #fff;
      border: 2px solid var(--color-border);
      border-radius: 6px;
      padding: 0.6rem 0.8rem;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: var(--shadow-md);
    }

    .btn-close-panel {
      border: none;
      background: transparent;
      font-size: 1.25rem;
      cursor: pointer;
      border-radius: 4px;
      padding: 0.2rem 0.4rem;
    }

    .btn-close-panel:hover,
    .btn-close-panel:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .panel-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      z-index: 1500;
      opacity: 0;
      animation: fadeIn 0.2s forwards;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    @media (max-width: 767px) {
      .tools-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 85vw;
        max-width: 320px;
        z-index: 2000;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }

      .tools-panel.open {
        transform: translateX(0);
      }

      .btn-menu {
        display: block;
      }
    }

    @media (min-width: 768px) {
      .btn-close-panel {
        display: none;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .tools-panel {
        width: 280px;
        min-width: 280px;
      }
    }
  </style>

<!-- Modern Compact UI Overrides -->
<style>
:root {
  /* Couleurs primaires - Bleu moderne plus saturé */
  --color-primary: #0066FF;
  --color-primary-hover: #0052CC;
  --color-primary-light: #E6F0FF;
  
  /* Couleurs secondaires - Gris modernes */
  --color-secondary: #F7F8FA;
  --color-secondary-hover: #E8EAED;
  
  /* Couleurs de danger */
  --color-danger: #FF3B30;
  --color-danger-hover: #E62E24;
  
  /* Backgrounds */
  --color-background: #FFFFFF;
  --color-background-alt: #FAFBFC;
  --color-background-elevated: #FFFFFF;
  
  /* Textes */
  --color-text-primary: #1A1A1A;
  --color-text-secondary: #4A4A4A;
  --color-text-muted: #8E8E93;
  
  /* Bordures */
  --color-border: #E5E5EA;
  --color-border-light: #F2F2F7;
  
  /* Ombres modernisées */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
  
  /* Bordures arrondies plus subtiles */
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;
  
  /* Espacements compacts */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 0.75rem;
  --spacing-lg: 1rem;
  --spacing-xl: 1.5rem;
}

/* 2. Typographie modernisée */
html, body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  font-size: 14px;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.panel-title {
  font-size: 1.25rem;
  font-weight: 700;
  letter-spacing: -0.02em;
}

.section-title {
  font-size: 0.95rem;
  font-weight: 600;
  letter-spacing: -0.01em;
  text-transform: uppercase;
  color: var(--color-text-muted);
}

/* 3. Panneau latéral compact */
.panel-header {
  padding: 1rem 1.25rem;
  background: var(--color-background);
  border-bottom: 1px solid var(--color-border-light);
  backdrop-filter: blur(10px);
}

.panel-content {
  padding: 0.75rem 1rem;
}

.panel-section {
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--color-border-light);
}

.tools-panel {
  width: 280px;
  min-width: 280px;
}

@media (min-width: 768px) and (max-width: 1023px) {
  .tools-panel {
    width: 260px;
    min-width: 260px;
  }
}

/* 4. Boutons modernisés */
.btn {
  padding: 0.625rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  border-radius: var(--radius-md);
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  border: none;
  cursor: pointer;
}

.btn:not(:disabled):active {
  transform: scale(0.98);
}

.btn-primary {
  background: var(--color-primary);
  color: #FFFFFF;
  box-shadow: 0 1px 3px rgba(0, 102, 255, 0.2);
}

.btn-primary:not(:disabled):hover {
  background: var(--color-primary-hover);
  box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
  transform: translateY(-1px);
}

.btn-secondary {
  background: var(--color-secondary);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
}

.btn-small {
  padding: 0.375rem 0.75rem;
  font-size: 0.8125rem;
}

/* 5. Cartes et conteneurs modernisés */
.layer-group {
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-md);
  background: var(--color-background-elevated);
  overflow: hidden;
  margin-bottom: 0.5rem;
  box-shadow: var(--shadow-sm);
  transition: all 0.2s ease;
}

.layer-group:hover {
  box-shadow: var(--shadow-md);
}

.layer-group-header {
  padding: 0.625rem 0.75rem;
  background: var(--color-background-alt);
  border: none;
  transition: background 0.15s ease;
}

.layer-group-content {
  padding: 0 0.75rem;
}

.layer-group.expanded .layer-group-content {
  padding: 0.625rem 0.75rem;
}

/* File info modernisé */
.file-info {
  margin-top: 0.75rem;
  padding: 0.75rem;
  border-radius: var(--radius-md);
  background: var(--color-background-alt);
  border: 1px solid var(--color-border-light);
}

/* 6. Toggles et contrôles modernisés */
.toggle-switch {
  width: 40px;
  height: 22px;
  border-radius: 11px;
  background: #E5E5EA;
}

.toggle-switch::after {
  width: 16px;
  height: 16px;
  top: 3px;
  left: 3px;
}

.toggle-input:checked + .toggle-switch::after {
  transform: translateX(18px);
}

.layer-toggle {
  padding: 0.375rem 0.25rem;
  gap: 0.625rem;
}

.toggle-text {
  font-size: 0.875rem;
}

.toggle-icon {
  font-size: 1rem;
}

/* 7. Waypoints et listes compactes */
.waypoints-list {
  max-height: 200px;
  gap: 0.375rem;
}

.waypoint-item {
  padding: 0.5rem;
  gap: 0.5rem;
  border-radius: var(--radius-md);
  background: var(--color-background-elevated);
  border: 1px solid var(--color-border-light);
}

/* 8. Info-list modernisée */
.info-list {
  grid-template-columns: auto 1fr;
  row-gap: 0.625rem;
  column-gap: 0.75rem;
  font-size: 0.875rem;
}

.info-list dt {
  font-weight: 600;
  font-size: 0.8125rem;
  color: var(--color-text-muted);
}

/* 9. Badge modernisé */
.badge {
  min-width: 1.5rem;
  padding: 0.125rem 0.375rem;
  border-radius: 999px;
  background: var(--color-primary);
  color: #FFFFFF;
  font-size: 0.75rem;
  font-weight: 600;
  box-shadow: 0 1px 3px rgba(0, 102, 255, 0.2);
}

/* 10. Profil d'élévation compact */
.elevation-profile {
  height: 180px;
}

.elevation-header {
  padding: 0.625rem 1rem;
  min-height: 36px;
}

.elevation-title h3 {
  font-size: 0.9375rem;
  font-weight: 600;
}

.elevation-stats-quick {
  gap: 1.25rem;
}

.stat-item {
  font-size: 0.8125rem;
}

@media (max-width: 767px) {
  .elevation-profile {
    height: 140px;
  }
}

/* 11. Bouton POI refresh modernisé */
.poi-refresh-button {
  left: 50%;
  top: 1rem;
  transform: translateX(-50%);
  padding: 0.5rem 0.875rem;
  background: rgba(0, 102, 255, 0.95);
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
  backdrop-filter: blur(10px);
}

.poi-refresh-button:hover {
  background: rgba(0, 82, 204, 0.95);
  transform: translateX(-50%) translateY(-2px);
  box-shadow: 0 6px 16px rgba(0, 102, 255, 0.4);
}

/* 12. Indicateurs et messages compacts */
.layer-loading,
.layer-error,
.layer-info,
.layer-total {
  padding: 0.5rem 0.625rem;
  border-radius: var(--radius-md);
  font-size: 0.8125rem;
}

.layer-loading {
  background: var(--color-primary-light);
  color: var(--color-primary);
}

.message {
  min-height: 2.5rem;
  padding: 0.625rem 0.875rem;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
}

/* 13. Drop zone modernisée */
.drop-zone {
  margin-top: 0.75rem;
  padding: 1rem;
  border: 2px dashed var(--color-border);
  border-radius: var(--radius-lg);
  background: var(--color-background-alt);
  transition: all 0.2s ease;
}

.drop-zone.dragover {
  border-color: var(--color-primary);
  background: var(--color-primary-light);
  transform: scale(1.01);
}

/* 14. Popups POI modernisés */
.poi-popup-container .leaflet-popup-content-wrapper {
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  padding: 0;
}

.poi-popup {
  font-size: 0.875rem;
  min-width: 200px;
}

.poi-header {
  padding-bottom: 0.625rem;
  margin-bottom: 0.625rem;
}

.poi-details {
  gap: 0.375rem;
  margin-bottom: 0.625rem;
}

.poi-row {
  font-size: 0.8125rem;
}

/* 15. Animations fluides */
* {
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

.layer-group,
.waypoint-item,
.poi-marker {
  animation: fadeIn 0.2s ease-out;
}

/* 16. Scrollbars modernisées */
.panel-content::-webkit-scrollbar,
.waypoints-list::-webkit-scrollbar {
  width: 6px;
}

.panel-content::-webkit-scrollbar-track,
.waypoints-list::-webkit-scrollbar-track {
  background: transparent;
}

.panel-content::-webkit-scrollbar-thumb,
.waypoints-list::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: 3px;
}

.panel-content::-webkit-scrollbar-thumb:hover,
.waypoints-list::-webkit-scrollbar-thumb:hover {
  background: var(--color-text-muted);
}
</style>
</head>
<body>
  <div class="app-container">
    <aside class="tools-panel" id="tools-panel" role="complementary" aria-label="Panneau d'outils">
      <header class="panel-header">
        <h1 class="panel-title">Lecteur GPX</h1>
        <button class="btn-close-panel" id="close-panel" aria-label="Fermer le panneau">✕</button>
      </header>
      <div class="panel-content">
        <section class="panel-section">
          <h3 class="section-title">Fichier GPX</h3>
          <div class="import-actions">
            <button class="btn btn-primary" id="import-button">
              <span aria-hidden="true">📁</span>
              Importer GPX
            </button>
            <button class="btn btn-primary" id="export-button" disabled>
              <span aria-hidden="true">💾</span>
              Exporter GPX
            </button>
          </div>
          <div class="file-info" id="file-info" style="display: none;">
            <small class="text-muted">Fichier actuel :</small>
            <p class="filename" id="current-filename">—</p>
            <label for="gpx-name-input" style="display:block; font-size:0.85rem; color:var(--color-text-muted); margin-top:0.75rem;">
              Nom d'export
            </label>
            <input id="gpx-name-input" class="file-name-input" type="text" placeholder="Nom du fichier" autocomplete="off" />
          </div>
          <div class="drop-zone" id="panel-drop-zone">
            <p>Ou glissez-déposez un fichier .gpx ici</p>
          </div>
        </section>

        <section class="panel-section" id="waypoints-section" style="display: none;">
          <h3 class="section-title">
            Waypoints
            <span class="badge" id="waypoint-count">0</span>
          </h3>
          <div class="waypoints-list" id="waypoints-list"></div>
          <button class="btn btn-secondary btn-small" id="clear-waypoints">Effacer tous les waypoints</button>
        </section>

        <section class="panel-section" id="trace-info-section" style="display: none;">
          <h3 class="section-title">Informations</h3>
          <dl class="info-list">
            <dt>Nom de la trace</dt>
            <dd>
              <span id="trace-name" class="trace-name">—</span>
              <span
                class="trace-name-help"
                title="Le nom provient d'abord du fichier GPX, puis du nom de fichier, ou d'un nom par défaut."
                aria-hidden="true"
              >
                ℹ️
              </span>
            </dd>
            <dt>Nom du fichier</dt>
            <dd id="file-name" class="file-name">—</dd>
            <dt>Distance totale</dt>
            <dd id="trace-distance" class="stat-highlight">—</dd>
            <dt>Dénivelé positif (D+)</dt>
            <dd id="trace-elevation-gain" class="stat-highlight">—</dd>
            <dt>Dénivelé négatif (D-)</dt>
            <dd id="trace-elevation-loss" class="stat-highlight">—</dd>
            <dt>Altitude</dt>
            <dd id="trace-altitude-range">—</dd>
            <dt>Nombre de points</dt>
            <dd id="point-count">—</dd>
            <dt>Type</dt>
            <dd id="trace-type">—</dd>
          </dl>
        </section>

        <div id="layers-section-placeholder"></div>

        <section class="panel-section panel-messages">
          <div id="message" class="message hidden" role="status" aria-live="polite"></div>
        </section>
      </div>
    </aside>

    <main class="map-container">
      <div class="map-main">
        <div id="map"></div>
        <button class="poi-refresh-button" id="poi-refresh-button" type="button" aria-label="Recharger les points d'intérêt">
          <span aria-hidden="true">🔄</span>
          Recharger les POI
        </button>
        <button class="btn-menu" id="menu-toggle" aria-label="Ouvrir le panneau" aria-expanded="false">☰</button>
      </div>
      <div class="elevation-profile" id="elevation-profile" aria-hidden="true">
        <div class="elevation-header" id="elevation-header">
          <div class="elevation-title" title="Profil altimétrique">
            <span class="elevation-icon" aria-hidden="true">📊</span>
            <h3>Profil altimétrique</h3>
          </div>
          <div class="elevation-stats-quick">
            <span class="stat-item">
              <span class="stat-label">Distance :</span>
              <span class="stat-value" id="profile-distance">—</span>
            </span>
            <span class="stat-item">
              <span class="stat-label">D+ :</span>
              <span class="stat-value" id="profile-elevation-gain">—</span>
            </span>
            <span class="stat-item">
              <span class="stat-label">D- :</span>
              <span class="stat-value" id="profile-elevation-loss">—</span>
            </span>
          </div>
          <button class="btn-collapse" id="elevation-collapse" type="button" aria-expanded="true" aria-label="Réduire le profil">
            <span aria-hidden="true">▼</span>
          </button>
        </div>
        <div class="elevation-content" id="elevation-content">
          <canvas
            id="elevation-canvas"
            role="img"
            aria-label="Graphique du profil altimétrique de la trace"
            aria-describedby="elevation-description"
            tabindex="0"
          ></canvas>
          <div id="elevation-description" class="sr-only">
            Le graphique montre l'élévation en mètres en fonction de la distance parcourue en kilomètres.
            Distance totale : <span id="aria-distance">—</span>.
            Dénivelé positif : <span id="aria-d-plus">—</span>.
            Altitude minimum : <span id="aria-min">—</span>.
            Altitude maximum : <span id="aria-max">—</span>.
          </div>
          <div class="elevation-tooltip" id="elevation-tooltip" style="display: none;">
            <div class="tooltip-row">
              <span class="tooltip-label">Distance :</span>
              <span class="tooltip-value" id="tooltip-distance">—</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Altitude :</span>
              <span class="tooltip-value" id="tooltip-elevation">—</span>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <input id="file-input" type="file" accept=".gpx" hidden />

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
  <script>
    /**
     * Convertit un élément XML GPX en GeoJSON Feature.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertPoint(element, featureType) {
      if (!element) {
        return null;
      }

      const lat = parseFloat(element.getAttribute('lat'));
      const lon = parseFloat(element.getAttribute('lon'));

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }

      const properties = { kind: featureType };

      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const ele = element.querySelector('ele');
      if (ele && ele.textContent.trim()) {
        const elevation = parseFloat(ele.textContent.trim());
        if (Number.isFinite(elevation)) {
          properties.ele = elevation;
        }
      }

      const time = element.querySelector('time');
      if (time && time.textContent.trim()) {
        properties.time = time.textContent.trim();
      }

      return {
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [lon, lat]
        },
        properties
      };
    }

    /**
     * Convertit une liste de points GPX en coordonnées GeoJSON.
     * @param {NodeListOf<Element>} points
     * @returns {number[][]}
     */
    function extractCoordinates(points) {
      const coordinates = [];
      points.forEach((point) => {
        const lat = parseFloat(point.getAttribute('lat'));
        const lon = parseFloat(point.getAttribute('lon'));
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          coordinates.push([lon, lat]);
        }
      });
      return coordinates;
    }

    /**
     * Convertit un élément GPX en GeoJSON pour les routes ou pistes.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertLinearFeature(element, featureType) {
      if (!element) {
        return null;
      }

      const properties = { kind: featureType };
      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const segments = [];

      if (featureType === 'track') {
        const trksegs = element.querySelectorAll('trkseg');
        trksegs.forEach((segment) => {
          const coords = extractCoordinates(segment.querySelectorAll('trkpt'));
          if (coords.length > 1) {
            segments.push(coords);
          }
        });
      } else if (featureType === 'route') {
        const coords = extractCoordinates(element.querySelectorAll('rtept'));
        if (coords.length > 1) {
          segments.push(coords);
        }
      }

      if (segments.length === 0) {
        return null;
      }

      const geometry =
        segments.length === 1
          ? { type: 'LineString', coordinates: segments[0] }
          : { type: 'MultiLineString', coordinates: segments };

      return {
        type: 'Feature',
        geometry,
        properties
      };
    }

    /**
     * Réalise une conversion minimale GPX -> GeoJSON pour les traces, routes et waypoints.
     * @param {XMLDocument} xml
     * @returns {GeoJSON.FeatureCollection}
     */
    function convertGpxToGeoJSON(xml) {
      const features = [];

      xml.querySelectorAll('wpt').forEach((wpt) => {
        const feature = convertPoint(wpt, 'waypoint');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('rte').forEach((route) => {
        const feature = convertLinearFeature(route, 'route');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('trk').forEach((track) => {
        const feature = convertLinearFeature(track, 'track');
        if (feature) {
          features.push(feature);
        }
      });

      return {
        type: 'FeatureCollection',
        features
      };
    }

    const OVERPASS_ENDPOINTS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://overpass.openstreetmap.fr/api/interpreter'
    ];

    const POI_GROUPS = {
      bike_services: { id: 'bike_services', label: 'Services vélo', icon: '🚴', defaultExpanded: true, order: 1 },
      resources: { id: 'resources', label: 'Ressources', icon: '💧', defaultExpanded: true, order: 2 },
      accommodation_outdoor: { id: 'accommodation_outdoor', label: 'Hébergement outdoor', icon: '🏕️', defaultExpanded: true, order: 3 },
      accommodation: { id: 'accommodation', label: 'Hébergement', icon: '🏨', defaultExpanded: false, order: 4 },
      sanitary: { id: 'sanitary', label: 'Sanitaires', icon: '🚻', defaultExpanded: true, order: 5 },
      food_shop: { id: 'food_shop', label: 'Alimentation', icon: '🛒', defaultExpanded: true, order: 6 },
      food_service: { id: 'food_service', label: 'Restauration', icon: '🍴', defaultExpanded: false, order: 7 },
      health: { id: 'health', label: 'Santé', icon: '💊', defaultExpanded: true, order: 8 },
      heritage: { id: 'heritage', label: 'Patrimoine', icon: '🪦', defaultExpanded: false, order: 9 }
    };

    const POI_CATEGORIES = {
      bicycle_repair: {
        id: 'bicycle_repair',
        label: 'Stations réparation',
        icon: '🔧',
        color: '#FF6B00',
        group: 'bike_services',
        tags: { amenity: 'bicycle_repair_station' },
        priority: 'high',
        minZoom: 12
      },
      bicycle_shop: {
        id: 'bicycle_shop',
        label: 'Magasins vélo',
        icon: '🚲',
        color: '#FF8C00',
        group: 'bike_services',
        tags: { shop: 'bicycle' },
        priority: 'high',
        minZoom: 12
      },
      drinking_water: {
        id: 'drinking_water',
        label: 'Eau potable',
        icon: '💧',
        color: '#2196F3',
        group: 'resources',
        tags: { amenity: 'drinking_water' },
        priority: 'high',
        minZoom: 11
      },
      camp_site: {
        id: 'camp_site',
        label: 'Camping',
        icon: '🏕️',
        color: '#4CAF50',
        group: 'accommodation_outdoor',
        tags: { tourism: 'camp_site' },
        excludeTags: { backcountry: 'yes' },
        priority: 'high',
        minZoom: 11
      },
      camp_site_backcountry: {
        id: 'camp_site_backcountry',
        label: 'Bivouac autorisé',
        icon: '⛺',
        color: '#66BB6A',
        group: 'accommodation_outdoor',
        tags: { tourism: 'camp_site', backcountry: 'yes' },
        priority: 'high',
        minZoom: 11
      },
      wilderness_hut: {
        id: 'wilderness_hut',
        label: 'Refuge',
        icon: '🛖',
        color: '#8D6E63',
        group: 'accommodation_outdoor',
        tags: { tourism: 'wilderness_hut' },
        priority: 'high',
        minZoom: 11
      },
      alpine_hut: {
        id: 'alpine_hut',
        label: 'Refuge alpin',
        icon: '🏔️',
        color: '#795548',
        group: 'accommodation_outdoor',
        tags: { tourism: 'alpine_hut' },
        priority: 'high',
        minZoom: 11
      },
      hotel: {
        id: 'hotel',
        label: 'Hôtel',
        icon: '🏨',
        color: '#9C27B0',
        group: 'accommodation',
        tags: { tourism: 'hotel' },
        priority: 'medium',
        minZoom: 12
      },
      hostel: {
        id: 'hostel',
        label: 'Auberge de jeunesse',
        icon: '🏠',
        color: '#AB47BC',
        group: 'accommodation',
        tags: { tourism: 'hostel' },
        priority: 'medium',
        minZoom: 12
      },
      guest_house: {
        id: 'guest_house',
        label: "Chambre d'hôtes",
        icon: '🏡',
        color: '#BA68C8',
        group: 'accommodation',
        tags: { tourism: 'guest_house' },
        priority: 'medium',
        minZoom: 13
      },
      toilets: {
        id: 'toilets',
        label: 'Toilettes',
        icon: '🚻',
        color: '#607D8B',
        group: 'sanitary',
        tags: { amenity: 'toilets' },
        priority: 'high',
        minZoom: 12
      },
      shower: {
        id: 'shower',
        label: 'Douches',
        icon: '🚿',
        color: '#78909C',
        group: 'sanitary',
        tags: { amenity: 'shower' },
        priority: 'medium',
        minZoom: 13
      },
      supermarket: {
        id: 'supermarket',
        label: 'Supermarché',
        icon: '🛒',
        color: '#FF5252',
        group: 'food_shop',
        tags: { shop: 'supermarket' },
        priority: 'high',
        minZoom: 12
      },
      convenience: {
        id: 'convenience',
        label: 'Épicerie',
        icon: '🏪',
        color: '#FF7043',
        group: 'food_shop',
        tags: { shop: 'convenience' },
        priority: 'high',
        minZoom: 12
      },
      restaurant: {
        id: 'restaurant',
        label: 'Restaurant',
        icon: '🍴',
        color: '#FFC107',
        group: 'food_service',
        tags: { amenity: 'restaurant' },
        priority: 'medium',
        minZoom: 13
      },
      cafe: {
        id: 'cafe',
        label: 'Café',
        icon: '☕',
        color: '#FFD54F',
        group: 'food_service',
        tags: { amenity: 'cafe' },
        priority: 'medium',
        minZoom: 13
      },
      fast_food: {
        id: 'fast_food',
        label: 'Fast-food',
        icon: '🍔',
        color: '#FFEB3B',
        group: 'food_service',
        tags: { amenity: 'fast_food' },
        priority: 'low',
        minZoom: 13
      },
      pharmacy: {
        id: 'pharmacy',
        label: 'Pharmacie',
        icon: '💊',
        color: '#00C853',
        group: 'health',
        tags: { amenity: 'pharmacy' },
        priority: 'high',
        minZoom: 12
      },
      cemetery: {
        id: 'cemetery',
        label: 'Cimetière',
        icon: '🪦',
        color: '#6A1B9A',
        group: 'heritage',
        tags: { landuse: 'cemetery' },
        priority: 'low',
        minZoom: 12
      },
      grave_yard: {
        id: 'grave_yard',
        label: 'Petit cimetière',
        icon: '⛪',
        color: '#757575',
        group: 'heritage',
        tags: { amenity: 'grave_yard' },
        priority: 'low',
        minZoom: 12
      },
      crematorium: {
        id: 'crematorium',
        label: 'Crématorium',
        icon: '🕯️',
        color: '#424242',
        group: 'heritage',
        tags: { amenity: 'crematorium' },
        priority: 'low',
        minZoom: 13
      }
    };

    const LAYER_PRESETS = {
      bikepacking: {
        label: 'Bikepacking',
        icon: '🚴',
        categories: [
          'bicycle_repair',
          'bicycle_shop',
          'drinking_water',
          'camp_site',
          'camp_site_backcountry',
          'supermarket',
          'convenience',
          'pharmacy'
        ]
      },
      hiking: {
        label: 'Randonnée',
        icon: '🥾',
        categories: [
          'drinking_water',
          'wilderness_hut',
          'alpine_hut',
          'camp_site',
          'toilets',
          'pharmacy'
        ]
      },
      touring: {
        label: 'Voyage à vélo',
        icon: '🚵',
        categories: [
          'bicycle_repair',
          'drinking_water',
          'camp_site',
          'hotel',
          'hostel',
          'supermarket',
          'restaurant',
          'cafe',
          'pharmacy'
        ]
      },
      urban: {
        label: 'Urbain',
        icon: '🏙️',
        categories: [
          'bicycle_shop',
          'drinking_water',
          'toilets',
          'supermarket',
          'convenience',
          'restaurant',
          'cafe',
          'fast_food',
          'pharmacy'
        ]
      }
    };

    const POI_SETTINGS = {
      debounceMs: 2000,
      minZoomDefault: 11,
      maxTotalItems: 500,
      maxItemsPerCategory: 120,
      cacheTtlMs: 10 * 60 * 1000,
      maxCacheEntries: 15,
      areaLimitDegSq: 0.12,
      maxRetries: 2,
      requestTimeoutMs: 12000
    };

    const poiCache = {
      data: new Map(),
      set(key, value) {
        this.data.set(key, { value, timestamp: Date.now() });
      },
      get(key) {
        const entry = this.data.get(key);
        if (!entry) {
          return null;
        }
        if (Date.now() - entry.timestamp > POI_SETTINGS.cacheTtlMs) {
          this.data.delete(key);
          return null;
        }
        return entry.value;
      },
      prune(maxEntries) {
        if (this.data.size <= maxEntries) {
          return;
        }
        const sorted = Array.from(this.data.entries()).sort(
          (a, b) => a[1].timestamp - b[1].timestamp
        );
        while (sorted.length > maxEntries) {
          const [keyToDelete] = sorted.shift();
          this.data.delete(keyToDelete);
        }
      },
      clear() {
        this.data.clear();
      }
    };

    const poiRequestLimiter = {
      lastRequest: 0,
      minInterval: 1500
    };

    const poiManager = {
      activeCategories: new Set(),
      expandedGroups: new Set(),
      layerGroups: new Map(),
      counts: new Map(),
      debounceTimer: null,
      abortController: null,
      currentRequestId: 0,
      loading: false,
      enabled: false,
      refreshPending: false,
      suppressRefreshPrompt: false,
      stats: {
        totalLoaded: 0,
        currentDisplayed: 0,
        requestCount: 0,
        errorCount: 0
      }
    };

    let layersSectionElement = null;
    let layersLoadingElement = null;
    let layersErrorElement = null;
    let layersInfoElement = null;
    let layersZoomInfoElement = null;
    let layersTotalElement = null;
    let layersTotalCountElement = null;
    let presetSelectElement = null;
    let isApplyingPreset = false;

    function getDefaultExpandedGroups() {
      return new Set(
        Object.values(POI_GROUPS)
          .filter((group) => group.defaultExpanded)
          .map((group) => group.id)
      );
    }

    function getDefaultActiveCategories() {
      return new Set(['cemetery', 'grave_yard']);
    }

    function loadLayerPreferences() {
      try {
        const raw = localStorage.getItem('gpx_layer_preferences');
        if (!raw) {
          return null;
        }
        const parsed = JSON.parse(raw);
        const active = new Set(
          Array.isArray(parsed.activeCategories)
            ? parsed.activeCategories.filter((id) => POI_CATEGORIES[id])
            : []
        );
        const expanded = new Set(
          Array.isArray(parsed.expandedGroups)
            ? parsed.expandedGroups.filter((id) => POI_GROUPS[id])
            : []
        );
        return { active, expanded };
      } catch (error) {
        console.warn('Impossible de charger les préférences:', error);
        return null;
      }
    }

    function saveLayerPreferences() {
      const data = {
        activeCategories: Array.from(poiManager.activeCategories),
        expandedGroups: Array.from(poiManager.expandedGroups)
      };
      try {
        localStorage.setItem('gpx_layer_preferences', JSON.stringify(data));
      } catch (error) {
        console.warn('Impossible de sauvegarder les préférences:', error);
      }
    }

    function generateLayersHTML() {
      const groups = Object.values(POI_GROUPS).sort((a, b) => a.order - b.order);
      let html = `
        <section class="panel-section layer-section" id="layers-section">
          <h3 class="section-title">Calques et affichage</h3>
          <div class="layer-global-actions">
            <button type="button" class="btn btn-secondary btn-small" id="layers-enable-all">Activer tout</button>
            <button type="button" class="btn btn-secondary btn-small" id="layers-disable-all">Désactiver tout</button>
          </div>
          <div class="layer-presets">
            <label for="preset-select">Profil :</label>
            <select id="preset-select" class="preset-select">
              <option value="">Personnalisé</option>`;
      Object.entries(LAYER_PRESETS).forEach(([presetId, preset]) => {
        html += `
              <option value="${presetId}">${preset.icon} ${preset.label}</option>`;
      });
      html += `
            </select>
          </div>`;
      groups.forEach((group) => {
        const categories = Object.values(POI_CATEGORIES).filter((category) => category.group === group.id);
        if (categories.length === 0) {
          return;
        }
        const isExpanded = poiManager.expandedGroups.has(group.id);
        html += `
          <div class="layer-group ${isExpanded ? 'expanded' : ''}" data-group="${group.id}">
            <button class="layer-group-header" type="button" data-group="${group.id}" aria-expanded="${isExpanded ? 'true' : 'false'}">
              <span class="layer-group-icon">${group.icon}</span>
              <span class="layer-group-label">${group.label}</span>
              <span class="layer-group-count">(${categories.length})</span>
              <span class="layer-group-chevron">▼</span>
            </button>
            <div class="layer-group-content">`;
        categories.forEach((category) => {
          const isChecked = poiManager.activeCategories.has(category.id) ? 'checked' : '';
          html += `
              <label class="layer-toggle" data-category="${category.id}">
                <input
                  type="checkbox"
                  id="layer-${category.id}"
                  class="toggle-input layer-checkbox"
                  data-category="${category.id}"
                  ${isChecked}
                />
                <span class="toggle-switch"></span>
                <span class="toggle-text">
                  <span class="toggle-icon" aria-hidden="true">${category.icon}</span>
                  ${category.label}
                </span>
                <span class="toggle-count" id="count-${category.id}" style="display: none;">(0)</span>
              </label>`;
        });
        html += `
            </div>
          </div>`;
      });
      html += `
          <div class="layer-indicators">
            <div class="layer-loading" id="layers-loading" style="display: none;">
              <span class="loading-spinner" aria-hidden="true">⏳</span>
              Chargement des POI...
            </div>
            <div class="layer-error" id="layers-error" style="display: none;" role="alert"></div>
            <div class="layer-info" id="layers-info" style="display: none;"></div>
            <div class="layer-info" id="layers-zoom-info" style="display: none;"></div>
          </div>
          <div class="layer-total" id="layers-total" style="display: none;">
            <strong>Total POI affichés :</strong>
            <span class="layer-count-value" id="layers-total-count">0</span>
          </div>
        </section>`;
      return html;
    }

    function attachLayerEventHandlers() {
      const enableAllButton = document.getElementById('layers-enable-all');
      const disableAllButton = document.getElementById('layers-disable-all');
      if (enableAllButton) {
        enableAllButton.addEventListener('click', () => enableAllCategories());
      }
      if (disableAllButton) {
        disableAllButton.addEventListener('click', () => disableAllCategories());
      }
      if (presetSelectElement) {
        presetSelectElement.addEventListener('change', handlePresetChange);
      }
      document.querySelectorAll('.layer-group-header').forEach((header) => {
        header.addEventListener('click', () => {
          const groupId = header.getAttribute('data-group');
          toggleGroupExpanded(groupId);
        });
      });
      document.querySelectorAll('.layer-checkbox').forEach((checkbox) => {
        checkbox.addEventListener('change', handleCategoryCheckboxChange);
      });
    }

    function renderLayersSection() {
      const placeholder = document.getElementById('layers-section-placeholder');
      if (!placeholder) {
        return;
      }
      placeholder.innerHTML = generateLayersHTML();
      layersSectionElement = document.getElementById('layers-section');
      layersLoadingElement = document.getElementById('layers-loading');
      layersErrorElement = document.getElementById('layers-error');
      layersInfoElement = document.getElementById('layers-info');
      layersZoomInfoElement = document.getElementById('layers-zoom-info');
      layersTotalElement = document.getElementById('layers-total');
      layersTotalCountElement = document.getElementById('layers-total-count');
      presetSelectElement = document.getElementById('preset-select');
      attachLayerEventHandlers();
      hideLayersIndicators();
      updateAllPOICounts();
      updateTotalPOICount(0);
      updatePresetSelection();
    }

    function ensureLayerGroup(categoryId) {
      if (!poiManager.layerGroups.has(categoryId)) {
        poiManager.layerGroups.set(categoryId, L.layerGroup());
      }
      return poiManager.layerGroups.get(categoryId);
    }

    function setCategoryCheckboxState(categoryId, isChecked) {
      const checkbox = document.getElementById(`layer-${categoryId}`);
      if (checkbox) {
        checkbox.checked = Boolean(isChecked);
      }
    }

    function updateCategoryCountUI(categoryId, count) {
      const element = document.getElementById(`count-${categoryId}`);
      if (!element) {
        return;
      }
      if (count > 0) {
        element.textContent = `(${count})`;
        element.style.display = 'inline';
      } else {
        element.style.display = 'none';
      }
    }

    function updateAllPOICounts() {
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        const count = poiManager.counts.get(categoryId) || 0;
        updateCategoryCountUI(categoryId, count);
      });
    }

    function updateTotalPOICount(total) {
      if (!layersTotalElement || !layersTotalCountElement) {
        return;
      }
      if (total > 0) {
        layersTotalElement.style.display = 'flex';
        layersTotalCountElement.textContent = String(total);
      } else {
        layersTotalElement.style.display = 'none';
        layersTotalCountElement.textContent = '0';
      }
    }

    function hideLayersIndicators() {
      hideLayersLoading();
      hideLayersError();
      hideLayersInfo();
      hideLayersZoomInfo();
    }

    function showLayersLoading() {
      if (layersLoadingElement) {
        layersLoadingElement.style.display = 'flex';
      }
    }

    function hideLayersLoading() {
      if (layersLoadingElement) {
        layersLoadingElement.style.display = 'none';
      }
    }

    function showLayersError(message) {
      if (layersErrorElement) {
        layersErrorElement.textContent = `⚠️ ${message}`;
        layersErrorElement.style.display = 'block';
      }
    }

    function hideLayersError() {
      if (layersErrorElement) {
        layersErrorElement.style.display = 'none';
        layersErrorElement.textContent = '';
      }
    }

    function showLayersInfo(message) {
      if (layersInfoElement) {
        layersInfoElement.textContent = message;
        layersInfoElement.style.display = 'block';
      }
    }

    function hideLayersInfo() {
      if (layersInfoElement) {
        layersInfoElement.style.display = 'none';
        layersInfoElement.textContent = '';
      }
    }

    function showLayersZoomInfo(minZoom) {
      if (layersZoomInfoElement) {
        layersZoomInfoElement.textContent = `ℹ️ Zoomez davantage pour voir les POI (zoom ≥ ${minZoom})`;
        layersZoomInfoElement.style.display = 'block';
      }
    }

    function hideLayersZoomInfo() {
      if (layersZoomInfoElement) {
        layersZoomInfoElement.style.display = 'none';
        layersZoomInfoElement.textContent = '';
      }
    }

    function showPoiRefreshButton() {
      if (!poiRefreshButton) {
        return;
      }
      poiRefreshButton.style.display = 'inline-flex';
      poiRefreshButton.setAttribute('aria-hidden', 'false');
    }

    function hidePoiRefreshButton() {
      if (!poiRefreshButton) {
        return;
      }
      poiRefreshButton.style.display = 'none';
      poiRefreshButton.setAttribute('aria-hidden', 'true');
    }

    function toggleGroupExpanded(groupId) {
      if (!groupId || !POI_GROUPS[groupId]) {
        return;
      }
      if (poiManager.expandedGroups.has(groupId)) {
        poiManager.expandedGroups.delete(groupId);
      } else {
        poiManager.expandedGroups.add(groupId);
      }
      saveLayerPreferences();
      const groupElement = document.querySelector(`.layer-group[data-group="${groupId}"]`);
      if (groupElement) {
        const header = groupElement.querySelector('.layer-group-header');
        const expanded = poiManager.expandedGroups.has(groupId);
        groupElement.classList.toggle('expanded', expanded);
        if (header) {
          header.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        }
      }
    }

    function handleCategoryCheckboxChange(event) {
      const checkbox = event.target;
      const categoryId = checkbox.getAttribute('data-category');
      setCategoryEnabled(categoryId, checkbox.checked);
    }

    function handlePresetChange(event) {
      const presetId = event.target.value;
      if (!presetId) {
        updatePresetSelection();
        return;
      }
      applyPreset(presetId);
    }

    function updatePresetSelection() {
      if (!presetSelectElement || isApplyingPreset) {
        return;
      }
      const active = Array.from(poiManager.activeCategories).sort();
      let matched = '';
      Object.entries(LAYER_PRESETS).some(([presetId, preset]) => {
        const presetCategories = preset.categories.filter((id) => POI_CATEGORIES[id]).sort();
        if (
          presetCategories.length === active.length &&
          presetCategories.every((value, index) => value === active[index])
        ) {
          matched = presetId;
          return true;
        }
        return false;
      });
      presetSelectElement.value = matched;
    }

    function applyPreset(presetId) {
      const preset = LAYER_PRESETS[presetId];
      if (!preset) {
        return;
      }
      isApplyingPreset = true;
      cancelPendingPOILoad();
      disableAllCategories({ triggerLoad: false, persist: false, skipPresetSync: true });
      preset.categories.forEach((categoryId) => {
        if (POI_CATEGORIES[categoryId]) {
          setCategoryEnabled(categoryId, true, { triggerLoad: false, persist: false, skipPresetSync: true });
        }
      });
      saveLayerPreferences();
      isApplyingPreset = false;
      updatePresetSelection();
      loadPOIForCurrentView(true);
    }

    function enableAllCategories() {
      cancelPendingPOILoad();
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        setCategoryEnabled(categoryId, true, { triggerLoad: false, persist: false, skipPresetSync: true });
      });
      saveLayerPreferences();
      updatePresetSelection();
      loadPOIForCurrentView(true);
    }

    function disableAllCategories(options = {}) {
      const { triggerLoad = true, persist = true, skipPresetSync = false } = options;
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        setCategoryEnabled(categoryId, false, { triggerLoad: false, persist: false, skipPresetSync: true });
      });
      if (persist) {
        saveLayerPreferences();
      }
      if (!skipPresetSync) {
        updatePresetSelection();
      }
      if (triggerLoad) {
        clearAllPOILayers();
        hideLayersIndicators();
      }
    }

    function setCategoryEnabled(categoryId, enabled, options = {}) {
      const { triggerLoad = true, persist = true, skipPresetSync = false } = options;
      const category = POI_CATEGORIES[categoryId];
      if (!category) {
        return;
      }
      const isActive = poiManager.activeCategories.has(categoryId);
      if (enabled === isActive) {
        setCategoryCheckboxState(categoryId, enabled);
        return;
      }
      if (enabled) {
        poiManager.activeCategories.add(categoryId);
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
        poiManager.counts.set(categoryId, poiManager.counts.get(categoryId) || 0);
        setCategoryCheckboxState(categoryId, true);
      } else {
        poiManager.activeCategories.delete(categoryId);
        const layerGroup = poiManager.layerGroups.get(categoryId);
        if (layerGroup) {
          layerGroup.clearLayers();
          if (map.hasLayer(layerGroup)) {
            map.removeLayer(layerGroup);
          }
        }
        poiManager.counts.set(categoryId, 0);
        setCategoryCheckboxState(categoryId, false);
      }
      if (persist) {
        saveLayerPreferences();
      }
      if (!skipPresetSync) {
        updatePresetSelection();
      }
      updateCategoryCountUI(categoryId, poiManager.counts.get(categoryId) || 0);
      if (triggerLoad) {
        cancelPendingPOILoad();
        loadPOIForCurrentView(true);
      }
    }

    function clearAllPOILayers() {
      poiManager.layerGroups.forEach((layerGroup, categoryId) => {
        layerGroup.clearLayers();
        if (!poiManager.activeCategories.has(categoryId) && map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
      });
      poiManager.counts.clear();
      updateAllPOICounts();
      updateTotalPOICount(0);
    }

    function cancelPendingPOILoad() {
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
        poiManager.debounceTimer = null;
      }
      if (poiManager.abortController) {
        poiManager.abortController.abort();
        poiManager.abortController = null;
      }
      poiManager.loading = false;
      hideLayersLoading();
    }

    function getMinZoomForActiveCategories() {
      let minZoom = POI_SETTINGS.minZoomDefault;
      poiManager.activeCategories.forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (category && category.minZoom) {
          minZoom = Math.max(minZoom, category.minZoom);
        }
      });
      return minZoom;
    }

    function isBoundsTooLarge(bounds) {
      const north = bounds.getNorth();
      const south = bounds.getSouth();
      const east = bounds.getEast();
      const west = bounds.getWest();
      const latDiff = Math.abs(north - south);
      const lngDiff = Math.abs(east - west);
      return latDiff * lngDiff > POI_SETTINGS.areaLimitDegSq;
    }

    function handlePOIViewportChange() {
      if (!poiManager.enabled) {
        return;
      }
      if (poiManager.suppressRefreshPrompt) {
        poiManager.suppressRefreshPrompt = false;
        return;
      }
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
      }
      poiManager.debounceTimer = setTimeout(() => {
        if (poiManager.activeCategories.size === 0 || poiManager.loading) {
          poiManager.refreshPending = false;
          hidePoiRefreshButton();
          return;
        }
        poiManager.refreshPending = true;
        showPoiRefreshButton();
      }, POI_SETTINGS.debounceMs);
    }

    function buildCacheKey(bounds, activeCategories) {
      const precision = 3;
      const boundsKey = [
        bounds.getSouth().toFixed(precision),
        bounds.getWest().toFixed(precision),
        bounds.getNorth().toFixed(precision),
        bounds.getEast().toFixed(precision)
      ].join(',');
      const categoriesKey = Array.from(activeCategories).sort().join(',');
      return `${boundsKey}|${categoriesKey}`;
    }

    function buildMultiCategoryOverpassQuery(bounds, activeCategories) {
      if (!activeCategories || activeCategories.size === 0) {
        return null;
      }
      const south = bounds.getSouth();
      const west = bounds.getWest();
      const north = bounds.getNorth();
      const east = bounds.getEast();
      const bbox = `${south},${west},${north},${east}`;
      const queryParts = [];
      Array.from(activeCategories).forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          return;
        }
        const required = Object.entries(category.tags);
        const excludes = Object.entries(category.excludeTags || {});
        const filters = required
          .map(([key, value]) => `["${key}"="${value}"]`)
          .join('');
        const excludeFilters = excludes
          .map(([key, value]) => `["${key}"!="${value}"]`)
          .join('');
        ['node', 'way', 'relation'].forEach((type) => {
          queryParts.push(`${type}${filters}${excludeFilters};`);
        });
      });
      if (queryParts.length === 0) {
        return null;
      }
      return `
        [out:json][timeout:25][bbox:${bbox}];
        (
          ${queryParts.join('\n          ')}
        );
        out center;
      `.trim();
    }

    async function loadPOIForCurrentView(force = false) {
      if (!poiManager.enabled) {
        return;
      }
      if (poiManager.loading && !force) {
        return;
      }
      if (poiManager.activeCategories.size === 0) {
        clearAllPOILayers();
        hideLayersIndicators();
        return;
      }
      const bounds = map.getBounds();
      const minZoom = getMinZoomForActiveCategories();
      if (map.getZoom() < minZoom) {
        clearAllPOILayers();
        showLayersZoomInfo(minZoom);
        hideLayersLoading();
        return;
      }
      if (isBoundsTooLarge(bounds)) {
        clearAllPOILayers();
        showLayersError('Zone trop grande, veuillez zoomer davantage.');
        hideLayersLoading();
        return;
      }
      hideLayersZoomInfo();
      hideLayersError();
      hideLayersInfo();
      const cacheKey = buildCacheKey(bounds, poiManager.activeCategories);
      const cached = poiCache.get(cacheKey);
      if (cached) {
        displayMultiCategoryPOIs(cached);
        return;
      }
      const requestId = ++poiManager.currentRequestId;
      poiManager.loading = true;
      showLayersLoading();
      try {
        const pois = await fetchPOIsFromOverpass(bounds, poiManager.activeCategories);
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiCache.set(cacheKey, pois);
        poiCache.prune(POI_SETTINGS.maxCacheEntries);
        displayMultiCategoryPOIs(pois);
        poiManager.stats.totalLoaded += pois.length;
        poiManager.stats.requestCount += 1;
      } catch (error) {
        if (error && error.name === 'AbortError') {
          return;
        }
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiManager.stats.errorCount += 1;
        clearAllPOILayers();
        showLayersError(error?.message || 'Impossible de charger les POI.');
      } finally {
        if (poiManager.currentRequestId === requestId) {
          poiManager.loading = false;
          hideLayersLoading();
          poiManager.abortController = null;
        }
      }
    }

    async function enforceRequestThrottle() {
      const now = Date.now();
      const elapsed = now - poiRequestLimiter.lastRequest;
      if (elapsed < poiRequestLimiter.minInterval) {
        await new Promise((resolve) => setTimeout(resolve, poiRequestLimiter.minInterval - elapsed));
      }
      poiRequestLimiter.lastRequest = Date.now();
    }

    async function fetchPOIsFromOverpass(bounds, activeCategories) {
      const query = buildMultiCategoryOverpassQuery(bounds, activeCategories);
      if (!query) {
        return [];
      }
      let lastError = null;
      const activeSnapshot = new Set(activeCategories);
      for (let attempt = 0; attempt <= POI_SETTINGS.maxRetries; attempt++) {
        const endpoint = OVERPASS_ENDPOINTS[attempt % OVERPASS_ENDPOINTS.length];
        const controller = new AbortController();
        poiManager.abortController = controller;
        let timedOut = false;
        const timeoutId = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, POI_SETTINGS.requestTimeoutMs);
        try {
          await enforceRequestThrottle();
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `data=${encodeURIComponent(query)}`,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            if (response.status === 429) {
              lastError = new Error('Trop de requêtes. Veuillez patienter quelques instants.');
            } else if (response.status === 504) {
              lastError = new Error('Timeout du serveur. Essayez de zoomer davantage.');
            } else {
              lastError = new Error(`Erreur HTTP ${response.status}`);
            }
            continue;
          }
          const data = await response.json();
          const elements = Array.isArray(data?.elements) ? data.elements : [];
          const parsed = elements
            .map((element) => parseMultiCategoryPOI(element, activeSnapshot))
            .filter(Boolean);
          return parsed;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            if (timedOut) {
              lastError = new Error('Timeout de la requête');
              continue;
            }
            throw error;
          }
          lastError =
            error instanceof Error
              ? error
              : new Error('Erreur inconnue lors du chargement des POI.');
        } finally {
          if (poiManager.abortController === controller) {
            poiManager.abortController = null;
          }
        }
      }
      throw lastError || new Error('Impossible de récupérer les POI.');
    }

    function parseMultiCategoryPOI(element, activeCategoryIds) {
      if (!element || !element.tags) {
        return null;
      }
      const tags = element.tags;
      let lat;
      let lon;
      if (element.type === 'node') {
        lat = element.lat;
        lon = element.lon;
      } else if (element.center) {
        lat = element.center.lat;
        lon = element.center.lon;
      }
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }
      const orderedCategories = Array.from(activeCategoryIds).sort();
      for (const categoryId of orderedCategories) {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          continue;
        }
        const requiredEntries = Object.entries(category.tags);
        let matches = true;
        for (const [key, value] of requiredEntries) {
          if (tags[key] !== value) {
            matches = false;
            break;
          }
        }
        if (!matches) {
          continue;
        }
        const excludeEntries = Object.entries(category.excludeTags || {});
        let excluded = false;
        for (const [key, value] of excludeEntries) {
          if (tags[key] === value) {
            excluded = true;
            break;
          }
        }
        if (excluded) {
          continue;
        }
        const addressParts = [];
        if (tags['addr:housenumber'] && tags['addr:street']) {
          addressParts.push(`${tags['addr:housenumber']} ${tags['addr:street']}`);
        } else if (tags['addr:street']) {
          addressParts.push(tags['addr:street']);
        }
        if (tags['addr:city']) {
          addressParts.push(tags['addr:city']);
        }
        const metadata = {
          opening_hours: tags.opening_hours || null,
          phone: tags.phone || tags.contact_phone || null,
          website: tags.website || tags.contact_website || null,
          capacity: tags.capacity || null,
          fee: tags.fee || null,
          access: tags.access || null,
          drinking_water: tags.drinking_water || null,
          shower: tags.shower || null,
          toilets: tags.toilets || null,
          cuisine: tags.cuisine || null
        };
        return {
          id: element.id,
          osmType: element.type,
          lat,
          lon,
          categoryId,
          name: tags.name || 'Sans nom',
          address: addressParts.join(', ') || null,
          metadata
        };
      }
      return null;
    }

    function createMultiCategoryPOIMarker(poi, category) {
      if (!poi || !category) {
        return null;
      }
      const icon = L.divIcon({
        className: 'poi-marker',
        html: `
          <div class="poi-marker-inner" style="background-color: ${category.color};">
            <span class="poi-marker-icon">${category.icon}</span>
          </div>
        `,
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      });
      const marker = L.marker([poi.lat, poi.lon], {
        icon,
        opacity: 0.9,
        title: poi.name
      });
      marker.bindPopup(createMultiCategoryPOIPopup(poi, category), {
        maxWidth: 320,
        className: 'poi-popup-container'
      });
      if (poi.name) {
        marker.bindTooltip(poi.name, {
          direction: 'top',
          offset: [0, -14]
        });
      }
      return marker;
    }

    function createMultiCategoryPOIPopup(poi, category) {
      const meta = poi.metadata || {};
      let html = `
        <div class="poi-popup">
          <div class="poi-header">
            <span class="poi-icon" aria-hidden="true">${category.icon}</span>
            <strong class="poi-name">${escapeHtml(poi.name)}</strong>
          </div>
          <div class="poi-details">
            <div class="poi-row">
              <span class="poi-label">Type :</span>
              <span class="poi-value">${escapeHtml(category.label)}</span>
            </div>`;
      if (poi.address) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Adresse :</span>
              <span class="poi-value">${escapeHtml(poi.address)}</span>
            </div>`;
      }
      if (meta.opening_hours) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Horaires :</span>
              <span class="poi-value">${escapeHtml(meta.opening_hours)}</span>
            </div>`;
      }
      if (meta.phone) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Téléphone :</span>
              <span class="poi-value"><a href="tel:${escapeHtml(meta.phone)}">${escapeHtml(meta.phone)}</a></span>
            </div>`;
      }
      if (meta.website) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Site web :</span>
              <span class="poi-value"><a href="${escapeHtml(meta.website)}" target="_blank" rel="noopener">🔗</a></span>
            </div>`;
      }
      if (meta.capacity) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Capacité :</span>
              <span class="poi-value">${escapeHtml(meta.capacity)}</span>
            </div>`;
      }
      if (meta.fee) {
        const feeLabel = meta.fee === 'yes' ? 'Payant' : meta.fee === 'no' ? 'Gratuit' : escapeHtml(meta.fee);
        html += `
            <div class="poi-row">
              <span class="poi-label">Tarif :</span>
              <span class="poi-value">${feeLabel}</span>
            </div>`;
      }
      if (meta.access && meta.access !== 'yes') {
        html += `
            <div class="poi-row">
              <span class="poi-label">Accès :</span>
              <span class="poi-value">${escapeHtml(meta.access)}</span>
            </div>`;
      }
      if (meta.cuisine) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Cuisine :</span>
              <span class="poi-value">${escapeHtml(meta.cuisine)}</span>
            </div>`;
      }
      const services = [];
      if (meta.drinking_water === 'yes') services.push('💧 Eau potable');
      if (meta.shower === 'yes') services.push('🚿 Douches');
      if (meta.toilets === 'yes') services.push('🚻 Toilettes');
      if (services.length > 0) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Services :</span>
              <span class="poi-value">${services.join(' • ')}</span>
            </div>`;
      }
      html += `
          </div>
          <div class="poi-footer">
            <small>
              <a href="https://www.openstreetmap.org/${poi.osmType}/${poi.id}" target="_blank" rel="noopener noreferrer">
                Voir sur OpenStreetMap ↗
              </a>
            </small>
          </div>
        </div>`;
      return html;
    }

    function displayMultiCategoryPOIs(pois) {
      poiManager.counts.clear();
      poiManager.layerGroups.forEach((layerGroup, categoryId) => {
        if (poiManager.activeCategories.has(categoryId)) {
          layerGroup.clearLayers();
        } else if (map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
      });
      if (!Array.isArray(pois) || pois.length === 0) {
        updateAllPOICounts();
        updateTotalPOICount(0);
        hideLayersInfo();
        return;
      }
      let workingPois = pois.slice();
      let totalLimited = false;
      if (workingPois.length > POI_SETTINGS.maxTotalItems) {
        workingPois = workingPois.slice(0, POI_SETTINGS.maxTotalItems);
        totalLimited = true;
      }
      const grouped = new Map();
      workingPois.forEach((poi) => {
        if (!poi || !poiManager.activeCategories.has(poi.categoryId)) {
          return;
        }
        if (!grouped.has(poi.categoryId)) {
          grouped.set(poi.categoryId, []);
        }
        grouped.get(poi.categoryId).push(poi);
      });
      let categoryLimited = false;
      let total = 0;
      poiManager.activeCategories.forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          return;
        }
        const items = grouped.get(categoryId) || [];
        let limitedItems = items;
        if (items.length > POI_SETTINGS.maxItemsPerCategory) {
          limitedItems = items.slice(0, POI_SETTINGS.maxItemsPerCategory);
          categoryLimited = true;
        }
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
        layerGroup.clearLayers();
        limitedItems.forEach((poi) => {
          const marker = createMultiCategoryPOIMarker(poi, category);
          if (marker) {
            marker.poi = poi;
            layerGroup.addLayer(marker);
          }
        });
        poiManager.counts.set(categoryId, limitedItems.length);
        total += limitedItems.length;
      });
      updateAllPOICounts();
      updateTotalPOICount(total);
      if (total === 0) {
        hideLayersInfo();
      } else if (totalLimited) {
        showLayersInfo(
          `Trop de points d'intérêt (${pois.length}), limitation à ${POI_SETTINGS.maxTotalItems}. Zoomez pour plus de détails.`
        );
      } else if (categoryLimited) {
        showLayersInfo('Certaines catégories contiennent de nombreux POI. Zoomez pour plus de détails.');
      } else {
        hideLayersInfo();
      }
      poiManager.stats.currentDisplayed = total;
    }

    function initPOIManager() {
      const prefs = loadLayerPreferences();
      poiManager.expandedGroups = prefs ? new Set(prefs.expanded) : getDefaultExpandedGroups();
      poiManager.activeCategories = prefs ? new Set(prefs.active) : getDefaultActiveCategories();
      renderLayersSection();
      poiManager.activeCategories.forEach((categoryId) => {
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
      });
      updatePresetSelection();
      poiManager.enabled = true;
      map.on('moveend', handlePOIViewportChange);
      map.on('zoomend', handlePOIViewportChange);
      if (poiManager.activeCategories.size > 0) {
        loadPOIForCurrentView(true);
      } else {
        hideLayersIndicators();
      }
    }

    const map = L.map('map').setView([48.8566, 2.3522], 12);
    map.zoomControl.setPosition('topright');

    // Couche de tuiles OpenStreetMap avec attribution obligatoire
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    const fileInput = document.getElementById('file-input');
    const importButton = document.getElementById('import-button');
    const exportButton = document.getElementById('export-button');
    const gpxNameInput = document.getElementById('gpx-name-input');
    const messageBox = document.getElementById('message');
    const panelDropZone = document.getElementById('panel-drop-zone');
    const toolsPanel = document.getElementById('tools-panel');
    const menuToggle = document.getElementById('menu-toggle');
    const closePanel = document.getElementById('close-panel');
    const fileInfo = document.getElementById('file-info');
    const currentFilename = document.getElementById('current-filename');
    const traceFileNameLabel = document.getElementById('file-name');
    const waypointsSection = document.getElementById('waypoints-section');
    const waypointsList = document.getElementById('waypoints-list');
    const waypointCountLabel = document.getElementById('waypoint-count');
    const clearWaypointsButton = document.getElementById('clear-waypoints');
    const traceInfoSection = document.getElementById('trace-info-section');
    const traceNameLabel = document.getElementById('trace-name');
    const pointCountLabel = document.getElementById('point-count');
    const traceTypeLabel = document.getElementById('trace-type');
    const traceDistanceLabel = document.getElementById('trace-distance');
    const traceElevationGainLabel = document.getElementById('trace-elevation-gain');
    const traceElevationLossLabel = document.getElementById('trace-elevation-loss');
    const traceAltitudeRangeLabel = document.getElementById('trace-altitude-range');
    const ariaDistance = document.getElementById('aria-distance');
    const ariaDPlus = document.getElementById('aria-d-plus');
    const ariaMin = document.getElementById('aria-min');
    const ariaMax = document.getElementById('aria-max');
    const profileDistanceValue = document.getElementById('profile-distance');
    const profileElevationGainValue = document.getElementById('profile-elevation-gain');
    const profileElevationLossValue = document.getElementById('profile-elevation-loss');
    const elevationProfile = document.getElementById('elevation-profile');
    const elevationHeader = document.getElementById('elevation-header');
    const elevationCollapseButton = document.getElementById('elevation-collapse');
    const elevationContent = document.getElementById('elevation-content');
    const elevationCanvas = document.getElementById('elevation-canvas');
    const elevationTooltip = document.getElementById('elevation-tooltip');
    const poiRefreshButton = document.getElementById('poi-refresh-button');

    // Activer le bouton "Recharger les POI"
    if (poiRefreshButton) {
      poiRefreshButton.addEventListener('click', () => {
        // Réinitialise l'état et recharge les POI pour la vue courante
        poiManager.refreshPending = false;
        hidePoiRefreshButton();
        loadPOIForCurrentView(true);
      });
    }


    let backdropElement = null;

    const waypointLayerGroup = L.layerGroup().addTo(map);
    let waypointCounter = 1;

    let gpxLayerGroup = null;
    let arrowLayerGroup = null;
    let currentGpxDocument = null;
    let currentGpxFileName = '';
    let currentGeojson = null;
    let currentTraceName = '';
    let traceNameSource = '';
    let currentElevationData = null;
    let elevationHoverMarker = null;
    let elevationMouseMoveHandler = null;
    let elevationMouseLeaveHandler = null;

    setExportAvailability(false);
    updateWaypointsList();
    updateTraceInfo(null);

    /**
     * Affiche un message utilisateur discret.
     * @param {string} text
     * @param {boolean} isError
     */
    function showMessage(text, isError = false, isHtml = false) {
      if (!messageBox) {
        return;
      }
      const content = text == null ? '' : String(text);
      const trimmed = content.trim();
      if (!trimmed) {
        messageBox.classList.add('hidden');
        messageBox.textContent = '';
        messageBox.classList.remove('error');
        return;
      }
      if (isHtml) {
        messageBox.innerHTML = content;
      } else {
        messageBox.textContent = trimmed;
      }
      messageBox.classList.remove('hidden');
      messageBox.classList.toggle('error', Boolean(isError));
    }

    /**
     * Efface les couches GPX précédemment ajoutées.
     */
    function clearPreviousLayers() {
      if (gpxLayerGroup) {
        map.removeLayer(gpxLayerGroup);
        gpxLayerGroup = null;
      }
      if (arrowLayerGroup) {
        map.removeLayer(arrowLayerGroup);
        arrowLayerGroup = null;
      }
      waypointLayerGroup.clearLayers();
      waypointCounter = 1;
      currentGeojson = null;
      updateWaypointsList();
      updateTraceInfo(null);
      resetElevationDisplay();
    }

    function setExportAvailability(isEnabled) {
      if (!exportButton) {
        return;
      }
      exportButton.disabled = !isEnabled;
      if (!isEnabled) {
        if (gpxNameInput) {
          gpxNameInput.value = '';
        }
        if (fileInfo) {
          fileInfo.style.display = 'none';
        }
        if (currentFilename) {
          currentFilename.textContent = '—';
        }
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '—';
        }
        resetElevationDisplay();
      } else if (fileInfo) {
        fileInfo.style.display = 'block';
        if (traceFileNameLabel && currentGpxFileName) {
          traceFileNameLabel.textContent = currentGpxFileName;
        }
      }
    }

    function normalizeLatLngSegments(latlngs) {
      if (!Array.isArray(latlngs)) {
        return [];
      }
      if (latlngs.length === 0) {
        return [];
      }
      const first = latlngs[0];
      if (Array.isArray(first)) {
        return latlngs;
      }
      return [latlngs];
    }

    function computeBearingDegrees(startLatLng, endLatLng) {
      const toRadians = (value) => (value * Math.PI) / 180;
      const toDegrees = (value) => (value * 180) / Math.PI;
      const phi1 = toRadians(startLatLng.lat);
      const phi2 = toRadians(endLatLng.lat);
      const deltaLambda = toRadians(endLatLng.lng - startLatLng.lng);
      const y = Math.sin(deltaLambda) * Math.cos(phi2);
      const x =
        Math.cos(phi1) * Math.sin(phi2) -
        Math.sin(phi1) * Math.cos(phi2) * Math.cos(deltaLambda);
      const theta = Math.atan2(y, x);
      return (toDegrees(theta) + 360) % 360;
    }

    function escapeHtml(value) {
      if (value === null || value === undefined) {
        return '';
      }
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function sanitizeFileName(name) {
      if (!name) {
        return 'trace';
      }
      const sanitized =
        name
          .replace(/[<>:"/\\|?*]/g, '_')
          .replace(/\s+/g, '_')
          .replace(/_+/g, '_')
          .replace(/^_|_$/g, '')
          .substring(0, 100) || 'trace';
      return sanitized;
    }

    function extractTraceName(xmlDoc, fileName) {
      if (xmlDoc) {
        const trackNames = xmlDoc.querySelectorAll('trk > name');
        for (const trackName of trackNames) {
          const value = trackName.textContent && trackName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-track' };
          }
        }

        const routeNames = xmlDoc.querySelectorAll('rte > name');
        for (const routeName of routeNames) {
          const value = routeName.textContent && routeName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-route' };
          }
        }

        const metadataName = xmlDoc.querySelector('metadata > name');
        if (metadataName) {
          const value = metadataName.textContent && metadataName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-metadata' };
          }
        }
      }

      if (fileName) {
        const withoutExtension = fileName.replace(/\.gpx$/i, '');
        if (withoutExtension.trim()) {
          return { name: withoutExtension.trim(), source: 'filename' };
        }
      }

      return { name: 'Trace sans nom', source: 'default' };
    }

    function displayTraceName(traceName, source) {
      if (!traceNameLabel) {
        return;
      }
      const safeName = traceName || '—';
      traceNameLabel.textContent = safeName;
      let tooltip = '';
      switch (source) {
        case 'gpx-track':
        case 'gpx-route':
        case 'gpx-metadata':
          tooltip = 'Nom extrait du fichier GPX';
          break;
        case 'filename':
          tooltip = 'Nom basé sur le nom de fichier';
          break;
        case 'default':
        default:
          tooltip = 'Nom par défaut (aucune information disponible)';
          break;
      }
      traceNameLabel.setAttribute('title', tooltip);
      traceNameLabel.className = `trace-name trace-name--${source || 'default'}`;
    }

    function haversineDistance(pointA, pointB) {
      if (!pointA || !pointB) {
        return 0;
      }
      const R = 6371000;
      const lat1 = (pointA.lat * Math.PI) / 180;
      const lat2 = (pointB.lat * Math.PI) / 180;
      const dLat = ((pointB.lat - pointA.lat) * Math.PI) / 180;
      const dLng = ((pointB.lng - pointA.lng) * Math.PI) / 180;

      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function calculateElevationStats(points) {
      if (!Array.isArray(points) || points.length === 0) {
        return null;
      }

      let elevationGain = 0;
      let elevationLoss = 0;
      let minElevation = Infinity;
      let maxElevation = -Infinity;
      let sumElevation = 0;

      points.forEach((point, index) => {
        const elevation = point.elevation;
        if (elevation < minElevation) {
          minElevation = elevation;
        }
        if (elevation > maxElevation) {
          maxElevation = elevation;
        }
        sumElevation += elevation;

        if (index > 0) {
          const diff = elevation - points[index - 1].elevation;
          if (diff > 0) {
            elevationGain += diff;
          } else if (diff < 0) {
            elevationLoss += Math.abs(diff);
          }
        }
      });

      return {
        totalDistance: Math.round(points[points.length - 1].distance),
        elevationGain: Math.round(elevationGain),
        elevationLoss: Math.round(elevationLoss),
        minElevation: Math.round(minElevation),
        maxElevation: Math.round(maxElevation),
        avgElevation: Math.round(sumElevation / points.length)
      };
    }

    function simplifyElevationData(points, maxPoints = 1500) {
      if (!Array.isArray(points) || points.length <= maxPoints) {
        return points || [];
      }
      const step = Math.max(1, Math.floor(points.length / maxPoints));
      const simplified = [];
      for (let i = 0; i < points.length; i += step) {
        simplified.push(points[i]);
      }
      if (simplified[simplified.length - 1] !== points[points.length - 1]) {
        simplified.push(points[points.length - 1]);
      }
      return simplified;
    }

    function extractElevationData(geojson, gpxDoc) {
      if (!geojson || !Array.isArray(geojson.features) || !gpxDoc) {
        return null;
      }

      const trackPoints = Array.from(gpxDoc.querySelectorAll('trkpt, rtept'));
      const elevationMap = new Map();
      trackPoints.forEach((trkpt) => {
        const lat = parseFloat(trkpt.getAttribute('lat'));
        const lng = parseFloat(trkpt.getAttribute('lon'));
        const eleNode = trkpt.querySelector('ele');
        if (!Number.isFinite(lat) || !Number.isFinite(lng) || !eleNode) {
          return;
        }
        const elevation = parseFloat(eleNode.textContent);
        if (!Number.isFinite(elevation)) {
          return;
        }
        const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
        elevationMap.set(key, elevation);
      });

      if (elevationMap.size === 0) {
        return null;
      }

      const points = [];
      let previousPoint = null;
      let cumulativeDistance = 0;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
          const elevation = elevationMap.get(key);
          if (!Number.isFinite(elevation)) {
            previousPoint = { lat, lng };
            return;
          }

          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }

          points.push({
            distance: cumulativeDistance,
            elevation,
            lat,
            lng,
            index: points.length
          });

          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (points.length < 2) {
        return null;
      }

      const stats = calculateElevationStats(points);
      if (!stats) {
        return null;
      }

      const simplifiedPoints = simplifyElevationData(points);
      return { points: simplifiedPoints, stats };
    }

    function calculateDistanceOnly(geojson) {
      if (!geojson || !Array.isArray(geojson.features)) {
        return null;
      }
      let cumulativeDistance = 0;
      let previousPoint = null;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }
          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (cumulativeDistance === 0) {
        return null;
      }
      return { distance: cumulativeDistance };
    }

    function updateElevationStats(stats) {
      if (
        !traceDistanceLabel ||
        !traceElevationGainLabel ||
        !traceElevationLossLabel ||
        !traceAltitudeRangeLabel ||
        !profileDistanceValue ||
        !profileElevationGainValue ||
        !profileElevationLossValue
      ) {
        return;
      }

      if (!stats) {
        traceDistanceLabel.textContent = '—';
        traceElevationGainLabel.textContent = '—';
        traceElevationLossLabel.textContent = '—';
        traceAltitudeRangeLabel.textContent = '—';
        profileDistanceValue.textContent = '—';
        profileElevationGainValue.textContent = '—';
        profileElevationLossValue.textContent = '—';
        if (ariaDistance) ariaDistance.textContent = '—';
        if (ariaDPlus) ariaDPlus.textContent = '—';
        if (ariaMin) ariaMin.textContent = '—';
        if (ariaMax) ariaMax.textContent = '—';
        if (elevationProfile) {
          elevationProfile.classList.remove('visible');
          elevationProfile.setAttribute('aria-hidden', 'true');
        }
        return;
      }

      const distanceKm = stats.totalDistance / 1000;
      traceDistanceLabel.textContent = `${distanceKm.toFixed(2)} km`;
      traceElevationGainLabel.textContent = `${stats.elevationGain} m`;
      traceElevationLossLabel.textContent = `${stats.elevationLoss} m`;
      traceAltitudeRangeLabel.textContent = `${stats.minElevation} m - ${stats.maxElevation} m`;

      profileDistanceValue.textContent = `${distanceKm.toFixed(2)} km`;
      profileElevationGainValue.textContent = `${stats.elevationGain} m`;
      profileElevationLossValue.textContent = `${stats.elevationLoss} m`;

      if (ariaDistance) ariaDistance.textContent = `${distanceKm.toFixed(2)} km`;
      if (ariaDPlus) ariaDPlus.textContent = `${stats.elevationGain} m`;
      if (ariaMin) ariaMin.textContent = `${stats.minElevation} m`;
      if (ariaMax) ariaMax.textContent = `${stats.maxElevation} m`;

      if (elevationProfile) {
        elevationProfile.classList.add('visible');
        elevationProfile.setAttribute('aria-hidden', 'false');
      }
    }

    function resetElevationDisplay() {
      currentElevationData = null;
      if (elevationHoverMarker) {
        map.removeLayer(elevationHoverMarker);
        elevationHoverMarker = null;
      }
      removeElevationInteraction();
      updateElevationStats(null);
      if (elevationTooltip) {
        elevationTooltip.style.display = 'none';
      }
      if (elevationContent && elevationCanvas) {
        const ctx = elevationCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, elevationCanvas.width, elevationCanvas.height);
        }
      }
      if (elevationProfile) {
        elevationProfile.classList.remove('collapsed');
        elevationProfile.setAttribute('aria-hidden', 'true');
      }
      if (elevationCollapseButton) {
        elevationCollapseButton.setAttribute('aria-expanded', 'true');
        elevationCollapseButton.setAttribute('aria-label', 'Réduire le profil');
      }
      map.invalidateSize();
    }

    function drawElevationProfile(canvas, points, stats) {
      if (!canvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return;
      }

      const width = canvas.width;
      const height = canvas.height;

      ctx.clearRect(0, 0, width, height);

      const margin = { top: 20, right: 20, bottom: 40, left: 60 };
      const chartWidth = Math.max(10, width - margin.left - margin.right);
      const chartHeight = Math.max(10, height - margin.top - margin.bottom);
      const maxDistance = stats.totalDistance || 1;
      const minEle = stats.minElevation - 20;
      const maxEle = stats.maxElevation + 20;

      const xScale = (distance) =>
        margin.left + (Math.min(distance, maxDistance) / maxDistance) * chartWidth;
      const yScale = (elevation) =>
        margin.top + chartHeight - ((elevation - minEle) / (maxEle - minEle)) * chartHeight;

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.lineWidth = 1;

      const elevationStep = Math.max(10, Math.ceil((maxEle - minEle) / 5 / 50) * 50);
      for (let ele = Math.ceil(minEle / elevationStep) * elevationStep; ele <= maxEle; ele += elevationStep) {
        const y = yScale(ele);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(width - margin.right, y);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(`${Math.round(ele)} m`, margin.left - 5, y + 4);
      }

      const distanceStepRaw = Math.max(100, Math.ceil(maxDistance / 5 / 1000) * 1000);
      for (let dist = 0; dist <= maxDistance; dist += distanceStepRaw) {
        const x = xScale(dist);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, height - margin.bottom);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${(dist / 1000).toFixed(1)} km`, x, height - margin.bottom + 18);
      }

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.lineTo(xScale(points[points.length - 1].distance), height - margin.bottom);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, margin.top, 0, height - margin.bottom);
      gradient.addColorStop(0, 'rgba(25, 118, 210, 0.3)');
      gradient.addColorStop(1, 'rgba(25, 118, 210, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.strokeStyle = '#1976d2';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#424242';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Distance (km)', width / 2, height - 8);

      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Altitude (m)', 0, 0);
      ctx.restore();
    }

    function renderElevationProfile() {
      if (
        !currentElevationData ||
        !currentElevationData.points ||
        !currentElevationData.stats ||
        !elevationCanvas ||
        !elevationProfile
      ) {
        return;
      }
      if (
        elevationProfile.classList.contains('collapsed') ||
        !elevationProfile.classList.contains('visible')
      ) {
        return;
      }
      drawElevationProfile(elevationCanvas, currentElevationData.points, currentElevationData.stats);
      setupElevationInteraction(currentElevationData.points, currentElevationData.stats);
    }

    function findClosestElevationPoint(canvas, points, stats, event) {
      if (!canvas || !points || !stats) {
        return null;
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const margin = { left: 60, right: 20 };
      const chartWidth = canvas.width - margin.left - margin.right;
      const relativeX = x - margin.left;
      if (relativeX < 0 || relativeX > chartWidth) {
        return null;
      }
      const distance = (relativeX / chartWidth) * stats.totalDistance;
      let closestPoint = points[0];
      let minDiff = Math.abs(points[0].distance - distance);
      for (let i = 1; i < points.length; i++) {
        const diff = Math.abs(points[i].distance - distance);
        if (diff < minDiff) {
          minDiff = diff;
          closestPoint = points[i];
        }
      }
      return { point: closestPoint, canvasX: x };
    }

    function removeElevationInteraction() {
      if (!elevationCanvas) {
        return;
      }
      if (elevationMouseMoveHandler) {
        elevationCanvas.removeEventListener('mousemove', elevationMouseMoveHandler);
      }
      if (elevationMouseLeaveHandler) {
        elevationCanvas.removeEventListener('mouseleave', elevationMouseLeaveHandler);
      }
      elevationMouseMoveHandler = null;
      elevationMouseLeaveHandler = null;
    }

    function setupElevationInteraction(points, stats) {
      if (!elevationCanvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      removeElevationInteraction();

      elevationMouseMoveHandler = (event) => {
        const result = findClosestElevationPoint(elevationCanvas, points, stats, event);
        if (!result) {
          if (elevationTooltip) {
            elevationTooltip.style.display = 'none';
          }
          if (elevationHoverMarker) {
            map.removeLayer(elevationHoverMarker);
            elevationHoverMarker = null;
          }
          return;
        }

        const { point, canvasX } = result;
        if (elevationTooltip) {
          const rect = elevationCanvas.getBoundingClientRect();
          elevationTooltip.style.display = 'block';
          elevationTooltip.style.left = `${canvasX + 15}px`;
          elevationTooltip.style.top = `${event.clientY - rect.top + 15}px`;
          const distanceElement = document.getElementById('tooltip-distance');
          const elevationElement = document.getElementById('tooltip-elevation');
          if (distanceElement) {
            distanceElement.textContent = `${(point.distance / 1000).toFixed(2)} km`;
          }
          if (elevationElement) {
            elevationElement.textContent = `${point.elevation.toFixed(0)} m`;
          }
        }

        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
        }
        elevationHoverMarker = L.circleMarker([point.lat, point.lng], {
          radius: 7,
          fillColor: '#ff5722',
          fillOpacity: 0.9,
          color: '#ffffff',
          weight: 2,
          interactive: false
        }).addTo(map);
      };

      elevationMouseLeaveHandler = () => {
        if (elevationTooltip) {
          elevationTooltip.style.display = 'none';
        }
        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
          elevationHoverMarker = null;
        }
      };

      elevationCanvas.addEventListener('mousemove', elevationMouseMoveHandler);
      elevationCanvas.addEventListener('mouseleave', elevationMouseLeaveHandler);
    }

    function setElevationCollapsed(collapsed) {
      if (!elevationProfile || !elevationCollapseButton) {
        return;
      }
      if (!elevationProfile.classList.contains('visible') && !collapsed) {
        return;
      }

      elevationProfile.classList.toggle('collapsed', collapsed);
      elevationCollapseButton.setAttribute('aria-expanded', String(!collapsed));
      elevationCollapseButton.setAttribute(
        'aria-label',
        collapsed ? 'Agrandir le profil' : 'Réduire le profil'
      );

      if (!collapsed) {
        requestAnimationFrame(() => {
          renderElevationProfile();
          map.invalidateSize();
        });
      } else {
        removeElevationInteraction();
        map.invalidateSize();
      }
    }

    function createWaypointPopupHtml(name) {
      const safeName = escapeHtml(name);
      return `
        <div class="waypoint-popup">
          <label for="waypoint-name-input">Nom du waypoint</label>
          <input id="waypoint-name-input" class="waypoint-name-input" type="text" value="${safeName}" />
          <div class="waypoint-popup-buttons">
            <button type="button" data-action="save">Enregistrer</button>
            <button type="button" data-action="delete">Supprimer</button>
          </div>
        </div>
      `;
    }

    function attachWaypointPopupHandlers(marker, popup) {
      const container = popup.getElement();
      if (!container) {
        return;
      }

      const input = container.querySelector('.waypoint-name-input');
      if (input) {
        input.value = marker.waypointName;
        input.focus();
        input.select();
      }

      const saveAction = () => {
        const newName = input && input.value.trim() ? input.value.trim() : marker.waypointName;
        marker.waypointName = newName;
        marker.setPopupContent(createWaypointPopupHtml(marker.waypointName));
        marker.openPopup();
        updateWaypointsList();
      };

      const deleteAction = () => {
        waypointLayerGroup.removeLayer(marker);
        map.closePopup(popup);
        updateWaypointsList();
      };

      if (input) {
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveAction();
          }
        });
      }

      const saveButton = container.querySelector('[data-action="save"]');
      if (saveButton) {
        saveButton.addEventListener('click', saveAction);
      }

      const deleteButton = container.querySelector('[data-action="delete"]');
      if (deleteButton) {
        deleteButton.addEventListener('click', deleteAction);
      }
    }

    function createWaypointMarker(latlng, name = '') {
      const trimmedName = name && name.trim() ? name.trim() : '';
      const finalName = trimmedName || `Waypoint ${waypointCounter}`;
      waypointCounter += 1;

      const marker = L.marker(latlng, { draggable: false, bubblingMouseEvents: false });
      marker.waypointName = finalName;
      marker.bindPopup(createWaypointPopupHtml(finalName));
      marker.on('popupopen', (event) => {
        attachWaypointPopupHandlers(marker, event.popup);
      });
      marker.bindTooltip(
        () => marker.waypointName,
        {
          direction: 'top',
          offset: [0, -12]
        }
      );

      waypointLayerGroup.addLayer(marker);
      updateWaypointsList();
      return marker;
    }

    function addWaypointsFromFeatures(features) {
      if (!Array.isArray(features)) {
        return;
      }
      features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const properties = feature.properties || {};
        const baseName = properties.name || properties.description || '';

        if (feature.geometry.type === 'Point') {
          const coords = feature.geometry.coordinates;
          if (Array.isArray(coords) && coords.length >= 2) {
            createWaypointMarker(L.latLng(coords[1], coords[0]), baseName);
          }
        } else if (feature.geometry.type === 'MultiPoint') {
          const points = feature.geometry.coordinates || [];
          points.forEach((coords, index) => {
            if (Array.isArray(coords) && coords.length >= 2) {
              const name = baseName ? `${baseName} (${index + 1})` : '';
              createWaypointMarker(L.latLng(coords[1], coords[0]), name);
            }
          });
        }
      });
    }

    function handleAddWaypointFromTrack(latlng) {
      const suggestedName = `Waypoint ${waypointCounter}`;
      const userInput = prompt('Nom du waypoint ?', suggestedName);
      if (userInput === null) {
        return;
      }
      const finalName = userInput.trim() ? userInput.trim() : suggestedName;
      const marker = createWaypointMarker(latlng, finalName);
      marker.openPopup();
    }

    function getWaypointMarkers() {
      const markers = [];
      waypointLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          markers.push(layer);
        } else if (layer && typeof layer.getLayers === 'function') {
          layer.getLayers().forEach((child) => {
            if (child instanceof L.Marker) {
              markers.push(child);
            }
          });
        }
      });
      return markers;
    }

    function updateWaypointsList() {
      if (!waypointsList || !waypointCountLabel || !waypointsSection) {
        return;
      }

      const markers = getWaypointMarkers();
      waypointCountLabel.textContent = markers.length;
      waypointsSection.style.display = markers.length > 0 ? 'block' : 'none';
      waypointsList.innerHTML = '';

      markers.forEach((marker) => {
        const item = document.createElement('div');
        item.className = 'waypoint-item';
        item.innerHTML = `
          <span class="waypoint-icon" aria-hidden="true">📍</span>
          <span class="waypoint-name">${escapeHtml(marker.waypointName)}</span>
          <button class="btn-icon-small" data-action="center" title="Centrer">🎯</button>
          <button class="btn-icon-small" data-action="delete" title="Supprimer">🗑️</button>
        `;

        const centerButton = item.querySelector('[data-action="center"]');
        if (centerButton) {
          centerButton.addEventListener('click', () => {
            const latlng = marker.getLatLng();
            if (latlng) {
              map.setView(latlng, Math.max(map.getZoom(), 16));
              marker.openPopup();
            }
          });
        }

        const deleteButton = item.querySelector('[data-action="delete"]');
        if (deleteButton) {
          deleteButton.addEventListener('click', () => {
            waypointLayerGroup.removeLayer(marker);
            updateWaypointsList();
          });
        }

        waypointsList.appendChild(item);
      });
    }

    function updateTraceInfo(info) {
      if (!traceInfoSection || !traceNameLabel || !pointCountLabel || !traceTypeLabel) {
        return;
      }

      if (!info) {
        traceInfoSection.style.display = 'none';
        displayTraceName('—', 'default');
        pointCountLabel.textContent = '—';
        traceTypeLabel.textContent = '—';
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '—';
        }
        return;
      }

      traceInfoSection.style.display = 'block';
      displayTraceName(currentTraceName || info.name || '—', traceNameSource || 'default');
      pointCountLabel.textContent = Number.isFinite(info.pointCount) ? info.pointCount : '—';
      traceTypeLabel.textContent = info.type || '—';
      if (traceFileNameLabel) {
        traceFileNameLabel.textContent = currentGpxFileName || '—';
      }
    }

    function createArrowIconHtml(bearing) {
      const rotation = ((bearing - 90) + 360) % 360;
      return `<span class="direction-arrow" style="display:inline-block; color:#ff5722; font-size:1rem; line-height:1; text-shadow:0 0 2px rgba(0,0,0,0.5); transform-origin:center; transform: rotate(${rotation}deg);">➤</span>`;
    }

    function createArrowMarker(point, bearing) {
      return L.marker(point, {
        icon: L.divIcon({
          className: '',
          html: createArrowIconHtml(bearing),
          iconSize: [16, 16],
          iconAnchor: [8, 8]
        }),
        interactive: false,
        keyboard: false
      });
    }

    function createArrowMarkers(layer) {
      const arrowMarkers = [];
      const latLngs = normalizeLatLngSegments(layer.getLatLngs());
      const arrowSpacingMeters = 2500;

      latLngs.forEach((segment) => {
        if (!Array.isArray(segment) || segment.length < 2) {
          return;
        }

        let previousPoint = L.latLng(segment[0]);
        let distanceFromLastArrow = 0;
        let totalSegmentDistance = 0;
        const segmentMarkers = [];

        for (let i = 1; i < segment.length; i++) {
          const currentPoint = L.latLng(segment[i]);
          let segmentDistance = map.distance(previousPoint, currentPoint);
          let segmentStart = previousPoint;

          if (segmentDistance === 0) {
            previousPoint = currentPoint;
            continue;
          }

          totalSegmentDistance += segmentDistance;

          while (distanceFromLastArrow + segmentDistance >= arrowSpacingMeters) {
            const distanceNeeded = arrowSpacingMeters - distanceFromLastArrow;
            const ratio = distanceNeeded / segmentDistance;
            const interpolatedLat =
              segmentStart.lat + (currentPoint.lat - segmentStart.lat) * ratio;
            const interpolatedLng =
              segmentStart.lng + (currentPoint.lng - segmentStart.lng) * ratio;
            const arrowPoint = L.latLng(interpolatedLat, interpolatedLng);
            const bearing = computeBearingDegrees(segmentStart, currentPoint);

            const marker = createArrowMarker(arrowPoint, bearing);

            arrowMarkers.push(marker);
            segmentMarkers.push(marker);

            segmentStart = arrowPoint;
            segmentDistance = map.distance(segmentStart, currentPoint);
            if (segmentDistance === 0) {
              break;
            }
            distanceFromLastArrow = 0;
          }

          distanceFromLastArrow += segmentDistance;
          previousPoint = currentPoint;
        }

        if (segmentMarkers.length === 0 && totalSegmentDistance > 0) {
          const targetDistance = totalSegmentDistance / 2;
          let accumulated = 0;
          for (let i = 1; i < segment.length; i++) {
            const start = L.latLng(segment[i - 1]);
            const end = L.latLng(segment[i]);
            const distance = map.distance(start, end);
            if (distance === 0) {
              continue;
            }
            if (accumulated + distance >= targetDistance) {
              const ratio = (targetDistance - accumulated) / distance;
              const lat = start.lat + (end.lat - start.lat) * ratio;
              const lng = start.lng + (end.lng - start.lng) * ratio;
              const point = L.latLng(lat, lng);
              const bearing = computeBearingDegrees(start, end);
              const marker = createArrowMarker(point, bearing);
              arrowMarkers.push(marker);
              segmentMarkers.push(marker);
              break;
            }
            accumulated += distance;
          }
        }
      });

      return arrowMarkers;
    }

    function computeTraceInfo(lineFeatures, geojson) {
      if (!Array.isArray(lineFeatures) || lineFeatures.length === 0) {
        return null;
      }

      const first = lineFeatures[0];
      const properties = first.properties || {};
      const name = properties.name || properties.description || (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : 'Trace');
      let pointCount = 0;
      let type = properties.kind || first.geometry?.type || '—';

      lineFeatures.forEach((feature) => {
        if (!feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        if (geometry.type === 'LineString') {
          pointCount += Array.isArray(geometry.coordinates) ? geometry.coordinates.length : 0;
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            pointCount += Array.isArray(segment) ? segment.length : 0;
          });
        }
        if (!type && geometry.type) {
          type = geometry.type;
        }
        if (!properties.kind && feature.properties && feature.properties.kind) {
          type = feature.properties.kind;
        }
      });

      if (!type && geojson && Array.isArray(geojson.features)) {
        const kinds = geojson.features
          .map((feature) => feature?.properties?.kind)
          .filter(Boolean);
        if (kinds.length > 0) {
          type = kinds[0];
        }
      }

      return {
        name,
        pointCount,
        type: type || '—'
      };
    }

    function displayGeoJSON(geojsonData) {
      clearPreviousLayers();

      currentGeojson = geojsonData;

      const lineFeatures = [];
      const pointFeatures = [];

      if (geojsonData && Array.isArray(geojsonData.features)) {
        geojsonData.features.forEach((feature) => {
          const geometryType = feature && feature.geometry && feature.geometry.type;
          if (geometryType === 'LineString' || geometryType === 'MultiLineString') {
            lineFeatures.push(feature);
          } else if (geometryType === 'Point' || geometryType === 'MultiPoint') {
            pointFeatures.push(feature);
          }
        });
      }

      const linesFeatureCollection = {
        type: 'FeatureCollection',
        features: lineFeatures
      };

      gpxLayerGroup = L.geoJSON(linesFeatureCollection, {
        style: function () {
          return {
            color: '#ff5722',
            weight: 3,
            opacity: 0.9
          };
        }
      }).addTo(map);

      const arrowLayers = [];
      gpxLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
          layer.on('click', (event) => {
            if (event.originalEvent) {
              event.originalEvent.preventDefault();
              event.originalEvent.stopPropagation();
            }
            handleAddWaypointFromTrack(event.latlng);
          });

          if (
            typeof L.polylineDecorator === 'function' &&
            L.Symbol &&
            typeof L.Symbol.arrowHead === 'function'
          ) {
            const decorator = L.polylineDecorator(layer, {
              patterns: [
                {
                  offset: '5%',
                  repeat: '50%',
                  symbol: L.Symbol.arrowHead({
                    pixelSize: 10,
                    headAngle: 60,
                    polygon: false,
                    pathOptions: {
                      stroke: true,
                      color: '#ff5722',
                      weight: 2,
                      opacity: 0.9
                    }
                  })
                }
              ]
            });
            arrowLayers.push(decorator);
          } else {
            const markers = createArrowMarkers(layer);
            if (markers.length > 0) {
              arrowLayers.push(L.layerGroup(markers));
            }
          }
        }
      });

      if (arrowLayers.length > 0) {
        arrowLayerGroup = L.layerGroup(arrowLayers).addTo(map);
      }

      if (pointFeatures.length > 0) {
        addWaypointsFromFeatures(pointFeatures);
      } else {
        updateWaypointsList();
      }

      let bounds = null;
      if (gpxLayerGroup.getLayers().length > 0) {
        bounds = gpxLayerGroup.getBounds();
      }
      waypointLayerGroup.eachLayer((layer) => {
        if (typeof layer.getLatLng !== 'function') {
          return;
        }
        const latlng = layer.getLatLng();
        if (!latlng) {
          return;
        }
        if (!bounds) {
          bounds = L.latLngBounds(latlng, latlng);
        } else {
          bounds.extend(latlng);
        }
      });

      if (bounds && typeof bounds.isValid === 'function' && bounds.isValid()) {
        map.fitBounds(bounds.pad(0.1));
      }

      updateTraceInfo(computeTraceInfo(lineFeatures, geojsonData));
      currentGeojson = geojsonData;
    }

    /**
     * Traite le fichier GPX sélectionné.
     * @param {File} file
     */
    async function handleFile(file) {
      if (!file) {
        return;
      }

      setExportAvailability(false);
      currentGpxDocument = null;
      currentGpxFileName = '';
      currentTraceName = '';
      traceNameSource = '';
      displayTraceName('—', 'default');
      updateTraceInfo(null);

      if (gpxNameInput) {
        gpxNameInput.value = file && file.name ? file.name.replace(/\.gpx$/i, '') : '';
      }

      if (!file.name.toLowerCase().endsWith('.gpx')) {
        showMessage('Veuillez sélectionner un fichier .gpx.', true);
        return;
      }

      const reader = new FileReader();

      reader.onload = async function (event) {
        try {
          showMessage('Chargement de la trace GPX…');
          const parser = new DOMParser();
          const xml = parser.parseFromString(event.target.result, 'application/xml');
          const parseError = xml.querySelector('parsererror');
          if (parseError) {
            throw new Error('Fichier GPX invalide.');
          }

          currentGpxDocument = xml;
          currentGpxFileName = file.name;
          if (currentFilename) {
            currentFilename.textContent = file.name;
          }
          if (traceFileNameLabel) {
            traceFileNameLabel.textContent = file.name;
          }

          const extractedTrace = extractTraceName(xml, file.name);
          currentTraceName = extractedTrace.name;
          traceNameSource = extractedTrace.source;
          if (gpxNameInput) {
            gpxNameInput.value = currentTraceName;
          }
          displayTraceName(currentTraceName, traceNameSource);

          const geojson = convertGpxToGeoJSON(xml);

          if (!geojson || !geojson.features || geojson.features.length === 0) {
            throw new Error('La trace GPX est vide ou invalide.');
          }

          setExportAvailability(true);
          displayGeoJSON(geojson);

          currentElevationData = extractElevationData(geojson, xml);
          let noElevationData = false;
          if (currentElevationData) {
            updateElevationStats(currentElevationData.stats);
            setElevationCollapsed(false);
            requestAnimationFrame(() => renderElevationProfile());
          } else {
            updateElevationStats(null);
            const distanceOnly = calculateDistanceOnly(geojson);
            if (distanceOnly && traceDistanceLabel) {
              traceDistanceLabel.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
              if (profileDistanceValue) {
                profileDistanceValue.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
              }
              if (ariaDistance) {
                ariaDistance.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
              }
            }
            if (traceElevationGainLabel) {
              traceElevationGainLabel.textContent = 'N/A';
            }
            if (traceElevationLossLabel) {
              traceElevationLossLabel.textContent = 'N/A';
            }
            if (traceAltitudeRangeLabel) {
              traceAltitudeRangeLabel.textContent = 'N/A';
            }
            if (profileElevationGainValue) {
              profileElevationGainValue.textContent = 'N/A';
            }
            if (profileElevationLossValue) {
              profileElevationLossValue.textContent = 'N/A';
            }
            if (ariaDPlus) {
              ariaDPlus.textContent = 'N/A';
            }
            if (ariaMin) {
              ariaMin.textContent = 'N/A';
            }
            if (ariaMax) {
              ariaMax.textContent = 'N/A';
            }
            if (elevationProfile) {
              elevationProfile.setAttribute('aria-hidden', 'true');
            }
            noElevationData = true;
          }

          let successMessage = '';
          switch (traceNameSource) {
            case 'gpx-track':
            case 'gpx-route':
            case 'gpx-metadata':
              successMessage = `Trace "<strong>${escapeHtml(currentTraceName)}</strong>" chargée avec succès.`;
              break;
            case 'filename':
              successMessage = `Fichier "<strong>${escapeHtml(currentTraceName)}</strong>" chargé (aucun nom dans le GPX).`;
              break;
            case 'default':
            default:
              successMessage = 'Trace chargée (aucun nom disponible).';
              break;
          }
          if (noElevationData) {
            successMessage += '<br><small>Cette trace ne contient pas de données d\'élévation.</small>';
          }
          showMessage(successMessage, false, true);
        } catch (error) {
          console.error(error);
          showMessage(error.message || 'Impossible de lire ce fichier GPX.', true);
          clearPreviousLayers();
          currentGpxDocument = null;
          currentGpxFileName = '';
          currentTraceName = '';
          traceNameSource = '';
          displayTraceName('—', 'default');
          setExportAvailability(false);
        }
      };

      reader.onerror = function () {
        showMessage('Erreur de lecture du fichier.', true);
        currentGpxDocument = null;
        currentGpxFileName = '';
        currentTraceName = '';
        traceNameSource = '';
        displayTraceName('—', 'default');
        setExportAvailability(false);
      };

      reader.readAsText(file);
    }

    function exportUpdatedGpx() {
      if (!currentGpxDocument) {
        showMessage('Aucune trace GPX à exporter.', true);
        return;
      }

      const xmlDoc = currentGpxDocument.cloneNode(true);
      const gpxRoot = xmlDoc && xmlDoc.documentElement ? xmlDoc.documentElement : null;

      if (!gpxRoot) {
        showMessage('Impossible de préparer le fichier GPX.', true);
        return;
      }

      const existingWaypoints = xmlDoc.querySelectorAll('wpt');
      existingWaypoints.forEach((node) => {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });

      const markers = getWaypointMarkers();
      markers.forEach((marker) => {
        if (typeof marker.getLatLng !== 'function') {
          return;
        }
        const latlng = marker.getLatLng();
        if (!latlng) {
          return;
        }

        const wptNode = xmlDoc.createElement('wpt');
        wptNode.setAttribute('lat', latlng.lat.toFixed(6));
        wptNode.setAttribute('lon', latlng.lng.toFixed(6));

        if (marker.waypointName) {
          const nameNode = xmlDoc.createElement('name');
          nameNode.textContent = marker.waypointName;
          wptNode.appendChild(nameNode);
        }

        gpxRoot.appendChild(wptNode);
      });

      const serializer = new XMLSerializer();
      let gpxString = serializer.serializeToString(xmlDoc);
      if (!gpxString.startsWith('<?xml')) {
        gpxString = `<?xml version="1.0" encoding="UTF-8"?>\n${gpxString}`;
      }

      const blob = new Blob([gpxString], { type: 'application/gpx+xml' });
      const url = URL.createObjectURL(blob);

      const explicitName = gpxNameInput && gpxNameInput.value.trim() ? gpxNameInput.value.trim() : '';
      const baseName =
        explicitName ||
        currentTraceName ||
        (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : '') ||
        'trace';
      const sanitizedName = sanitizeFileName(baseName);
      const downloadName = `${sanitizedName}_with_waypoints.gpx`;

      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = downloadName;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);

      setTimeout(() => {
        URL.revokeObjectURL(url);
      }, 0);

      showMessage(`Fichier "${downloadName}" exporté.`);
    }

    function togglePanel(open) {
      if (!toolsPanel) {
        return;
      }
      const shouldOpen = open !== undefined ? open : !toolsPanel.classList.contains('open');
      if (shouldOpen) {
        toolsPanel.classList.add('open');
        menuToggle?.setAttribute('aria-expanded', 'true');
        if (!backdropElement) {
          backdropElement = document.createElement('div');
          backdropElement.className = 'panel-backdrop';
          backdropElement.addEventListener('click', () => {
            togglePanel(false);
          });
          document.body.appendChild(backdropElement);
        }
      } else {
        toolsPanel.classList.remove('open');
        menuToggle?.setAttribute('aria-expanded', 'false');
        if (backdropElement) {
          backdropElement.remove();
          backdropElement = null;
        }
      }
      map.invalidateSize();
    }

    initPOIManager();

    // Gestion du clic sur le bouton pour ouvrir le sélecteur de fichier
    importButton.addEventListener('click', () => fileInput.click());

    if (exportButton) {
      exportButton.addEventListener('click', exportUpdatedGpx);
    }

    if (menuToggle) {
      menuToggle.addEventListener('click', () => togglePanel(true));
    }

    if (closePanel) {
      closePanel.addEventListener('click', () => togglePanel(false));
    }

    if (elevationHeader && elevationProfile) {
      elevationHeader.addEventListener('click', (event) => {
        if (event.target === elevationCollapseButton) {
          return;
        }
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    if (elevationCollapseButton && elevationProfile) {
      elevationCollapseButton.addEventListener('click', (event) => {
        event.stopPropagation();
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    // Gestion du changement de fichier via le sélecteur
    fileInput.addEventListener('change', (event) => {
      const selectedFile = event.target.files && event.target.files[0];
      handleFile(selectedFile);
      fileInput.value = '';
    });

    if (clearWaypointsButton) {
      clearWaypointsButton.addEventListener('click', () => {
        waypointLayerGroup.clearLayers();
        updateWaypointsList();
      });
    }

    function handleDragEnter(zone, event) {
      event.preventDefault();
      event.stopPropagation();
      zone.classList.add('dragover');
    }

    function handleDragLeave(zone, event) {
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
    }

    function handleDrop(zone, event) {
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
      const files = event.dataTransfer && event.dataTransfer.files;
      if (files && files.length > 0) {
        handleFile(files[0]);
      }
    }

    if (panelDropZone) {
      ['dragenter', 'dragover'].forEach((eventName) => {
        panelDropZone.addEventListener(eventName, (event) => handleDragEnter(panelDropZone, event));
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        panelDropZone.addEventListener(eventName, (event) => {
          if (eventName === 'drop') {
            handleDrop(panelDropZone, event);
          } else {
            handleDragLeave(panelDropZone, event);
          }
        });
      });
    }

    // Gestion du drag & drop sur la carte
    const mapContainer = document.querySelector('#map');
    if (mapContainer) {
      ['dragenter', 'dragover'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
        });
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (eventName === 'drop') {
            const droppedFiles = event.dataTransfer && event.dataTransfer.files;
            if (droppedFiles && droppedFiles.length > 0) {
              handleFile(droppedFiles[0]);
            }
          }
        });
      });
    }

    // Empêche le navigateur d'ouvrir le fichier en dehors de la zone prévue
    document.addEventListener('dragover', (event) => {
      event.preventDefault();
    });
    document.addEventListener('drop', (event) => {
      event.preventDefault();
    });

    // S'assure que la carte s'ajuste lors des changements de taille de fenêtre
    window.addEventListener('resize', () => {
      map.invalidateSize();
      requestAnimationFrame(() => renderElevationProfile());
    });

    // Fermer le panneau avec la touche Échap sur mobile
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        togglePanel(false);
      }
    });
  </script>
</body>
</html>
