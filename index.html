<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lecteur GPX - Carte OpenStreetMap</title>
  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    :root {
      --color-primary: #1976d2;
      --color-primary-hover: #1565c0;
      --color-secondary: #f5f5f5;
      --color-secondary-hover: #eeeeee;
      --color-danger: #f44336;
      --color-background: #ffffff;
      --color-background-alt: #f8f9fa;
      --color-text-primary: #212121;
      --color-text-secondary: #424242;
      --color-text-muted: #757575;
      --color-border: #e0e0e0;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--color-background-alt);
      color: var(--color-text-primary);
    }

    body {
      overflow: hidden;
    }

    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .hidden {
      display: none !important;
    }

    .tools-panel {
      width: 320px;
      min-width: 320px;
      height: 100vh;
      background: var(--color-background);
      border-right: 1px solid var(--color-border);
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .panel-header {
      padding: 1.5rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .panel-title {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem 1.5rem;
    }

    .panel-section {
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid var(--color-border);
    }

    .panel-section:last-child {
      border-bottom: none;
      padding-bottom: 0;
      margin-bottom: 0;
    }

    /* Calques OSM */
    .layer-toggle {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .toggle-label {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
      user-select: none;
    }

    .toggle-input {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      background: #ccc;
      border-radius: 12px;
      transition: background 0.3s ease;
      flex-shrink: 0;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      top: 3px;
      left: 3px;
      transition: transform 0.3s ease;
    }

    .toggle-input:checked + .toggle-switch {
      background: var(--color-primary);
    }

    .toggle-input:checked + .toggle-switch::after {
      transform: translateX(20px);
    }

    .toggle-input:focus + .toggle-switch {
      outline: 2px solid var(--color-primary);
      outline-offset: 2px;
    }

    .toggle-text {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--color-text-primary);
      flex: 1;
    }

    .toggle-icon {
      font-size: 1.1rem;
    }

    .toggle-count {
      font-size: 0.85rem;
      color: var(--color-text-muted);
      font-weight: 600;
    }

    .toggle-help {
      margin: 0;
      font-size: 0.85rem;
      color: var(--color-text-muted);
      padding-left: 3.5rem;
    }

    .layer-loading,
    .layer-error,
    .layer-info {
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }

    .layer-loading {
      background: #e3f2fd;
      color: #1976d2;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .layer-error {
      background: #ffebee;
      color: #c62828;
      border: 1px solid rgba(198, 40, 40, 0.2);
    }

    .layer-info {
      background: #fff8e1;
      color: #f57f17;
      border: 1px solid rgba(245, 127, 23, 0.2);
    }

    .layer-loading .loading-spinner {
      display: inline-block;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .section-title {
      margin: 0 0 1rem 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 1.75rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: var(--color-primary);
      color: #fff;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      width: 100%;
      border: none;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      transition: box-shadow 0.2s ease, transform 0.1s ease;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    .btn-primary {
      background: var(--color-primary);
      color: #ffffff;
    }

    .btn-primary:not(:disabled):hover,
    .btn-primary:not(:disabled):focus {
      background: var(--color-primary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-secondary {
      background: var(--color-secondary);
      color: var(--color-text-secondary);
    }

    .btn-secondary:hover,
    .btn-secondary:focus {
      background: var(--color-secondary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-small {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
    }

    .btn-icon-small {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 1rem;
      padding: 0.25rem;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .btn-icon-small:hover,
    .btn-icon-small:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .import-actions {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .file-info {
      margin-top: 1rem;
      padding: 0.75rem;
      border-radius: 6px;
      background: var(--color-background-alt);
      border: 1px solid var(--color-border);
    }

    .file-info small {
      display: block;
      color: var(--color-text-muted);
      margin-bottom: 0.25rem;
    }

    .filename {
      margin: 0;
      font-weight: 600;
      color: var(--color-text-primary);
      word-break: break-all;
    }

    .file-name-input {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
      margin-top: 0.75rem;
    }

    .drop-zone {
      margin-top: 1rem;
      padding: 1rem;
      border: 2px dashed var(--color-border);
      border-radius: 8px;
      text-align: center;
      color: var(--color-text-muted);
      background: #fff;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .drop-zone.dragover {
      border-color: var(--color-primary);
      background: rgba(25, 118, 210, 0.08);
      color: var(--color-text-primary);
    }

    .waypoints-list {
      max-height: 240px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .waypoint-item {
      display: grid;
      grid-template-columns: auto 1fr auto auto;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.6rem;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: #fff;
      box-shadow: var(--shadow-sm);
    }

    .waypoint-popup {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 200px;
    }

    .waypoint-popup label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .waypoint-popup input {
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
    }

    .waypoint-popup-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .waypoint-popup-buttons button {
      flex: 1;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: var(--color-secondary);
    }

    .waypoint-popup-buttons button[data-action="save"] {
      background: var(--color-primary);
      color: #fff;
    }

    .waypoint-popup-buttons button[data-action="delete"] {
      background: var(--color-danger);
      color: #fff;
    }

    .waypoint-name {
      font-size: 0.95rem;
      color: var(--color-text-primary);
    }

    .waypoint-icon {
      font-size: 1.1rem;
    }

    .info-list {
      margin: 0;
      display: grid;
      grid-template-columns: auto 1fr;
      row-gap: 0.75rem;
      column-gap: 1rem;
      font-size: 0.95rem;
    }

    .info-list dt {
      font-weight: 600;
      color: var(--color-text-secondary);
    }

    .info-list dd {
      margin: 0;
      color: var(--color-text-primary);
    }

    .text-muted {
      color: var(--color-text-muted);
    }

    .trace-name {
      font-weight: 600;
      font-size: 1rem;
      word-break: break-word;
    }

    .trace-name--gpx-track,
    .trace-name--gpx-route,
    .trace-name--gpx-metadata {
      color: var(--color-primary);
    }

    .trace-name--filename {
      color: var(--color-text-muted);
      font-style: italic;
    }

    .trace-name--default {
      color: #9e9e9e;
      font-style: italic;
    }

    .file-name {
      font-family: "Courier New", Courier, monospace;
      font-size: 0.9rem;
      color: var(--color-text-muted);
      word-break: break-all;
    }

    .trace-name-help {
      font-size: 1rem;
      cursor: help;
      color: var(--color-text-muted);
      display: inline-block;
      margin-left: 0.35rem;
    }

    .stat-highlight {
      font-weight: 600;
      color: var(--color-primary);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .elevation-profile {
      position: relative;
      width: 100%;
      background: var(--color-background);
      border-top: 2px solid var(--color-primary);
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
      display: none;
      flex-direction: column;
      z-index: 500;
      transition: height 0.3s ease;
      height: 200px;
    }

    .elevation-profile.visible {
      display: flex;
    }

    .elevation-profile.collapsed {
      height: 40px;
    }

    .elevation-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.75rem 1rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      cursor: pointer;
      user-select: none;
      min-height: 40px;
    }

    .elevation-header:hover {
      background: rgba(0, 0, 0, 0.02);
    }

    .elevation-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .elevation-title h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .elevation-icon {
      font-size: 1.25rem;
    }

    .elevation-stats-quick {
      display: flex;
      gap: 1.5rem;
      flex: 1;
      justify-content: center;
    }

    .stat-item {
      display: flex;
      gap: 0.25rem;
      font-size: 0.9rem;
    }

    .stat-label {
      color: var(--color-text-muted);
    }

    .stat-value {
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .btn-collapse {
      border: none;
      background: transparent;
      font-size: 1rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .btn-collapse:hover,
    .btn-collapse:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .elevation-profile.collapsed .btn-collapse span {
      transform: rotate(180deg);
      display: inline-block;
    }

    .elevation-content {
      flex: 1;
      position: relative;
      overflow: hidden;
      padding: 1rem;
      display: none;
    }

    .elevation-profile:not(.collapsed) .elevation-content {
      display: block;
    }

    #elevation-canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .elevation-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .tooltip-row {
      display: flex;
      gap: 0.5rem;
      white-space: nowrap;
    }

    /* Marqueurs POI OSM */
    .poi-marker {
      border: none !important;
      background: transparent !important;
    }

    .poi-marker-inner {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      border: 2px solid #fff;
      transition: transform 0.2s ease;
    }

    .poi-marker:hover .poi-marker-inner {
      transform: scale(1.15);
    }

    .poi-marker-icon {
      font-size: 14px;
      line-height: 1;
      filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
    }

    .poi-popup-container .leaflet-popup-content-wrapper {
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .poi-popup {
      font-family: inherit;
      min-width: 220px;
    }

    .poi-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--color-border);
      margin-bottom: 0.75rem;
    }

    .poi-header .poi-icon {
      font-size: 1.5rem;
    }

    .poi-name {
      font-size: 1rem;
      color: var(--color-text-primary);
    }

    .poi-details {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .poi-row {
      display: flex;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .poi-label {
      color: var(--color-text-muted);
      min-width: 70px;
    }

    .poi-value {
      color: var(--color-text-primary);
      font-weight: 500;
    }

    .poi-footer {
      padding-top: 0.5rem;
      border-top: 1px solid var(--color-border);
    }

    .poi-footer a {
      color: var(--color-primary);
      text-decoration: none;
      font-size: 0.85rem;
    }

    .poi-footer a:hover {
      text-decoration: underline;
    }

    .tooltip-label {
      color: rgba(255, 255, 255, 0.7);
    }

    .tooltip-value {
      font-weight: 600;
    }

    @media (max-width: 767px) {
      .elevation-profile {
        height: 150px;
      }

      .elevation-stats-quick {
        display: none;
      }

      .elevation-header {
        padding: 0.5rem 0.75rem;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .elevation-stats-quick {
        gap: 1rem;
        font-size: 0.85rem;
      }
    }

    .panel-messages {
      padding: 0;
    }

    .message {
      min-height: 3rem;
      padding: 0.75rem 1rem;
      border-radius: 6px;
      border: 1px solid transparent;
      background: #f1f8ff;
      color: #0d47a1;
    }

    .message.hidden {
      display: none;
    }

    .message.error {
      background: #ffebee;
      border-color: rgba(244, 67, 54, 0.3);
      color: #c62828;
    }

    .map-container {
      flex: 1;
      position: relative;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .map-main {
      position: relative;
      flex: 1;
      min-height: 0;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .btn-menu {
      display: none;
      position: absolute;
      top: 1rem;
      left: 1rem;
      z-index: 1000;
      background: #fff;
      border: 2px solid var(--color-border);
      border-radius: 6px;
      padding: 0.6rem 0.8rem;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: var(--shadow-md);
    }

    .btn-close-panel {
      border: none;
      background: transparent;
      font-size: 1.25rem;
      cursor: pointer;
      border-radius: 4px;
      padding: 0.2rem 0.4rem;
    }

    .btn-close-panel:hover,
    .btn-close-panel:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .panel-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      z-index: 1500;
      opacity: 0;
      animation: fadeIn 0.2s forwards;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    @media (max-width: 767px) {
      .tools-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 85vw;
        max-width: 320px;
        z-index: 2000;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }

      .tools-panel.open {
        transform: translateX(0);
      }

      .btn-menu {
        display: block;
      }
    }

    @media (min-width: 768px) {
      .btn-close-panel {
        display: none;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .tools-panel {
        width: 280px;
        min-width: 280px;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <aside class="tools-panel" id="tools-panel" role="complementary" aria-label="Panneau d'outils">
      <header class="panel-header">
        <h1 class="panel-title">Lecteur GPX</h1>
        <button class="btn-close-panel" id="close-panel" aria-label="Fermer le panneau">✕</button>
      </header>
      <div class="panel-content">
        <section class="panel-section">
          <h3 class="section-title">Fichier GPX</h3>
          <div class="import-actions">
            <button class="btn btn-primary" id="import-button">
              <span aria-hidden="true">📁</span>
              Importer GPX
            </button>
            <button class="btn btn-primary" id="export-button" disabled>
              <span aria-hidden="true">💾</span>
              Exporter GPX
            </button>
          </div>
          <div class="file-info" id="file-info" style="display: none;">
            <small class="text-muted">Fichier actuel :</small>
            <p class="filename" id="current-filename">—</p>
            <label for="gpx-name-input" style="display:block; font-size:0.85rem; color:var(--color-text-muted); margin-top:0.75rem;">
              Nom d'export
            </label>
            <input id="gpx-name-input" class="file-name-input" type="text" placeholder="Nom du fichier" autocomplete="off" />
          </div>
          <div class="drop-zone" id="panel-drop-zone">
            <p>Ou glissez-déposez un fichier .gpx ici</p>
          </div>
        </section>

        <section class="panel-section" id="waypoints-section" style="display: none;">
          <h3 class="section-title">
            Waypoints
            <span class="badge" id="waypoint-count">0</span>
          </h3>
          <div class="waypoints-list" id="waypoints-list"></div>
          <button class="btn btn-secondary btn-small" id="clear-waypoints">Effacer tous les waypoints</button>
        </section>

        <section class="panel-section" id="trace-info-section" style="display: none;">
          <h3 class="section-title">Informations</h3>
          <dl class="info-list">
            <dt>Nom de la trace</dt>
            <dd>
              <span id="trace-name" class="trace-name">—</span>
              <span
                class="trace-name-help"
                title="Le nom provient d'abord du fichier GPX, puis du nom de fichier, ou d'un nom par défaut."
                aria-hidden="true"
              >
                ℹ️
              </span>
            </dd>
            <dt>Nom du fichier</dt>
            <dd id="file-name" class="file-name">—</dd>
            <dt>Distance totale</dt>
            <dd id="trace-distance" class="stat-highlight">—</dd>
            <dt>Dénivelé positif (D+)</dt>
            <dd id="trace-elevation-gain" class="stat-highlight">—</dd>
            <dt>Dénivelé négatif (D-)</dt>
            <dd id="trace-elevation-loss" class="stat-highlight">—</dd>
            <dt>Altitude</dt>
            <dd id="trace-altitude-range">—</dd>
            <dt>Nombre de points</dt>
            <dd id="point-count">—</dd>
            <dt>Type</dt>
            <dd id="trace-type">—</dd>
          </dl>
        </section>

        <section class="panel-section" id="layers-section">
          <h3 class="section-title">Calques et affichage</h3>
          <div class="layer-toggle">
            <label class="toggle-label" for="show-cemeteries">
              <input
                type="checkbox"
                id="show-cemeteries"
                class="toggle-input"
                aria-describedby="cemeteries-description"
              />
              <span class="toggle-switch"></span>
              <span class="toggle-text">
                <span class="toggle-icon" aria-hidden="true">🪦</span>
                Cimetières OSM
              </span>
              <span class="toggle-count" id="cemeteries-count" style="display: none;">(0)</span>
            </label>
            <p id="cemeteries-description" class="toggle-help">
              Affiche les cimetières sur la zone visible
            </p>
          </div>
          <div class="layer-loading" id="cemeteries-loading" style="display: none;">
            <span class="loading-spinner" aria-hidden="true">⏳</span>
            Chargement des POI...
          </div>
          <div class="layer-error" id="cemeteries-error" style="display: none;" role="alert"></div>
          <div class="layer-info" id="cemeteries-zoom-info" style="display: none;">
            <small>ℹ️ Zoomez davantage pour voir les cimetières (zoom ≥ 12)</small>
          </div>
        </section>

        <section class="panel-section panel-messages">
          <div id="message" class="message hidden" role="status" aria-live="polite"></div>
        </section>
      </div>
    </aside>

    <main class="map-container">
      <div class="map-main">
        <div id="map"></div>
        <button class="btn-menu" id="menu-toggle" aria-label="Ouvrir le panneau" aria-expanded="false">☰</button>
      </div>
      <div class="elevation-profile" id="elevation-profile" aria-hidden="true">
        <div class="elevation-header" id="elevation-header">
          <div class="elevation-title" title="Profil altimétrique">
            <span class="elevation-icon" aria-hidden="true">📊</span>
            <h3>Profil altimétrique</h3>
          </div>
          <div class="elevation-stats-quick">
            <span class="stat-item">
              <span class="stat-label">Distance :</span>
              <span class="stat-value" id="profile-distance">—</span>
            </span>
            <span class="stat-item">
              <span class="stat-label">D+ :</span>
              <span class="stat-value" id="profile-elevation-gain">—</span>
            </span>
            <span class="stat-item">
              <span class="stat-label">D- :</span>
              <span class="stat-value" id="profile-elevation-loss">—</span>
            </span>
          </div>
          <button class="btn-collapse" id="elevation-collapse" type="button" aria-expanded="true" aria-label="Réduire le profil">
            <span aria-hidden="true">▼</span>
          </button>
        </div>
        <div class="elevation-content" id="elevation-content">
          <canvas
            id="elevation-canvas"
            role="img"
            aria-label="Graphique du profil altimétrique de la trace"
            aria-describedby="elevation-description"
            tabindex="0"
          ></canvas>
          <div id="elevation-description" class="sr-only">
            Le graphique montre l'élévation en mètres en fonction de la distance parcourue en kilomètres.
            Distance totale : <span id="aria-distance">—</span>.
            Dénivelé positif : <span id="aria-d-plus">—</span>.
            Altitude minimum : <span id="aria-min">—</span>.
            Altitude maximum : <span id="aria-max">—</span>.
          </div>
          <div class="elevation-tooltip" id="elevation-tooltip" style="display: none;">
            <div class="tooltip-row">
              <span class="tooltip-label">Distance :</span>
              <span class="tooltip-value" id="tooltip-distance">—</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Altitude :</span>
              <span class="tooltip-value" id="tooltip-elevation">—</span>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <input id="file-input" type="file" accept=".gpx" hidden />

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
  <script>
    /**
     * Convertit un élément XML GPX en GeoJSON Feature.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertPoint(element, featureType) {
      if (!element) {
        return null;
      }

      const lat = parseFloat(element.getAttribute('lat'));
      const lon = parseFloat(element.getAttribute('lon'));

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }

      const properties = { kind: featureType };

      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const ele = element.querySelector('ele');
      if (ele && ele.textContent.trim()) {
        const elevation = parseFloat(ele.textContent.trim());
        if (Number.isFinite(elevation)) {
          properties.ele = elevation;
        }
      }

      const time = element.querySelector('time');
      if (time && time.textContent.trim()) {
        properties.time = time.textContent.trim();
      }

      return {
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [lon, lat]
        },
        properties
      };
    }

    /**
     * Convertit une liste de points GPX en coordonnées GeoJSON.
     * @param {NodeListOf<Element>} points
     * @returns {number[][]}
     */
    function extractCoordinates(points) {
      const coordinates = [];
      points.forEach((point) => {
        const lat = parseFloat(point.getAttribute('lat'));
        const lon = parseFloat(point.getAttribute('lon'));
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          coordinates.push([lon, lat]);
        }
      });
      return coordinates;
    }

    /**
     * Convertit un élément GPX en GeoJSON pour les routes ou pistes.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertLinearFeature(element, featureType) {
      if (!element) {
        return null;
      }

      const properties = { kind: featureType };
      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const segments = [];

      if (featureType === 'track') {
        const trksegs = element.querySelectorAll('trkseg');
        trksegs.forEach((segment) => {
          const coords = extractCoordinates(segment.querySelectorAll('trkpt'));
          if (coords.length > 1) {
            segments.push(coords);
          }
        });
      } else if (featureType === 'route') {
        const coords = extractCoordinates(element.querySelectorAll('rtept'));
        if (coords.length > 1) {
          segments.push(coords);
        }
      }

      if (segments.length === 0) {
        return null;
      }

      const geometry =
        segments.length === 1
          ? { type: 'LineString', coordinates: segments[0] }
          : { type: 'MultiLineString', coordinates: segments };

      return {
        type: 'Feature',
        geometry,
        properties
      };
    }

    /**
     * Réalise une conversion minimale GPX -> GeoJSON pour les traces, routes et waypoints.
     * @param {XMLDocument} xml
     * @returns {GeoJSON.FeatureCollection}
     */
    function convertGpxToGeoJSON(xml) {
      const features = [];

      xml.querySelectorAll('wpt').forEach((wpt) => {
        const feature = convertPoint(wpt, 'waypoint');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('rte').forEach((route) => {
        const feature = convertLinearFeature(route, 'route');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('trk').forEach((track) => {
        const feature = convertLinearFeature(track, 'track');
        if (feature) {
          features.push(feature);
        }
      });

      return {
        type: 'FeatureCollection',
        features
      };
    }

    function initPOIManager() {
      if (!cemeteriesToggle) {
        return;
      }
      cemeteriesToggle.checked = false;
      cemeteriesToggle.addEventListener('change', handleCemeteriesToggle);
      map.on('moveend', handlePOIViewportChange);
      map.on('zoomend', handlePOIViewportChange);
    }

    function handleCemeteriesToggle(event) {
      const isEnabled = Boolean(event?.target?.checked);
      if (isEnabled) {
        enableCemeteryLayer();
      } else {
        disableCemeteryLayer();
      }
    }

    function enableCemeteryLayer() {
      poiManager.enabled = true;
      hidePOIError();
      if (!map.hasLayer(poiManager.layerGroup)) {
        poiManager.layerGroup.addTo(map);
      }
      if (map.getZoom() < POI_SETTINGS.minZoom) {
        showPOIZoomInfo();
        poiManager.layerGroup.clearLayers();
        updatePOICount(0);
        return;
      }
      hidePOIZoomInfo();
      loadPOIForCurrentView(true);
    }

    function disableCemeteryLayer() {
      poiManager.enabled = false;
      poiManager.layerGroup.clearLayers();
      updatePOICount(0);
      hidePOILoadingIndicator();
      hidePOIZoomInfo();
      hidePOIError();
      if (map.hasLayer(poiManager.layerGroup)) {
        map.removeLayer(poiManager.layerGroup);
      }
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
        poiManager.debounceTimer = null;
      }
      if (poiManager.abortController) {
        poiManager.abortController.abort();
        poiManager.abortController = null;
      }
    }

    function handlePOIViewportChange() {
      if (!poiManager.enabled) {
        return;
      }
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
      }
      poiManager.debounceTimer = setTimeout(() => {
        loadPOIForCurrentView();
      }, POI_SETTINGS.debounceMs);
    }

    async function loadPOIForCurrentView(isImmediate = false) {
      if (!poiManager.enabled) {
        return;
      }
      if (poiManager.loading && !isImmediate) {
        return;
      }

      const bounds = map.getBounds();

      if (map.getZoom() < POI_SETTINGS.minZoom) {
        poiManager.layerGroup.clearLayers();
        updatePOICount(0);
        showPOIZoomInfo();
        hidePOILoadingIndicator();
        return;
      }

      if (isBoundsTooLarge(bounds)) {
        poiManager.layerGroup.clearLayers();
        updatePOICount(0);
        showPOIError('Zone trop grande, veuillez zoomer davantage.');
        hidePOILoadingIndicator();
        return;
      }

      hidePOIZoomInfo();
      hidePOIError();

      const cacheKey = boundsToKey(bounds);
      const cachedPois = poiCache.get(cacheKey);
      if (cachedPois) {
        displayPOIMarkers(cachedPois);
        return;
      }

      const requestId = ++poiManager.currentRequestId;
      poiManager.loading = true;
      showPOILoadingIndicator();

      try {
        const pois = await fetchPOIsFromOverpass(bounds);
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiCache.set(cacheKey, pois);
        poiCache.prune(POI_SETTINGS.maxCacheEntries);
        displayPOIMarkers(pois);
        poiManager.stats.totalLoaded += pois.length;
        poiManager.stats.requestCount += 1;
      } catch (error) {
        if (error && error.name === 'AbortError') {
          return;
        }
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiManager.stats.errorCount += 1;
        showPOIError(error?.message || 'Impossible de charger les cimetières.');
        poiManager.layerGroup.clearLayers();
        updatePOICount(0);
      } finally {
        if (poiManager.currentRequestId === requestId) {
          poiManager.loading = false;
          hidePOILoadingIndicator();
        }
      }
    }

    function boundsToKey(bounds) {
      const precision = 3;
      return [
        bounds.getSouth().toFixed(precision),
        bounds.getWest().toFixed(precision),
        bounds.getNorth().toFixed(precision),
        bounds.getEast().toFixed(precision)
      ].join(',');
    }

    function isBoundsTooLarge(bounds) {
      const north = bounds.getNorth();
      const south = bounds.getSouth();
      const east = bounds.getEast();
      const west = bounds.getWest();
      const latDiff = Math.abs(north - south);
      const lngDiff = Math.abs(east - west);
      const area = latDiff * lngDiff;
      return area > POI_SETTINGS.areaLimitDegSq;
    }

    async function enforceRequestThrottle() {
      const now = Date.now();
      const elapsed = now - poiRequestLimiter.lastRequest;
      if (elapsed < poiRequestLimiter.minInterval) {
        await new Promise((resolve) =>
          setTimeout(resolve, poiRequestLimiter.minInterval - elapsed)
        );
      }
      poiRequestLimiter.lastRequest = Date.now();
    }

    async function fetchPOIsFromOverpass(bounds) {
      const query = buildOverpassQuery(bounds);
      let lastError = null;

      for (let attempt = 0; attempt <= POI_SETTINGS.maxRetries; attempt++) {
        const endpoint = OVERPASS_ENDPOINTS[attempt % OVERPASS_ENDPOINTS.length];
        const backoffDelay = attempt > 0 ? 1000 * Math.pow(2, attempt - 1) : 0;
        if (backoffDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, backoffDelay));
        }

        const controller = new AbortController();
        poiManager.abortController = controller;
        let timedOut = false;
        const timeoutId = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, POI_SETTINGS.requestTimeoutMs);

        try {
          await enforceRequestThrottle();
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: `data=${encodeURIComponent(query)}`,
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (!response.ok) {
            if (response.status === 429) {
              lastError = new Error('Trop de requêtes. Veuillez patienter quelques instants.');
            } else if (response.status === 504) {
              lastError = new Error('Timeout du serveur. Essayez de zoomer davantage.');
            } else {
              lastError = new Error(`Erreur HTTP ${response.status}`);
            }
            continue;
          }

          const data = await response.json();
          const elements = Array.isArray(data?.elements) ? data.elements : [];
          const pois = elements.map(parsePOIElement).filter(Boolean);

          if (pois.length > POI_SETTINGS.maxItems) {
            return pois.slice(0, POI_SETTINGS.maxItems);
          }
          return pois;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            if (timedOut) {
              lastError = new Error('Timeout de la requête');
              continue;
            }
            throw error;
          }
          lastError =
            error instanceof Error
              ? error
              : new Error('Erreur inconnue lors du chargement des POI.');
        } finally {
          if (poiManager.abortController === controller) {
            poiManager.abortController = null;
          }
        }
      }

      throw lastError || new Error('Impossible de récupérer les cimetières.');
    }

    function buildOverpassQuery(bounds) {
      const south = bounds.getSouth();
      const west = bounds.getWest();
      const north = bounds.getNorth();
      const east = bounds.getEast();
      const bbox = `${south},${west},${north},${east}`;
      return `
        [out:json][timeout:25][bbox:${bbox}];
        (
          node["amenity"="grave_yard"];
          way["amenity"="grave_yard"];
          relation["amenity"="grave_yard"];
          node["landuse"="cemetery"];
          way["landuse"="cemetery"];
          relation["landuse"="cemetery"];
          node["amenity"="crematorium"];
          way["amenity"="crematorium"];
          relation["amenity"="crematorium"];
        );
        out center;
      `.trim();
    }

    function parsePOIElement(element) {
      if (!element) {
        return null;
      }
      const tags = element.tags || {};
      let lat;
      let lon;

      if (element.type === 'node') {
        lat = element.lat;
        lon = element.lon;
      } else if (element.center) {
        lat = element.center.lat;
        lon = element.center.lon;
      }

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }

      const type =
        tags.amenity === 'grave_yard'
          ? 'grave_yard'
          : tags.landuse === 'cemetery'
          ? 'cemetery'
          : tags.amenity === 'crematorium'
          ? 'crematorium'
          : null;

      if (!type) {
        return null;
      }

      let address = '';
      if (tags['addr:street']) {
        address = tags['addr:housenumber']
          ? `${tags['addr:housenumber']} ${tags['addr:street']}`
          : tags['addr:street'];
        if (tags['addr:city']) {
          address += `, ${tags['addr:city']}`;
        }
      }

      return {
        id: element.id,
        osmType: element.type,
        lat,
        lon,
        type,
        name: tags.name || 'Sans nom',
        religion: tags.religion || null,
        address: address || null
      };
    }

    function displayPOIMarkers(pois) {
      poiManager.layerGroup.clearLayers();
      if (!Array.isArray(pois) || pois.length === 0) {
        poiManager.stats.currentDisplayed = 0;
        updatePOICount(0);
        return;
      }

      pois.forEach((poi) => {
        const marker = createPOIMarker(poi);
        if (marker) {
          marker.poi = poi;
          poiManager.layerGroup.addLayer(marker);
        }
      });

      poiManager.stats.currentDisplayed = pois.length;
      updatePOICount(pois.length);
    }

    function createPOIMarker(poi) {
      if (!poi) {
        return null;
      }
      const style = POI_STYLES[poi.type] || POI_STYLES.cemetery;
      const iconSize = style.size === 'small' ? [24, 24] : [30, 30];
      const iconAnchor = [iconSize[0] / 2, iconSize[1] / 2];
      const icon = L.divIcon({
        className: 'poi-marker',
        html: `
          <div class="poi-marker-inner" style="background-color: ${style.color};">
            <span class="poi-marker-icon">${style.icon}</span>
          </div>
        `,
        iconSize,
        iconAnchor
      });

      const marker = L.marker([poi.lat, poi.lon], {
        icon,
        opacity: 0.85,
        title: poi.name
      });

      marker.bindPopup(createPOIPopupContent(poi), {
        maxWidth: 300,
        className: 'poi-popup-container'
      });

      if (poi.name) {
        marker.bindTooltip(poi.name, {
          direction: 'top',
          offset: [0, -15]
        });
      }

      return marker;
    }

    function createPOIPopupContent(poi) {
      const style = POI_STYLES[poi.type] || POI_STYLES.cemetery;
      const typeLabel =
        poi.type === 'grave_yard'
          ? 'Petit cimetière'
          : poi.type === 'cemetery'
          ? 'Cimetière'
          : poi.type === 'crematorium'
          ? 'Crématorium'
          : poi.type;

      let html = `
        <div class="poi-popup">
          <div class="poi-header">
            <span class="poi-icon" aria-hidden="true">${style.icon}</span>
            <strong class="poi-name">${escapeHtml(poi.name)}</strong>
          </div>
          <div class="poi-details">
            <div class="poi-row">
              <span class="poi-label">Type :</span>
              <span class="poi-value">${typeLabel}</span>
            </div>
      `;

      if (poi.religion) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Religion :</span>
              <span class="poi-value">${escapeHtml(poi.religion)}</span>
            </div>
        `;
      }

      if (poi.address) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Adresse :</span>
              <span class="poi-value">${escapeHtml(poi.address)}</span>
            </div>
        `;
      }

      html += `
          </div>
          <div class="poi-footer">
            <small>
              <a href="https://www.openstreetmap.org/${poi.osmType}/${poi.id}" target="_blank" rel="noopener noreferrer">
                Voir sur OpenStreetMap ↗
              </a>
            </small>
          </div>
        </div>
      `;

      return html;
    }

    function showPOILoadingIndicator() {
      if (cemeteriesLoading) {
        cemeteriesLoading.style.display = 'flex';
      }
    }

    function hidePOILoadingIndicator() {
      if (cemeteriesLoading) {
        cemeteriesLoading.style.display = 'none';
      }
    }

    function showPOIZoomInfo() {
      if (cemeteriesZoomInfo) {
        cemeteriesZoomInfo.style.display = 'block';
      }
    }

    function hidePOIZoomInfo() {
      if (cemeteriesZoomInfo) {
        cemeteriesZoomInfo.style.display = 'none';
      }
    }

    function showPOIError(message) {
      if (cemeteriesError) {
        cemeteriesError.textContent = `⚠️ ${message}`;
        cemeteriesError.style.display = 'block';
        setTimeout(() => {
          if (cemeteriesError) {
            cemeteriesError.style.display = 'none';
          }
        }, 5000);
      }
    }

    function hidePOIError() {
      if (cemeteriesError) {
        cemeteriesError.style.display = 'none';
      }
    }

    function updatePOICount(count) {
      if (!cemeteriesCountLabel) {
        return;
      }
      if (count > 0) {
        cemeteriesCountLabel.textContent = `(${count})`;
        cemeteriesCountLabel.style.display = 'inline';
      } else {
        cemeteriesCountLabel.style.display = 'none';
      }
    }

    // Initialisation de la carte Leaflet centrée sur Paris
    const map = L.map('map').setView([48.8566, 2.3522], 12);
    map.zoomControl.setPosition('topright');

    // Couche de tuiles OpenStreetMap avec attribution obligatoire
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    const fileInput = document.getElementById('file-input');
    const importButton = document.getElementById('import-button');
    const exportButton = document.getElementById('export-button');
    const gpxNameInput = document.getElementById('gpx-name-input');
    const messageBox = document.getElementById('message');
    const panelDropZone = document.getElementById('panel-drop-zone');
    const toolsPanel = document.getElementById('tools-panel');
    const menuToggle = document.getElementById('menu-toggle');
    const closePanel = document.getElementById('close-panel');
    const fileInfo = document.getElementById('file-info');
    const currentFilename = document.getElementById('current-filename');
    const traceFileNameLabel = document.getElementById('file-name');
    const waypointsSection = document.getElementById('waypoints-section');
    const waypointsList = document.getElementById('waypoints-list');
    const waypointCountLabel = document.getElementById('waypoint-count');
    const clearWaypointsButton = document.getElementById('clear-waypoints');
    const traceInfoSection = document.getElementById('trace-info-section');
    const traceNameLabel = document.getElementById('trace-name');
    const pointCountLabel = document.getElementById('point-count');
    const traceTypeLabel = document.getElementById('trace-type');
    const traceDistanceLabel = document.getElementById('trace-distance');
    const traceElevationGainLabel = document.getElementById('trace-elevation-gain');
    const traceElevationLossLabel = document.getElementById('trace-elevation-loss');
    const traceAltitudeRangeLabel = document.getElementById('trace-altitude-range');
    const ariaDistance = document.getElementById('aria-distance');
    const ariaDPlus = document.getElementById('aria-d-plus');
    const ariaMin = document.getElementById('aria-min');
    const ariaMax = document.getElementById('aria-max');
    const profileDistanceValue = document.getElementById('profile-distance');
    const profileElevationGainValue = document.getElementById('profile-elevation-gain');
    const profileElevationLossValue = document.getElementById('profile-elevation-loss');
    const elevationProfile = document.getElementById('elevation-profile');
    const elevationHeader = document.getElementById('elevation-header');
    const elevationCollapseButton = document.getElementById('elevation-collapse');
    const elevationContent = document.getElementById('elevation-content');
    const elevationCanvas = document.getElementById('elevation-canvas');
    const elevationTooltip = document.getElementById('elevation-tooltip');
    const cemeteriesToggle = document.getElementById('show-cemeteries');
    const cemeteriesCountLabel = document.getElementById('cemeteries-count');
    const cemeteriesLoading = document.getElementById('cemeteries-loading');
    const cemeteriesError = document.getElementById('cemeteries-error');
    const cemeteriesZoomInfo = document.getElementById('cemeteries-zoom-info');

    let backdropElement = null;

    const waypointLayerGroup = L.layerGroup().addTo(map);
    let waypointCounter = 1;

    let gpxLayerGroup = null;
    let arrowLayerGroup = null;

    const POI_STYLES = {
      grave_yard: {
        icon: '⛪',
        color: '#757575',
        size: 'small'
      },
      cemetery: {
        icon: '🪦',
        color: '#6a1b9a',
        size: 'medium'
      },
      crematorium: {
        icon: '🕯️',
        color: '#424242',
        size: 'small'
      }
    };

    const OVERPASS_ENDPOINTS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://overpass.openstreetmap.fr/api/interpreter'
    ];

    const POI_SETTINGS = {
      minZoom: 12,
      debounceMs: 2000,
      maxItems: 200,
      cacheTtlMs: 10 * 60 * 1000,
      maxCacheEntries: 10,
      areaLimitDegSq: 0.1,
      maxRetries: 2,
      requestTimeoutMs: 10000
    };

    const poiCache = {
      data: new Map(),
      set(key, value) {
        this.data.set(key, { value, timestamp: Date.now() });
      },
      get(key) {
        const entry = this.data.get(key);
        if (!entry) {
          return null;
        }
        if (Date.now() - entry.timestamp > POI_SETTINGS.cacheTtlMs) {
          this.data.delete(key);
          return null;
        }
        return entry.value;
      },
      prune(maxEntries) {
        if (this.data.size <= maxEntries) {
          return;
        }
        const sorted = Array.from(this.data.entries()).sort(
          (a, b) => a[1].timestamp - b[1].timestamp
        );
        while (sorted.length > maxEntries) {
          const [keyToDelete] = sorted.shift();
          this.data.delete(keyToDelete);
        }
      },
      clear() {
        this.data.clear();
      }
    };

    const poiRequestLimiter = {
      lastRequest: 0,
      minInterval: 2000
    };

    const poiManager = {
      enabled: false,
      loading: false,
      layerGroup: L.layerGroup(),
      debounceTimer: null,
      abortController: null,
      currentRequestId: 0,
      stats: {
        totalLoaded: 0,
        currentDisplayed: 0,
        requestCount: 0,
        errorCount: 0
      }
    };
    let currentGpxDocument = null;
    let currentGpxFileName = '';
    let currentGeojson = null;
    let currentTraceName = '';
    let traceNameSource = '';
    let currentElevationData = null;
    let elevationHoverMarker = null;
    let elevationMouseMoveHandler = null;
    let elevationMouseLeaveHandler = null;

    setExportAvailability(false);
    updateWaypointsList();
    updateTraceInfo(null);

    /**
     * Affiche un message utilisateur discret.
     * @param {string} text
     * @param {boolean} isError
     */
    function showMessage(text, isError = false, isHtml = false) {
      if (!messageBox) {
        return;
      }
      const content = text == null ? '' : String(text);
      const trimmed = content.trim();
      if (!trimmed) {
        messageBox.classList.add('hidden');
        messageBox.textContent = '';
        messageBox.classList.remove('error');
        return;
      }
      if (isHtml) {
        messageBox.innerHTML = content;
      } else {
        messageBox.textContent = trimmed;
      }
      messageBox.classList.remove('hidden');
      messageBox.classList.toggle('error', Boolean(isError));
    }

    /**
     * Efface les couches GPX précédemment ajoutées.
     */
    function clearPreviousLayers() {
      if (gpxLayerGroup) {
        map.removeLayer(gpxLayerGroup);
        gpxLayerGroup = null;
      }
      if (arrowLayerGroup) {
        map.removeLayer(arrowLayerGroup);
        arrowLayerGroup = null;
      }
      waypointLayerGroup.clearLayers();
      waypointCounter = 1;
      currentGeojson = null;
      updateWaypointsList();
      updateTraceInfo(null);
      resetElevationDisplay();
    }

    function setExportAvailability(isEnabled) {
      if (!exportButton) {
        return;
      }
      exportButton.disabled = !isEnabled;
      if (!isEnabled) {
        if (gpxNameInput) {
          gpxNameInput.value = '';
        }
        if (fileInfo) {
          fileInfo.style.display = 'none';
        }
        if (currentFilename) {
          currentFilename.textContent = '—';
        }
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '—';
        }
        resetElevationDisplay();
      } else if (fileInfo) {
        fileInfo.style.display = 'block';
        if (traceFileNameLabel && currentGpxFileName) {
          traceFileNameLabel.textContent = currentGpxFileName;
        }
      }
    }

    function normalizeLatLngSegments(latlngs) {
      if (!Array.isArray(latlngs)) {
        return [];
      }
      if (latlngs.length === 0) {
        return [];
      }
      const first = latlngs[0];
      if (Array.isArray(first)) {
        return latlngs;
      }
      return [latlngs];
    }

    function computeBearingDegrees(startLatLng, endLatLng) {
      const toRadians = (value) => (value * Math.PI) / 180;
      const toDegrees = (value) => (value * 180) / Math.PI;
      const phi1 = toRadians(startLatLng.lat);
      const phi2 = toRadians(endLatLng.lat);
      const deltaLambda = toRadians(endLatLng.lng - startLatLng.lng);
      const y = Math.sin(deltaLambda) * Math.cos(phi2);
      const x =
        Math.cos(phi1) * Math.sin(phi2) -
        Math.sin(phi1) * Math.cos(phi2) * Math.cos(deltaLambda);
      const theta = Math.atan2(y, x);
      return (toDegrees(theta) + 360) % 360;
    }

    function escapeHtml(value) {
      if (value === null || value === undefined) {
        return '';
      }
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function sanitizeFileName(name) {
      if (!name) {
        return 'trace';
      }
      const sanitized =
        name
          .replace(/[<>:"/\\|?*]/g, '_')
          .replace(/\s+/g, '_')
          .replace(/_+/g, '_')
          .replace(/^_|_$/g, '')
          .substring(0, 100) || 'trace';
      return sanitized;
    }

    function extractTraceName(xmlDoc, fileName) {
      if (xmlDoc) {
        const trackNames = xmlDoc.querySelectorAll('trk > name');
        for (const trackName of trackNames) {
          const value = trackName.textContent && trackName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-track' };
          }
        }

        const routeNames = xmlDoc.querySelectorAll('rte > name');
        for (const routeName of routeNames) {
          const value = routeName.textContent && routeName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-route' };
          }
        }

        const metadataName = xmlDoc.querySelector('metadata > name');
        if (metadataName) {
          const value = metadataName.textContent && metadataName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-metadata' };
          }
        }
      }

      if (fileName) {
        const withoutExtension = fileName.replace(/\.gpx$/i, '');
        if (withoutExtension.trim()) {
          return { name: withoutExtension.trim(), source: 'filename' };
        }
      }

      return { name: 'Trace sans nom', source: 'default' };
    }

    function displayTraceName(traceName, source) {
      if (!traceNameLabel) {
        return;
      }
      const safeName = traceName || '—';
      traceNameLabel.textContent = safeName;
      let tooltip = '';
      switch (source) {
        case 'gpx-track':
        case 'gpx-route':
        case 'gpx-metadata':
          tooltip = 'Nom extrait du fichier GPX';
          break;
        case 'filename':
          tooltip = 'Nom basé sur le nom de fichier';
          break;
        case 'default':
        default:
          tooltip = 'Nom par défaut (aucune information disponible)';
          break;
      }
      traceNameLabel.setAttribute('title', tooltip);
      traceNameLabel.className = `trace-name trace-name--${source || 'default'}`;
    }

    function haversineDistance(pointA, pointB) {
      if (!pointA || !pointB) {
        return 0;
      }
      const R = 6371000;
      const lat1 = (pointA.lat * Math.PI) / 180;
      const lat2 = (pointB.lat * Math.PI) / 180;
      const dLat = ((pointB.lat - pointA.lat) * Math.PI) / 180;
      const dLng = ((pointB.lng - pointA.lng) * Math.PI) / 180;

      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function calculateElevationStats(points) {
      if (!Array.isArray(points) || points.length === 0) {
        return null;
      }

      let elevationGain = 0;
      let elevationLoss = 0;
      let minElevation = Infinity;
      let maxElevation = -Infinity;
      let sumElevation = 0;

      points.forEach((point, index) => {
        const elevation = point.elevation;
        if (elevation < minElevation) {
          minElevation = elevation;
        }
        if (elevation > maxElevation) {
          maxElevation = elevation;
        }
        sumElevation += elevation;

        if (index > 0) {
          const diff = elevation - points[index - 1].elevation;
          if (diff > 0) {
            elevationGain += diff;
          } else if (diff < 0) {
            elevationLoss += Math.abs(diff);
          }
        }
      });

      return {
        totalDistance: Math.round(points[points.length - 1].distance),
        elevationGain: Math.round(elevationGain),
        elevationLoss: Math.round(elevationLoss),
        minElevation: Math.round(minElevation),
        maxElevation: Math.round(maxElevation),
        avgElevation: Math.round(sumElevation / points.length)
      };
    }

    function simplifyElevationData(points, maxPoints = 1500) {
      if (!Array.isArray(points) || points.length <= maxPoints) {
        return points || [];
      }
      const step = Math.max(1, Math.floor(points.length / maxPoints));
      const simplified = [];
      for (let i = 0; i < points.length; i += step) {
        simplified.push(points[i]);
      }
      if (simplified[simplified.length - 1] !== points[points.length - 1]) {
        simplified.push(points[points.length - 1]);
      }
      return simplified;
    }

    function extractElevationData(geojson, gpxDoc) {
      if (!geojson || !Array.isArray(geojson.features) || !gpxDoc) {
        return null;
      }

      const trackPoints = Array.from(gpxDoc.querySelectorAll('trkpt, rtept'));
      const elevationMap = new Map();
      trackPoints.forEach((trkpt) => {
        const lat = parseFloat(trkpt.getAttribute('lat'));
        const lng = parseFloat(trkpt.getAttribute('lon'));
        const eleNode = trkpt.querySelector('ele');
        if (!Number.isFinite(lat) || !Number.isFinite(lng) || !eleNode) {
          return;
        }
        const elevation = parseFloat(eleNode.textContent);
        if (!Number.isFinite(elevation)) {
          return;
        }
        const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
        elevationMap.set(key, elevation);
      });

      if (elevationMap.size === 0) {
        return null;
      }

      const points = [];
      let previousPoint = null;
      let cumulativeDistance = 0;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
          const elevation = elevationMap.get(key);
          if (!Number.isFinite(elevation)) {
            previousPoint = { lat, lng };
            return;
          }

          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }

          points.push({
            distance: cumulativeDistance,
            elevation,
            lat,
            lng,
            index: points.length
          });

          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (points.length < 2) {
        return null;
      }

      const stats = calculateElevationStats(points);
      if (!stats) {
        return null;
      }

      const simplifiedPoints = simplifyElevationData(points);
      return { points: simplifiedPoints, stats };
    }

    function calculateDistanceOnly(geojson) {
      if (!geojson || !Array.isArray(geojson.features)) {
        return null;
      }
      let cumulativeDistance = 0;
      let previousPoint = null;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }
          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (cumulativeDistance === 0) {
        return null;
      }
      return { distance: cumulativeDistance };
    }

    function updateElevationStats(stats) {
      if (
        !traceDistanceLabel ||
        !traceElevationGainLabel ||
        !traceElevationLossLabel ||
        !traceAltitudeRangeLabel ||
        !profileDistanceValue ||
        !profileElevationGainValue ||
        !profileElevationLossValue
      ) {
        return;
      }

      if (!stats) {
        traceDistanceLabel.textContent = '—';
        traceElevationGainLabel.textContent = '—';
        traceElevationLossLabel.textContent = '—';
        traceAltitudeRangeLabel.textContent = '—';
        profileDistanceValue.textContent = '—';
        profileElevationGainValue.textContent = '—';
        profileElevationLossValue.textContent = '—';
        if (ariaDistance) ariaDistance.textContent = '—';
        if (ariaDPlus) ariaDPlus.textContent = '—';
        if (ariaMin) ariaMin.textContent = '—';
        if (ariaMax) ariaMax.textContent = '—';
        if (elevationProfile) {
          elevationProfile.classList.remove('visible');
          elevationProfile.setAttribute('aria-hidden', 'true');
        }
        return;
      }

      const distanceKm = stats.totalDistance / 1000;
      traceDistanceLabel.textContent = `${distanceKm.toFixed(2)} km`;
      traceElevationGainLabel.textContent = `${stats.elevationGain} m`;
      traceElevationLossLabel.textContent = `${stats.elevationLoss} m`;
      traceAltitudeRangeLabel.textContent = `${stats.minElevation} m - ${stats.maxElevation} m`;

      profileDistanceValue.textContent = `${distanceKm.toFixed(2)} km`;
      profileElevationGainValue.textContent = `${stats.elevationGain} m`;
      profileElevationLossValue.textContent = `${stats.elevationLoss} m`;

      if (ariaDistance) ariaDistance.textContent = `${distanceKm.toFixed(2)} km`;
      if (ariaDPlus) ariaDPlus.textContent = `${stats.elevationGain} m`;
      if (ariaMin) ariaMin.textContent = `${stats.minElevation} m`;
      if (ariaMax) ariaMax.textContent = `${stats.maxElevation} m`;

      if (elevationProfile) {
        elevationProfile.classList.add('visible');
        elevationProfile.setAttribute('aria-hidden', 'false');
      }
    }

    function resetElevationDisplay() {
      currentElevationData = null;
      if (elevationHoverMarker) {
        map.removeLayer(elevationHoverMarker);
        elevationHoverMarker = null;
      }
      removeElevationInteraction();
      updateElevationStats(null);
      if (elevationTooltip) {
        elevationTooltip.style.display = 'none';
      }
      if (elevationContent && elevationCanvas) {
        const ctx = elevationCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, elevationCanvas.width, elevationCanvas.height);
        }
      }
      if (elevationProfile) {
        elevationProfile.classList.remove('collapsed');
        elevationProfile.setAttribute('aria-hidden', 'true');
      }
      if (elevationCollapseButton) {
        elevationCollapseButton.setAttribute('aria-expanded', 'true');
        elevationCollapseButton.setAttribute('aria-label', 'Réduire le profil');
      }
      map.invalidateSize();
    }

    function drawElevationProfile(canvas, points, stats) {
      if (!canvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return;
      }

      const width = canvas.width;
      const height = canvas.height;

      ctx.clearRect(0, 0, width, height);

      const margin = { top: 20, right: 20, bottom: 40, left: 60 };
      const chartWidth = Math.max(10, width - margin.left - margin.right);
      const chartHeight = Math.max(10, height - margin.top - margin.bottom);
      const maxDistance = stats.totalDistance || 1;
      const minEle = stats.minElevation - 20;
      const maxEle = stats.maxElevation + 20;

      const xScale = (distance) =>
        margin.left + (Math.min(distance, maxDistance) / maxDistance) * chartWidth;
      const yScale = (elevation) =>
        margin.top + chartHeight - ((elevation - minEle) / (maxEle - minEle)) * chartHeight;

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.lineWidth = 1;

      const elevationStep = Math.max(10, Math.ceil((maxEle - minEle) / 5 / 50) * 50);
      for (let ele = Math.ceil(minEle / elevationStep) * elevationStep; ele <= maxEle; ele += elevationStep) {
        const y = yScale(ele);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(width - margin.right, y);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(`${Math.round(ele)} m`, margin.left - 5, y + 4);
      }

      const distanceStepRaw = Math.max(100, Math.ceil(maxDistance / 5 / 1000) * 1000);
      for (let dist = 0; dist <= maxDistance; dist += distanceStepRaw) {
        const x = xScale(dist);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, height - margin.bottom);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${(dist / 1000).toFixed(1)} km`, x, height - margin.bottom + 18);
      }

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.lineTo(xScale(points[points.length - 1].distance), height - margin.bottom);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, margin.top, 0, height - margin.bottom);
      gradient.addColorStop(0, 'rgba(25, 118, 210, 0.3)');
      gradient.addColorStop(1, 'rgba(25, 118, 210, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.strokeStyle = '#1976d2';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#424242';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Distance (km)', width / 2, height - 8);

      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Altitude (m)', 0, 0);
      ctx.restore();
    }

    function renderElevationProfile() {
      if (
        !currentElevationData ||
        !currentElevationData.points ||
        !currentElevationData.stats ||
        !elevationCanvas ||
        !elevationProfile
      ) {
        return;
      }
      if (
        elevationProfile.classList.contains('collapsed') ||
        !elevationProfile.classList.contains('visible')
      ) {
        return;
      }
      drawElevationProfile(elevationCanvas, currentElevationData.points, currentElevationData.stats);
      setupElevationInteraction(currentElevationData.points, currentElevationData.stats);
    }

    function findClosestElevationPoint(canvas, points, stats, event) {
      if (!canvas || !points || !stats) {
        return null;
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const margin = { left: 60, right: 20 };
      const chartWidth = canvas.width - margin.left - margin.right;
      const relativeX = x - margin.left;
      if (relativeX < 0 || relativeX > chartWidth) {
        return null;
      }
      const distance = (relativeX / chartWidth) * stats.totalDistance;
      let closestPoint = points[0];
      let minDiff = Math.abs(points[0].distance - distance);
      for (let i = 1; i < points.length; i++) {
        const diff = Math.abs(points[i].distance - distance);
        if (diff < minDiff) {
          minDiff = diff;
          closestPoint = points[i];
        }
      }
      return { point: closestPoint, canvasX: x };
    }

    function removeElevationInteraction() {
      if (!elevationCanvas) {
        return;
      }
      if (elevationMouseMoveHandler) {
        elevationCanvas.removeEventListener('mousemove', elevationMouseMoveHandler);
      }
      if (elevationMouseLeaveHandler) {
        elevationCanvas.removeEventListener('mouseleave', elevationMouseLeaveHandler);
      }
      elevationMouseMoveHandler = null;
      elevationMouseLeaveHandler = null;
    }

    function setupElevationInteraction(points, stats) {
      if (!elevationCanvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      removeElevationInteraction();

      elevationMouseMoveHandler = (event) => {
        const result = findClosestElevationPoint(elevationCanvas, points, stats, event);
        if (!result) {
          if (elevationTooltip) {
            elevationTooltip.style.display = 'none';
          }
          if (elevationHoverMarker) {
            map.removeLayer(elevationHoverMarker);
            elevationHoverMarker = null;
          }
          return;
        }

        const { point, canvasX } = result;
        if (elevationTooltip) {
          const rect = elevationCanvas.getBoundingClientRect();
          elevationTooltip.style.display = 'block';
          elevationTooltip.style.left = `${canvasX + 15}px`;
          elevationTooltip.style.top = `${event.clientY - rect.top + 15}px`;
          const distanceElement = document.getElementById('tooltip-distance');
          const elevationElement = document.getElementById('tooltip-elevation');
          if (distanceElement) {
            distanceElement.textContent = `${(point.distance / 1000).toFixed(2)} km`;
          }
          if (elevationElement) {
            elevationElement.textContent = `${point.elevation.toFixed(0)} m`;
          }
        }

        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
        }
        elevationHoverMarker = L.circleMarker([point.lat, point.lng], {
          radius: 7,
          fillColor: '#ff5722',
          fillOpacity: 0.9,
          color: '#ffffff',
          weight: 2,
          interactive: false
        }).addTo(map);
      };

      elevationMouseLeaveHandler = () => {
        if (elevationTooltip) {
          elevationTooltip.style.display = 'none';
        }
        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
          elevationHoverMarker = null;
        }
      };

      elevationCanvas.addEventListener('mousemove', elevationMouseMoveHandler);
      elevationCanvas.addEventListener('mouseleave', elevationMouseLeaveHandler);
    }

    function setElevationCollapsed(collapsed) {
      if (!elevationProfile || !elevationCollapseButton) {
        return;
      }
      if (!elevationProfile.classList.contains('visible') && !collapsed) {
        return;
      }

      elevationProfile.classList.toggle('collapsed', collapsed);
      elevationCollapseButton.setAttribute('aria-expanded', String(!collapsed));
      elevationCollapseButton.setAttribute(
        'aria-label',
        collapsed ? 'Agrandir le profil' : 'Réduire le profil'
      );

      if (!collapsed) {
        requestAnimationFrame(() => {
          renderElevationProfile();
          map.invalidateSize();
        });
      } else {
        removeElevationInteraction();
        map.invalidateSize();
      }
    }

    function createWaypointPopupHtml(name) {
      const safeName = escapeHtml(name);
      return `
        <div class="waypoint-popup">
          <label for="waypoint-name-input">Nom du waypoint</label>
          <input id="waypoint-name-input" class="waypoint-name-input" type="text" value="${safeName}" />
          <div class="waypoint-popup-buttons">
            <button type="button" data-action="save">Enregistrer</button>
            <button type="button" data-action="delete">Supprimer</button>
          </div>
        </div>
      `;
    }

    function attachWaypointPopupHandlers(marker, popup) {
      const container = popup.getElement();
      if (!container) {
        return;
      }

      const input = container.querySelector('.waypoint-name-input');
      if (input) {
        input.value = marker.waypointName;
        input.focus();
        input.select();
      }

      const saveAction = () => {
        const newName = input && input.value.trim() ? input.value.trim() : marker.waypointName;
        marker.waypointName = newName;
        marker.setPopupContent(createWaypointPopupHtml(marker.waypointName));
        marker.openPopup();
        updateWaypointsList();
      };

      const deleteAction = () => {
        waypointLayerGroup.removeLayer(marker);
        map.closePopup(popup);
        updateWaypointsList();
      };

      if (input) {
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveAction();
          }
        });
      }

      const saveButton = container.querySelector('[data-action="save"]');
      if (saveButton) {
        saveButton.addEventListener('click', saveAction);
      }

      const deleteButton = container.querySelector('[data-action="delete"]');
      if (deleteButton) {
        deleteButton.addEventListener('click', deleteAction);
      }
    }

    function createWaypointMarker(latlng, name = '') {
      const trimmedName = name && name.trim() ? name.trim() : '';
      const finalName = trimmedName || `Waypoint ${waypointCounter}`;
      waypointCounter += 1;

      const marker = L.marker(latlng, { draggable: false, bubblingMouseEvents: false });
      marker.waypointName = finalName;
      marker.bindPopup(createWaypointPopupHtml(finalName));
      marker.on('popupopen', (event) => {
        attachWaypointPopupHandlers(marker, event.popup);
      });
      marker.bindTooltip(
        () => marker.waypointName,
        {
          direction: 'top',
          offset: [0, -12]
        }
      );

      waypointLayerGroup.addLayer(marker);
      updateWaypointsList();
      return marker;
    }

    function addWaypointsFromFeatures(features) {
      if (!Array.isArray(features)) {
        return;
      }
      features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const properties = feature.properties || {};
        const baseName = properties.name || properties.description || '';

        if (feature.geometry.type === 'Point') {
          const coords = feature.geometry.coordinates;
          if (Array.isArray(coords) && coords.length >= 2) {
            createWaypointMarker(L.latLng(coords[1], coords[0]), baseName);
          }
        } else if (feature.geometry.type === 'MultiPoint') {
          const points = feature.geometry.coordinates || [];
          points.forEach((coords, index) => {
            if (Array.isArray(coords) && coords.length >= 2) {
              const name = baseName ? `${baseName} (${index + 1})` : '';
              createWaypointMarker(L.latLng(coords[1], coords[0]), name);
            }
          });
        }
      });
    }

    function handleAddWaypointFromTrack(latlng) {
      const suggestedName = `Waypoint ${waypointCounter}`;
      const userInput = prompt('Nom du waypoint ?', suggestedName);
      if (userInput === null) {
        return;
      }
      const finalName = userInput.trim() ? userInput.trim() : suggestedName;
      const marker = createWaypointMarker(latlng, finalName);
      marker.openPopup();
    }

    function getWaypointMarkers() {
      const markers = [];
      waypointLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          markers.push(layer);
        } else if (layer && typeof layer.getLayers === 'function') {
          layer.getLayers().forEach((child) => {
            if (child instanceof L.Marker) {
              markers.push(child);
            }
          });
        }
      });
      return markers;
    }

    function updateWaypointsList() {
      if (!waypointsList || !waypointCountLabel || !waypointsSection) {
        return;
      }

      const markers = getWaypointMarkers();
      waypointCountLabel.textContent = markers.length;
      waypointsSection.style.display = markers.length > 0 ? 'block' : 'none';
      waypointsList.innerHTML = '';

      markers.forEach((marker) => {
        const item = document.createElement('div');
        item.className = 'waypoint-item';
        item.innerHTML = `
          <span class="waypoint-icon" aria-hidden="true">📍</span>
          <span class="waypoint-name">${escapeHtml(marker.waypointName)}</span>
          <button class="btn-icon-small" data-action="center" title="Centrer">🎯</button>
          <button class="btn-icon-small" data-action="delete" title="Supprimer">🗑️</button>
        `;

        const centerButton = item.querySelector('[data-action="center"]');
        if (centerButton) {
          centerButton.addEventListener('click', () => {
            const latlng = marker.getLatLng();
            if (latlng) {
              map.setView(latlng, Math.max(map.getZoom(), 16));
              marker.openPopup();
            }
          });
        }

        const deleteButton = item.querySelector('[data-action="delete"]');
        if (deleteButton) {
          deleteButton.addEventListener('click', () => {
            waypointLayerGroup.removeLayer(marker);
            updateWaypointsList();
          });
        }

        waypointsList.appendChild(item);
      });
    }

    function updateTraceInfo(info) {
      if (!traceInfoSection || !traceNameLabel || !pointCountLabel || !traceTypeLabel) {
        return;
      }

      if (!info) {
        traceInfoSection.style.display = 'none';
        displayTraceName('—', 'default');
        pointCountLabel.textContent = '—';
        traceTypeLabel.textContent = '—';
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '—';
        }
        return;
      }

      traceInfoSection.style.display = 'block';
      displayTraceName(currentTraceName || info.name || '—', traceNameSource || 'default');
      pointCountLabel.textContent = Number.isFinite(info.pointCount) ? info.pointCount : '—';
      traceTypeLabel.textContent = info.type || '—';
      if (traceFileNameLabel) {
        traceFileNameLabel.textContent = currentGpxFileName || '—';
      }
    }

    function createArrowIconHtml(bearing) {
      const rotation = ((bearing - 90) + 360) % 360;
      return `<span class="direction-arrow" style="display:inline-block; color:#ff5722; font-size:1rem; line-height:1; text-shadow:0 0 2px rgba(0,0,0,0.5); transform-origin:center; transform: rotate(${rotation}deg);">➤</span>`;
    }

    function createArrowMarker(point, bearing) {
      return L.marker(point, {
        icon: L.divIcon({
          className: '',
          html: createArrowIconHtml(bearing),
          iconSize: [16, 16],
          iconAnchor: [8, 8]
        }),
        interactive: false,
        keyboard: false
      });
    }

    function createArrowMarkers(layer) {
      const arrowMarkers = [];
      const latLngs = normalizeLatLngSegments(layer.getLatLngs());
      const arrowSpacingMeters = 2500;

      latLngs.forEach((segment) => {
        if (!Array.isArray(segment) || segment.length < 2) {
          return;
        }

        let previousPoint = L.latLng(segment[0]);
        let distanceFromLastArrow = 0;
        let totalSegmentDistance = 0;
        const segmentMarkers = [];

        for (let i = 1; i < segment.length; i++) {
          const currentPoint = L.latLng(segment[i]);
          let segmentDistance = map.distance(previousPoint, currentPoint);
          let segmentStart = previousPoint;

          if (segmentDistance === 0) {
            previousPoint = currentPoint;
            continue;
          }

          totalSegmentDistance += segmentDistance;

          while (distanceFromLastArrow + segmentDistance >= arrowSpacingMeters) {
            const distanceNeeded = arrowSpacingMeters - distanceFromLastArrow;
            const ratio = distanceNeeded / segmentDistance;
            const interpolatedLat =
              segmentStart.lat + (currentPoint.lat - segmentStart.lat) * ratio;
            const interpolatedLng =
              segmentStart.lng + (currentPoint.lng - segmentStart.lng) * ratio;
            const arrowPoint = L.latLng(interpolatedLat, interpolatedLng);
            const bearing = computeBearingDegrees(segmentStart, currentPoint);

            const marker = createArrowMarker(arrowPoint, bearing);

            arrowMarkers.push(marker);
            segmentMarkers.push(marker);

            segmentStart = arrowPoint;
            segmentDistance = map.distance(segmentStart, currentPoint);
            if (segmentDistance === 0) {
              break;
            }
            distanceFromLastArrow = 0;
          }

          distanceFromLastArrow += segmentDistance;
          previousPoint = currentPoint;
        }

        if (segmentMarkers.length === 0 && totalSegmentDistance > 0) {
          const targetDistance = totalSegmentDistance / 2;
          let accumulated = 0;
          for (let i = 1; i < segment.length; i++) {
            const start = L.latLng(segment[i - 1]);
            const end = L.latLng(segment[i]);
            const distance = map.distance(start, end);
            if (distance === 0) {
              continue;
            }
            if (accumulated + distance >= targetDistance) {
              const ratio = (targetDistance - accumulated) / distance;
              const lat = start.lat + (end.lat - start.lat) * ratio;
              const lng = start.lng + (end.lng - start.lng) * ratio;
              const point = L.latLng(lat, lng);
              const bearing = computeBearingDegrees(start, end);
              const marker = createArrowMarker(point, bearing);
              arrowMarkers.push(marker);
              segmentMarkers.push(marker);
              break;
            }
            accumulated += distance;
          }
        }
      });

      return arrowMarkers;
    }

    function computeTraceInfo(lineFeatures, geojson) {
      if (!Array.isArray(lineFeatures) || lineFeatures.length === 0) {
        return null;
      }

      const first = lineFeatures[0];
      const properties = first.properties || {};
      const name = properties.name || properties.description || (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : 'Trace');
      let pointCount = 0;
      let type = properties.kind || first.geometry?.type || '—';

      lineFeatures.forEach((feature) => {
        if (!feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        if (geometry.type === 'LineString') {
          pointCount += Array.isArray(geometry.coordinates) ? geometry.coordinates.length : 0;
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            pointCount += Array.isArray(segment) ? segment.length : 0;
          });
        }
        if (!type && geometry.type) {
          type = geometry.type;
        }
        if (!properties.kind && feature.properties && feature.properties.kind) {
          type = feature.properties.kind;
        }
      });

      if (!type && geojson && Array.isArray(geojson.features)) {
        const kinds = geojson.features
          .map((feature) => feature?.properties?.kind)
          .filter(Boolean);
        if (kinds.length > 0) {
          type = kinds[0];
        }
      }

      return {
        name,
        pointCount,
        type: type || '—'
      };
    }

    function displayGeoJSON(geojsonData) {
      clearPreviousLayers();

      currentGeojson = geojsonData;

      const lineFeatures = [];
      const pointFeatures = [];

      if (geojsonData && Array.isArray(geojsonData.features)) {
        geojsonData.features.forEach((feature) => {
          const geometryType = feature && feature.geometry && feature.geometry.type;
          if (geometryType === 'LineString' || geometryType === 'MultiLineString') {
            lineFeatures.push(feature);
          } else if (geometryType === 'Point' || geometryType === 'MultiPoint') {
            pointFeatures.push(feature);
          }
        });
      }

      const linesFeatureCollection = {
        type: 'FeatureCollection',
        features: lineFeatures
      };

      gpxLayerGroup = L.geoJSON(linesFeatureCollection, {
        style: function () {
          return {
            color: '#ff5722',
            weight: 3,
            opacity: 0.9
          };
        }
      }).addTo(map);

      const arrowLayers = [];
      gpxLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
          layer.on('click', (event) => {
            if (event.originalEvent) {
              event.originalEvent.preventDefault();
              event.originalEvent.stopPropagation();
            }
            handleAddWaypointFromTrack(event.latlng);
          });

          if (
            typeof L.polylineDecorator === 'function' &&
            L.Symbol &&
            typeof L.Symbol.arrowHead === 'function'
          ) {
            const decorator = L.polylineDecorator(layer, {
              patterns: [
                {
                  offset: '5%',
                  repeat: '50%',
                  symbol: L.Symbol.arrowHead({
                    pixelSize: 10,
                    headAngle: 60,
                    polygon: false,
                    pathOptions: {
                      stroke: true,
                      color: '#ff5722',
                      weight: 2,
                      opacity: 0.9
                    }
                  })
                }
              ]
            });
            arrowLayers.push(decorator);
          } else {
            const markers = createArrowMarkers(layer);
            if (markers.length > 0) {
              arrowLayers.push(L.layerGroup(markers));
            }
          }
        }
      });

      if (arrowLayers.length > 0) {
        arrowLayerGroup = L.layerGroup(arrowLayers).addTo(map);
      }

      if (pointFeatures.length > 0) {
        addWaypointsFromFeatures(pointFeatures);
      } else {
        updateWaypointsList();
      }

      let bounds = null;
      if (gpxLayerGroup.getLayers().length > 0) {
        bounds = gpxLayerGroup.getBounds();
      }
      waypointLayerGroup.eachLayer((layer) => {
        if (typeof layer.getLatLng !== 'function') {
          return;
        }
        const latlng = layer.getLatLng();
        if (!latlng) {
          return;
        }
        if (!bounds) {
          bounds = L.latLngBounds(latlng, latlng);
        } else {
          bounds.extend(latlng);
        }
      });

      if (bounds && typeof bounds.isValid === 'function' && bounds.isValid()) {
        map.fitBounds(bounds.pad(0.1));
      }

      updateTraceInfo(computeTraceInfo(lineFeatures, geojsonData));
      currentGeojson = geojsonData;
    }

    /**
     * Traite le fichier GPX sélectionné.
     * @param {File} file
     */
    async function handleFile(file) {
      if (!file) {
        return;
      }

      setExportAvailability(false);
      currentGpxDocument = null;
      currentGpxFileName = '';
      currentTraceName = '';
      traceNameSource = '';
      displayTraceName('—', 'default');
      updateTraceInfo(null);

      if (gpxNameInput) {
        gpxNameInput.value = file && file.name ? file.name.replace(/\.gpx$/i, '') : '';
      }

      if (!file.name.toLowerCase().endsWith('.gpx')) {
        showMessage('Veuillez sélectionner un fichier .gpx.', true);
        return;
      }

      const reader = new FileReader();

      reader.onload = async function (event) {
        try {
          showMessage('Chargement de la trace GPX…');
          const parser = new DOMParser();
          const xml = parser.parseFromString(event.target.result, 'application/xml');
          const parseError = xml.querySelector('parsererror');
          if (parseError) {
            throw new Error('Fichier GPX invalide.');
          }

          currentGpxDocument = xml;
          currentGpxFileName = file.name;
          if (currentFilename) {
            currentFilename.textContent = file.name;
          }
          if (traceFileNameLabel) {
            traceFileNameLabel.textContent = file.name;
          }

          const extractedTrace = extractTraceName(xml, file.name);
          currentTraceName = extractedTrace.name;
          traceNameSource = extractedTrace.source;
          if (gpxNameInput) {
            gpxNameInput.value = currentTraceName;
          }
          displayTraceName(currentTraceName, traceNameSource);

          const geojson = convertGpxToGeoJSON(xml);

          if (!geojson || !geojson.features || geojson.features.length === 0) {
            throw new Error('La trace GPX est vide ou invalide.');
          }

          setExportAvailability(true);
          displayGeoJSON(geojson);

          currentElevationData = extractElevationData(geojson, xml);
          let noElevationData = false;
          if (currentElevationData) {
            updateElevationStats(currentElevationData.stats);
            setElevationCollapsed(false);
            requestAnimationFrame(() => renderElevationProfile());
          } else {
            updateElevationStats(null);
            const distanceOnly = calculateDistanceOnly(geojson);
            if (distanceOnly && traceDistanceLabel) {
              traceDistanceLabel.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
              if (profileDistanceValue) {
                profileDistanceValue.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
              }
              if (ariaDistance) {
                ariaDistance.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
              }
            }
            if (traceElevationGainLabel) {
              traceElevationGainLabel.textContent = 'N/A';
            }
            if (traceElevationLossLabel) {
              traceElevationLossLabel.textContent = 'N/A';
            }
            if (traceAltitudeRangeLabel) {
              traceAltitudeRangeLabel.textContent = 'N/A';
            }
            if (profileElevationGainValue) {
              profileElevationGainValue.textContent = 'N/A';
            }
            if (profileElevationLossValue) {
              profileElevationLossValue.textContent = 'N/A';
            }
            if (ariaDPlus) {
              ariaDPlus.textContent = 'N/A';
            }
            if (ariaMin) {
              ariaMin.textContent = 'N/A';
            }
            if (ariaMax) {
              ariaMax.textContent = 'N/A';
            }
            if (elevationProfile) {
              elevationProfile.setAttribute('aria-hidden', 'true');
            }
            noElevationData = true;
          }

          let successMessage = '';
          switch (traceNameSource) {
            case 'gpx-track':
            case 'gpx-route':
            case 'gpx-metadata':
              successMessage = `Trace "<strong>${escapeHtml(currentTraceName)}</strong>" chargée avec succès.`;
              break;
            case 'filename':
              successMessage = `Fichier "<strong>${escapeHtml(currentTraceName)}</strong>" chargé (aucun nom dans le GPX).`;
              break;
            case 'default':
            default:
              successMessage = 'Trace chargée (aucun nom disponible).';
              break;
          }
          if (noElevationData) {
            successMessage += '<br><small>Cette trace ne contient pas de données d\'élévation.</small>';
          }
          showMessage(successMessage, false, true);
        } catch (error) {
          console.error(error);
          showMessage(error.message || 'Impossible de lire ce fichier GPX.', true);
          clearPreviousLayers();
          currentGpxDocument = null;
          currentGpxFileName = '';
          currentTraceName = '';
          traceNameSource = '';
          displayTraceName('—', 'default');
          setExportAvailability(false);
        }
      };

      reader.onerror = function () {
        showMessage('Erreur de lecture du fichier.', true);
        currentGpxDocument = null;
        currentGpxFileName = '';
        currentTraceName = '';
        traceNameSource = '';
        displayTraceName('—', 'default');
        setExportAvailability(false);
      };

      reader.readAsText(file);
    }

    function exportUpdatedGpx() {
      if (!currentGpxDocument) {
        showMessage('Aucune trace GPX à exporter.', true);
        return;
      }

      const xmlDoc = currentGpxDocument.cloneNode(true);
      const gpxRoot = xmlDoc && xmlDoc.documentElement ? xmlDoc.documentElement : null;

      if (!gpxRoot) {
        showMessage('Impossible de préparer le fichier GPX.', true);
        return;
      }

      const existingWaypoints = xmlDoc.querySelectorAll('wpt');
      existingWaypoints.forEach((node) => {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });

      const markers = getWaypointMarkers();
      markers.forEach((marker) => {
        if (typeof marker.getLatLng !== 'function') {
          return;
        }
        const latlng = marker.getLatLng();
        if (!latlng) {
          return;
        }

        const wptNode = xmlDoc.createElement('wpt');
        wptNode.setAttribute('lat', latlng.lat.toFixed(6));
        wptNode.setAttribute('lon', latlng.lng.toFixed(6));

        if (marker.waypointName) {
          const nameNode = xmlDoc.createElement('name');
          nameNode.textContent = marker.waypointName;
          wptNode.appendChild(nameNode);
        }

        gpxRoot.appendChild(wptNode);
      });

      const serializer = new XMLSerializer();
      let gpxString = serializer.serializeToString(xmlDoc);
      if (!gpxString.startsWith('<?xml')) {
        gpxString = `<?xml version="1.0" encoding="UTF-8"?>\n${gpxString}`;
      }

      const blob = new Blob([gpxString], { type: 'application/gpx+xml' });
      const url = URL.createObjectURL(blob);

      const explicitName = gpxNameInput && gpxNameInput.value.trim() ? gpxNameInput.value.trim() : '';
      const baseName =
        explicitName ||
        currentTraceName ||
        (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : '') ||
        'trace';
      const sanitizedName = sanitizeFileName(baseName);
      const downloadName = `${sanitizedName}_with_waypoints.gpx`;

      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = downloadName;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);

      setTimeout(() => {
        URL.revokeObjectURL(url);
      }, 0);

      showMessage(`Fichier "${downloadName}" exporté.`);
    }

    function togglePanel(open) {
      if (!toolsPanel) {
        return;
      }
      const shouldOpen = open !== undefined ? open : !toolsPanel.classList.contains('open');
      if (shouldOpen) {
        toolsPanel.classList.add('open');
        menuToggle?.setAttribute('aria-expanded', 'true');
        if (!backdropElement) {
          backdropElement = document.createElement('div');
          backdropElement.className = 'panel-backdrop';
          backdropElement.addEventListener('click', () => {
            togglePanel(false);
          });
          document.body.appendChild(backdropElement);
        }
      } else {
        toolsPanel.classList.remove('open');
        menuToggle?.setAttribute('aria-expanded', 'false');
        if (backdropElement) {
          backdropElement.remove();
          backdropElement = null;
        }
      }
      map.invalidateSize();
    }

    initPOIManager();

    // Gestion du clic sur le bouton pour ouvrir le sélecteur de fichier
    importButton.addEventListener('click', () => fileInput.click());

    if (exportButton) {
      exportButton.addEventListener('click', exportUpdatedGpx);
    }

    if (menuToggle) {
      menuToggle.addEventListener('click', () => togglePanel(true));
    }

    if (closePanel) {
      closePanel.addEventListener('click', () => togglePanel(false));
    }

    if (elevationHeader && elevationProfile) {
      elevationHeader.addEventListener('click', (event) => {
        if (event.target === elevationCollapseButton) {
          return;
        }
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    if (elevationCollapseButton && elevationProfile) {
      elevationCollapseButton.addEventListener('click', (event) => {
        event.stopPropagation();
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    // Gestion du changement de fichier via le sélecteur
    fileInput.addEventListener('change', (event) => {
      const selectedFile = event.target.files && event.target.files[0];
      handleFile(selectedFile);
      fileInput.value = '';
    });

    if (clearWaypointsButton) {
      clearWaypointsButton.addEventListener('click', () => {
        waypointLayerGroup.clearLayers();
        updateWaypointsList();
      });
    }

    function handleDragEnter(zone, event) {
      event.preventDefault();
      event.stopPropagation();
      zone.classList.add('dragover');
    }

    function handleDragLeave(zone, event) {
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
    }

    function handleDrop(zone, event) {
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
      const files = event.dataTransfer && event.dataTransfer.files;
      if (files && files.length > 0) {
        handleFile(files[0]);
      }
    }

    if (panelDropZone) {
      ['dragenter', 'dragover'].forEach((eventName) => {
        panelDropZone.addEventListener(eventName, (event) => handleDragEnter(panelDropZone, event));
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        panelDropZone.addEventListener(eventName, (event) => {
          if (eventName === 'drop') {
            handleDrop(panelDropZone, event);
          } else {
            handleDragLeave(panelDropZone, event);
          }
        });
      });
    }

    // Gestion du drag & drop sur la carte
    const mapContainer = document.querySelector('#map');
    if (mapContainer) {
      ['dragenter', 'dragover'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
        });
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (eventName === 'drop') {
            const droppedFiles = event.dataTransfer && event.dataTransfer.files;
            if (droppedFiles && droppedFiles.length > 0) {
              handleFile(droppedFiles[0]);
            }
          }
        });
      });
    }

    // Empêche le navigateur d'ouvrir le fichier en dehors de la zone prévue
    document.addEventListener('dragover', (event) => {
      event.preventDefault();
    });
    document.addEventListener('drop', (event) => {
      event.preventDefault();
    });

    // S'assure que la carte s'ajuste lors des changements de taille de fenêtre
    window.addEventListener('resize', () => {
      map.invalidateSize();
      requestAnimationFrame(() => renderElevationProfile());
    });

    // Fermer le panneau avec la touche Échap sur mobile
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        togglePanel(false);
      }
    });
  </script>
</body>
</html>
