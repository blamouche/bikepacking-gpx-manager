<!DOCTYPE html>

<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Cycling Companion - Localisez les points d'int√©r√™t dont vous avez besoin</title>
<!-- ==================== SEO META TAGS ==================== -->

<!-- Description principale -->
<meta name="description" content="Planifiez vos sorties bikepacking avec Cycling Companion : importez vos traces GPX, visualisez le profil d'√©l√©vation, ajoutez des waypoints et trouvez les points d'int√©r√™t (eau, nourriture, h√©bergement) le long de votre parcours.">

<!-- Mots-cl√©s -->
<meta name="keywords" content="bikepacking, cyclotourisme, planification itin√©raire v√©lo, trace GPX, profil altim√©trique, waypoints, points d'int√©r√™t cyclisme, carte v√©lo interactive, h√©bergement cycliste, bivouac v√©lo, gravel bike, voyage √† v√©lo">

<!-- Auteur -->
<meta name="author" content="Benoit Lamouche">

<!-- Robots -->
<meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">

<!-- Langue -->
<meta name="language" content="fr">
<link rel="alternate" hreflang="fr" href="https://blamouche.github.io/bikepacking-gpx-manager/">
<link rel="alternate" hreflang="x-default" href="https://blamouche.github.io/bikepacking-gpx-manager/">

<!-- URL Canonique -->
<link rel="canonical" href="https://blamouche.github.io/bikepacking-gpx-manager/">

<!-- G√©olocalisation -->
<meta name="geo.region" content="FR">
<meta name="geo.placename" content="France">

<!-- ==================== OPEN GRAPH (Facebook, LinkedIn) ==================== -->

<meta property="og:type" content="website">
<meta property="og:site_name" content="Cycling Companion">
<meta property="og:title" content="Cycling Companion - Planificateur d'itin√©raires bikepacking et cyclotourisme">
<meta property="og:description" content="Outil gratuit de planification pour vos aventures √† v√©lo : importez vos traces GPX, visualisez le d√©nivel√©, ajoutez des waypoints et trouvez facilement les points d'eau, restaurants et h√©bergements le long de votre parcours.">
<meta property="og:url" content="https://blamouche.github.io/bikepacking-gpx-manager/">
<meta property="og:image" content="https://blamouche.github.io/bikepacking-gpx-manager/img/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:image:alt" content="Interface de Cycling Companion montrant une carte interactive avec trace GPX et points d'int√©r√™t">
<meta property="og:image:type" content="image/png">
<meta property="og:locale" content="fr_FR">

<!-- ==================== TWITTER CARDS ==================== -->

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@blamouche">
<meta name="twitter:creator" content="@blamouche">
<meta name="twitter:title" content="Cycling Companion - Planificateur bikepacking gratuit">
<meta name="twitter:description" content="Planifiez vos sorties v√©lo : traces GPX, profil d'√©l√©vation, waypoints et POI (eau, nourriture, h√©bergement) sur carte interactive.">
<meta name="twitter:image" content="https://blamouche.github.io/bikepacking-gpx-manager/img/twitter-card.png">
<meta name="twitter:image:alt" content="Carte cyclable avec trace GPX et points d'int√©r√™t">

<!-- ==================== FAVICONS & IC√îNES ==================== -->

<!-- Favicons standards -->
<link rel="icon" type="image/png" sizes="16x16" href="/bikepacking-gpx-manager/img/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/bikepacking-gpx-manager/img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="/bikepacking-gpx-manager/img/icon-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/bikepacking-gpx-manager/img/icon-512x512.png">

<!-- Apple Touch Icon -->
<link rel="apple-touch-icon" sizes="180x180" href="/bikepacking-gpx-manager/img/apple-touch-icon.png">

<!-- Web App Manifest (PWA) -->
<link rel="manifest" href="/bikepacking-gpx-manager/site.webmanifest">

<!-- Microsoft Tiles -->
<meta name="msapplication-TileColor" content="#0066FF">
<meta name="msapplication-TileImage" content="/bikepacking-gpx-manager/img/icon-512x512.png">
<meta name="msapplication-config" content="/bikepacking-gpx-manager/browserconfig.xml">

<!-- Theme Color -->
<meta name="theme-color" content="#0066FF">

<!-- Apple Web App -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Cycling Companion">

<!-- Mobile Web App -->
<meta name="mobile-web-app-capable" content="yes">

<!-- ==================== PERFORMANCE & PRECONNECT ==================== -->

<!-- Preconnect pour les ressources externes -->
<link rel="preconnect" href="https://unpkg.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com">
<link rel="dns-prefetch" href="https://tile.openstreetmap.org">
<link rel="dns-prefetch" href="https://tile-cyclosm.openstreetmap.fr">
<link rel="dns-prefetch" href="https://overpass-api.de">

<!-- Preload des ressources critiques Leaflet -->
<link rel="preload" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" as="style">
<link rel="preload" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" as="script">

<!-- ==================== SCHEMA.ORG JSON-LD ==================== -->

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebApplication",
      "name": "Cycling Companion",
      "alternateName": "Bikepacking Helper",
      "url": "https://blamouche.github.io/bikepacking-gpx-manager/",
      "description": "Application web gratuite de planification d'itin√©raires de bikepacking et cyclotourisme avec visualisation de traces GPX, profil d'√©l√©vation interactif, gestion de waypoints et recherche de points d'int√©r√™t (eau potable, alimentation, h√©bergement, r√©paration v√©lo).",
      "applicationCategory": "LifestyleApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "EUR"
      },
      "featureList": [
        "Import et visualisation de traces GPX",
        "Profil d'√©l√©vation interactif avec statistiques (D+, D-, distance)",
        "Cr√©ation et gestion de waypoints personnalis√©s",
        "Export GPX avec waypoints",
        "Recherche de points d'int√©r√™t : eau potable, alimentation, h√©bergement, services v√©lo",
        "Fond de carte multiple : CyclOSM, OpenStreetMap, OpenTopoMap, satellite",
        "G√©n√©ration de roadbook d√©taill√©",
        "G√©olocalisation en temps r√©el",
        "Sauvegarde automatique locale",
        "100% gratuit et sans publicit√©"
      ],
      "screenshot": "https://blamouche.github.io/bikepacking-gpx-manager/img/screenshot.png",
      "image": "https://blamouche.github.io/bikepacking-gpx-manager/img/logo.png",
      "author": {
        "@type": "Person",
        "name": "Benoit Lamouche",
        "url": "https://lamouche.fr",
        "sameAs": [
          "https://twitter.com/blamouche",
          "https://github.com/blamouche"
        ]
      },
      "inLanguage": "fr-FR",
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "softwareVersion": "1.0",
      "datePublished": "2025-01-15",
      "dateModified": "2025-01-15",
      "license": "https://opensource.org/licenses/MIT"
    },
    {
      "@type": "BreadcrumbList",
      "itemListElement": [
        {
          "@type": "ListItem",
          "position": 1,
          "name": "Accueil",
          "item": "https://blamouche.github.io/bikepacking-gpx-manager/"
        }
      ]
    },
    {
      "@type": "Organization",
      "name": "Cycling Companion",
      "url": "https://blamouche.github.io/bikepacking-gpx-manager/",
      "logo": "https://blamouche.github.io/bikepacking-gpx-manager/img/logo.png",
      "sameAs": [
        "https://twitter.com/blamouche",
        "https://github.com/blamouche",
        "https://lamouche.fr"
      ]
    },
    {
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "Cycling Companion est-il gratuit ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Oui, Cycling Companion est 100% gratuit et open source. Toutes les fonctionnalit√©s sont accessibles sans inscription ni abonnement."
          }
        },
        {
          "@type": "Question",
          "name": "Quels formats de fichiers sont support√©s ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "L'application supporte les fichiers GPX standard, contenant des traces (tracks), des routes ou des waypoints. Vous pouvez importer des fichiers cr√©√©s avec n'importe quelle application de navigation GPS (Komoot, Strava, Garmin, Wahoo, etc.)."
          }
        },
        {
          "@type": "Question",
          "name": "Mes donn√©es sont-elles sauvegard√©es ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Oui, vos traces et waypoints sont automatiquement sauvegard√©s localement dans votre navigateur. Aucune donn√©e n'est envoy√©e √† un serveur externe, garantissant votre confidentialit√© totale."
          }
        },
        {
          "@type": "Question",
          "name": "Quels types de points d'int√©r√™t puis-je trouver ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "L'application vous permet de localiser : points d'eau potable, cimeti√®res (source d'eau), supermarch√©s, √©piceries, restaurants, caf√©s, stations de r√©paration v√©lo, magasins de v√©lo, campings, bivouacs, refuges, h√¥tels, auberges, toilettes publiques, douches, pharmacies et h√¥pitaux."
          }
        },
        {
          "@type": "Question",
          "name": "L'application fonctionne-t-elle hors ligne ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Une fois charg√©e, l'application peut fonctionner partiellement hors ligne avec vos traces d√©j√† import√©es. Cependant, le chargement des cartes et la recherche de POI n√©cessitent une connexion internet."
          }
        },
        {
          "@type": "Question",
          "name": "Comment exporter mes traces avec les waypoints ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Cliquez sur le bouton Exporter, choisissez d'inclure ou non vos waypoints, et t√©l√©chargez le fichier GPX. Votre trace enrichie sera compatible avec tous les GPS et applications de navigation."
          }
        }
      ]
    }
  ]
}
</script>
<!-- Leaflet CSS -->
<link crossorigin="" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" rel="stylesheet"/>
<style>
    :root {
      --color-primary: #1976d2;
      --color-primary-hover: #1565c0;
      --color-primary-light: rgba(25, 118, 210, 0.12);
      --color-secondary: #f5f5f5;
      --color-secondary-hover: #eeeeee;
      --color-danger: #f44336;
      --color-background: #ffffff;
      --color-background-alt: #f8f9fa;
      --color-text-primary: #212121;
      --color-text-secondary: #424242;
      --color-text-muted: #757575;
      --color-border: #e0e0e0;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--color-background-alt);
      color: var(--color-text-primary);
    }

    body {
      overflow: hidden;
    }

    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .hidden {
      display: none !important;
    }

    .tools-panel {
      width: 420px;
      min-width: 420px;
      height: 100vh;
      background: var(--color-background);
      border-right: 1px solid var(--color-border);
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .panel-header {
      padding: 1.5rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .panel-title {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem 1.5rem;
    }

    .panel-section {
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid var(--color-border);
    }

    .panel-section:last-child {
      border-bottom: none;
      padding-bottom: 0;
      margin-bottom: 0;
    }

    /* Calques POI */
    .layer-section {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .layer-global-actions {
      display: flex;
      gap: 0.5rem;
    }

    .layer-global-actions .btn {
      flex: 1;
    }

    .layer-presets {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      /* Espacement vertical : marge au-dessus et au-dessous du bloc */
      margin: 0.75rem 0;
    }

    .layer-presets label {
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .preset-select {
      flex: 1;
      padding: 0.45rem 0.6rem;
      border-radius: 6px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
      background: #fff;
    }

    .layer-group {
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: #fff;
      overflow: hidden;
      margin-bottom: 0.5rem;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
    }

    .layer-group-header {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem;
      background: var(--color-background-alt);
      border: none;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }

    .layer-group-header:hover {
      background: rgba(0, 0, 0, 0.03);
    }

    .layer-group-icon {
      font-size: 1.1rem;
    }

    .layer-group-label {
      flex: 1;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--color-text-primary);
      text-align: left;
    }

    .layer-group-count {
      font-size: 0.85rem;
      color: var(--color-text-muted);
    }

    .layer-group-chevron {
      font-size: 0.8rem;
      color: var(--color-text-muted);
      transition: transform 0.3s ease;
    }

    .layer-group.expanded .layer-group-chevron {
      transform: rotate(180deg);
    }

    .layer-group-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
      padding: 0 0.75rem;
    }

    .layer-group.expanded .layer-group-content {
      max-height: 1000px;
      padding: 0.75rem;
    }

    .layer-toggle {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
      user-select: none;
      padding: 0.4rem 0.25rem;
    }

    .layer-toggle + .layer-toggle {
      border-top: 1px dashed rgba(0, 0, 0, 0.05);
    }

    .toggle-input {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      background: #ccc;
      border-radius: 12px;
      transition: background 0.3s ease;
      flex-shrink: 0;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      top: 3px;
      left: 3px;
      transition: transform 0.3s ease;
    }

    .toggle-input:checked + .toggle-switch {
      background: var(--color-primary);
    }

    .toggle-input:checked + .toggle-switch::after {
      transform: translateX(20px);
    }

    .toggle-input:focus + .toggle-switch {
      outline: 2px solid var(--color-primary);
      outline-offset: 2px;
    }

    .toggle-text {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--color-text-primary);
      flex: 1;
    }

    .toggle-icon {
      font-size: 1.1rem;
    }

    .toggle-count {
      font-size: 0.85rem;
      color: var(--color-text-muted);
      font-weight: 600;
    }

    .layer-indicators {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .layer-loading,
    .layer-error,
    .layer-info {
      padding: 0.6rem 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      display: none;
    }

    .layer-loading {
      background: #e3f2fd;
      color: #1976d2;
      align-items: center;
      gap: 0.5rem;
    }

    .layer-error {
      background: #ffebee;
      color: #c62828;
      border: 1px solid rgba(198, 40, 40, 0.2);
    }

    .layer-info {
      background: #fff8e1;
      color: #f57f17;
      border: 1px solid rgba(245, 127, 23, 0.2);
    }

    .layer-loading .loading-spinner {
      display: inline-block;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .section-title {
      margin: 0 0 1rem 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 1.75rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: var(--color-primary);
      color: #fff;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      width: 100%;
      border: none;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      transition: box-shadow 0.2s ease, transform 0.1s ease;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    .btn-primary {
      background: var(--color-primary);
      color: #ffffff;
    }

    .btn-primary:not(:disabled):hover,
    .btn-primary:not(:disabled):focus {
      background: var(--color-primary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-secondary {
      background: var(--color-secondary);
      color: var(--color-text-secondary);
    }

    .btn-secondary:hover,
    .btn-secondary:focus {
      background: var(--color-secondary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-small {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
    }

    .btn-icon-small {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 1rem;
      padding: 0.25rem;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .btn-icon-small:hover,
    .btn-icon-small:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .section-title .section-icon {
      margin-right: 0.4rem;
      font-size: 1.1rem;
    }

    .gpx-section {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .gpx-empty-state,
    .gpx-loaded-state {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .gpx-loaded-state.dragover,
    .gpx-import-zone.dragover {
      box-shadow: 0 0 0 2px var(--color-primary-light, rgba(25, 118, 210, 0.2));
    }

    .gpx-import-zone {
      padding: 1.5rem;
      border: 2px dashed var(--color-border);
      border-radius: 12px;
      background: var(--color-background-alt);
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      color: var(--color-text-secondary);
    }

    .gpx-import-zone .gpx-import-icon {
      font-size: 1.75rem;
    }

    .gpx-import-zone .gpx-import-title {
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .gpx-import-zone .gpx-import-hint {
      font-size: 0.9rem;
      color: var(--color-text-muted);
    }

    .gpx-import-zone:hover,
    .gpx-import-zone:focus {
      border-color: var(--color-primary);
      background: rgba(25, 118, 210, 0.08);
      color: var(--color-text-primary);
    }

    .gpx-import-zone.dragover {
      border-color: var(--color-primary);
      background: var(--color-primary-light, rgba(25, 118, 210, 0.12));
      transform: scale(1.02);
      color: var(--color-text-primary);
    }

    .trace-summary {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      background: var(--color-background-alt);
      border: 1px solid var(--color-border);
      border-radius: 10px;
      padding: 0.75rem 1rem;
    }

    .trace-summary .trace-filename {
      font-weight: 600;
      color: var(--color-text-primary);
      word-break: break-word;
    }

    .trace-summary .trace-stats {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--color-text-muted);
      font-size: 0.875rem;
    }

    .trace-summary .trace-stats .icon {
      font-size: 1rem;
    }

    .gpx-actions {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.375rem;
    }

    .gpx-action-btn {
      padding: 0.5rem 0.375rem;
      font-size: 0.8125rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.125rem;
      border: 1px solid var(--color-border);
      border-radius: 10px;
      background: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .gpx-action-btn:hover,
    .gpx-action-btn:focus {
      border-color: var(--color-primary);
      color: var(--color-primary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }

    .gpx-action-btn .icon {
      font-size: 1.125rem;
      line-height: 1;
    }

    .gpx-action-btn .label {
      font-size: 0.75rem;
      line-height: 1;
    }

    .gpx-action-btn--danger {
      border-color: rgba(244, 67, 54, 0.35);
      color: var(--color-danger);
    }

    .gpx-action-btn--danger:hover,
    .gpx-action-btn--danger:focus {
      border-color: var(--color-danger);
      color: var(--color-danger);
      box-shadow: 0 2px 4px rgba(244, 67, 54, 0.15);
    }

    .gpx-action-btn.is-confirm {
      border-color: var(--color-danger);
      background: rgba(244, 67, 54, 0.08);
      color: var(--color-danger);
      box-shadow: 0 2px 6px rgba(244, 67, 54, 0.2);
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(33, 33, 33, 0.4);
      backdrop-filter: blur(2px);
      z-index: 1000;
    }

    .export-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--color-background);
      border-radius: 14px;
      box-shadow: var(--shadow-md);
      width: min(420px, 90vw);
      z-index: 1001;
      display: flex;
      flex-direction: column;
      max-height: 90vh;
    }

    .export-modal.hidden,
    .modal-backdrop.hidden {
      display: none;
    }

    .export-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--color-border);
    }

    .export-modal-header h4 {
      margin: 0;
      font-size: 1.05rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .export-modal-content {
      padding: 1rem 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow-y: auto;
    }

    .export-modal-content label {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .export-modal-content input[type="text"] {
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .checkbox-label input {
      width: 1.1rem;
      height: 1.1rem;
    }

    .export-preview {
      padding: 0.75rem;
      border-radius: 8px;
      background: var(--color-background-alt);
      border: 1px dashed var(--color-border);
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .export-modal-actions {
      padding: 0.9rem 1.25rem;
      border-top: 1px solid var(--color-border);
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    @media (max-width: 600px) {
      .gpx-actions {
        grid-template-columns: repeat(2, 1fr);
      }

      .gpx-action-btn--export {
        grid-column: 1 / -1;
      }
    }

    @media (max-width: 480px) {
      .export-modal {
        inset: auto 0 0 0;
        transform: none;
        margin: 0.75rem;
        width: auto;
      }
    }

    .waypoints-list {
      max-height: 240px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .waypoint-item {
      display: grid;
      grid-template-columns: auto 1fr auto auto;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.6rem;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: #fff;
      box-shadow: var(--shadow-sm);
    }

    .waypoint-popup {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 200px;
    }

    .waypoint-popup label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .waypoint-popup input {
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
    }

    .waypoint-popup-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .waypoint-popup-buttons button {
      flex: 1;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: var(--color-secondary);
    }

    .waypoint-popup-buttons button[data-action="save"] {
      background: var(--color-primary);
      color: #fff;
    }

    .waypoint-popup-buttons button[data-action="delete"] {
      background: var(--color-danger);
      color: #fff;
    }

    .waypoint-name {
      font-size: 0.95rem;
      color: var(--color-text-primary);
    }

    .waypoint-icon {
      font-size: 1.1rem;
    }

    .info-list {
      margin: 0;
      display: grid;
      grid-template-columns: auto 1fr;
      row-gap: 0.75rem;
      column-gap: 1rem;
      font-size: 0.95rem;
    }

    .info-list dt {
      font-weight: 600;
      color: var(--color-text-secondary);
    }

    .info-list dd {
      margin: 0;
      color: var(--color-text-primary);
    }

    .mini-elevation-profile {
      margin-top: 1rem;
      padding: 0.75rem;
      background: var(--color-background-alt);
      border: 1px solid var(--color-border-light);
      border-radius: var(--radius-md);
    }

    .mini-profile-title {
      margin: 0 0 0.5rem 0;
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--color-text-secondary);
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    .mini-profile-canvas-wrapper {
      position: relative;
      width: 100%;
      height: 120px;
      background: var(--color-background);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    #mini-elevation-canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: default;
    }

    @media (max-width: 767px) {
      .mini-profile-canvas-wrapper {
        height: 100px;
      }
    }

    .text-muted {
      color: var(--color-text-muted);
    }

    .trace-name {
      font-weight: 600;
      font-size: 1rem;
      word-break: break-word;
    }

    .trace-name--gpx-track,
    .trace-name--gpx-route,
    .trace-name--gpx-metadata {
      color: var(--color-primary);
    }

    .trace-name--filename {
      color: var(--color-text-muted);
      font-style: italic;
    }

    .trace-name--default {
      color: #9e9e9e;
      font-style: italic;
    }

    .file-name {
      font-family: "Courier New", Courier, monospace;
      font-size: 0.9rem;
      color: var(--color-text-muted);
      word-break: break-all;
    }

    .trace-name-help {
      font-size: 1rem;
      cursor: help;
      color: var(--color-text-muted);
      display: inline-block;
      margin-left: 0.35rem;
    }

    .stat-highlight {
      font-weight: 600;
      color: var(--color-primary);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .elevation-profile {
      position: relative;
      width: 100%;
      background: var(--color-background);
      border-top: 2px solid var(--color-primary);
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
      display: none;
      flex-direction: column;
      z-index: 500;
      transition: height 0.3s ease;
      height: 200px;
    }

    .elevation-profile.visible {
      display: flex;
    }

    .elevation-profile.collapsed {
      height: 40px;
    }

    .elevation-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.75rem 1rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      cursor: pointer;
      user-select: none;
      min-height: 40px;
    }

    .elevation-header:hover {
      background: rgba(0, 0, 0, 0.02);
    }

    .elevation-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .elevation-title h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .elevation-icon {
      font-size: 1.25rem;
    }

    .elevation-stats-quick {
      display: flex;
      gap: 1.5rem;
      flex: 1;
      justify-content: center;
    }

    .stat-item {
      display: flex;
      gap: 0.25rem;
      font-size: 0.9rem;
    }

    .stat-label {
      color: var(--color-text-muted);
    }

    .stat-value {
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .btn-collapse {
      border: none;
      background: transparent;
      font-size: 1rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .btn-collapse:hover,
    .btn-collapse:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .elevation-profile.collapsed .btn-collapse span {
      transform: rotate(180deg);
      display: inline-block;
    }

    .elevation-content {
      flex: 1;
      position: relative;
      overflow: hidden;
      padding: 1rem;
      display: none;
    }

    .elevation-profile:not(.collapsed) .elevation-content {
      display: block;
    }

    #elevation-canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .elevation-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .tooltip-row {
      display: flex;
      gap: 0.5rem;
      white-space: nowrap;
    }

    /* Marqueurs POI OSM */
    .poi-marker {
      border: none !important;
      background: transparent !important;
    }

    .poi-marker-inner {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      border: 2px solid #fff;
      transition: transform 0.2s ease;
    }

    .poi-marker:hover .poi-marker-inner {
      transform: scale(1.15);
    }

    .poi-marker-icon {
      font-size: 14px;
      line-height: 1;
      filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
    }

    .poi-popup-container .leaflet-popup-content-wrapper {
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .poi-popup {
      font-family: inherit;
      min-width: 220px;
    }

    .poi-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--color-border);
      margin-bottom: 0.75rem;
    }

    .poi-header .poi-icon {
      font-size: 1.5rem;
    }

    .poi-name {
      font-size: 1rem;
      color: var(--color-text-primary);
    }

    .poi-details {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .poi-row {
      display: flex;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .poi-label {
      color: var(--color-text-muted);
      min-width: 70px;
    }

    .poi-value {
      color: var(--color-text-primary);
      font-weight: 500;
    }

    .poi-footer {
      padding-top: 0.5rem;
      border-top: 1px solid var(--color-border);
    }

    .poi-footer a {
      color: var(--color-primary);
      text-decoration: none;
      font-size: 0.85rem;
    }

    .poi-footer a:hover {
      text-decoration: underline;
    }

    .tooltip-label {
      color: rgba(255, 255, 255, 0.7);
    }

    .tooltip-value {
      font-weight: 600;
    }

    @media (max-width: 767px) {
      .layer-global-actions {
        flex-direction: column;
      }

      .layer-presets {
        flex-direction: column;
        align-items: stretch;
        gap: 0.35rem;
      }

      .layer-presets label {
        font-size: 0.85rem;
      }

      .elevation-profile {
        height: 150px;
      }

      .elevation-stats-quick {
        display: none;
      }

      .elevation-header {
        padding: 0.5rem 0.75rem;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .elevation-stats-quick {
        gap: 1rem;
        font-size: 0.85rem;
      }
    }

    .panel-messages {
      padding: 0;
    }

    .message {
      min-height: 3rem;
      padding: 0.75rem 1rem;
      border-radius: 6px;
      border: 1px solid transparent;
      background: #f1f8ff;
      color: #0d47a1;
    }

    .message.hidden {
      display: none;
    }

    .message.error {
      background: #ffebee;
      border-color: rgba(244, 67, 54, 0.3);
      color: #c62828;
    }

    .map-container {
      flex: 1;
      position: relative;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .map-main {
      position: relative;
      flex: 1;
      min-height: 0;
    }

    .poi-refresh-button {
      position: fixed;
      z-index: 900;
      display: none;
      align-items: center;
      gap: 0.4rem;
      padding: 0.6rem 0.85rem;
      background: rgba(25, 118, 210, 0.95);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      box-shadow: var(--shadow-md);
      cursor: pointer;
      transition: background 0.2s ease, transform 0.1s ease;
      top: 90% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: min(90vw, 1000px);}


    .poi-refresh-button:hover,
    .poi-refresh-button:focus {
      background: rgba(21, 101, 192, 0.95);
      transform: translateX(-50%) translateY(-1px);
      outline: none;
    }

    .poi-refresh-button span {
      /*display: inline-flex;*/
      display:block;
      align-items: center;
      justify-content: center;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .btn-menu {
      display: none;
      position: absolute;
      top: 1rem;
      left: 1rem;
      z-index: 1000;
      background: #fff;
      border: 2px solid var(--color-border);
      border-radius: 6px;
      padding: 0.6rem 0.8rem;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: var(--shadow-md);
    }

    .btn-close-panel {
      border: none;
      background: transparent;
      font-size: 1.25rem;
      cursor: pointer;
      border-radius: 4px;
      padding: 0.2rem 0.4rem;
    }

    .btn-close-panel:hover,
    .btn-close-panel:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .panel-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      z-index: 1500;
      opacity: 0;
      animation: fadeIn 0.2s forwards;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    @media (max-width: 767px) {
      .tools-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 90vw;
        max-width: 420px;
        z-index: 2000;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }

      .tools-panel.open {
        transform: translateX(0);
      }

      .btn-menu {
        display: block;
      }
    }

    @media (min-width: 768px) {
      .btn-close-panel {
        display: none;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .tools-panel {
        width: 280px;
        min-width: 280px;
      }
    }
  
/* === Layer indicators overrides merged === */

/* === Waypoint Markers === */
.waypoint-marker {
  border: none !important;
  background: transparent !important;
}

.waypoint-marker-inner {
  width: 28px;
  height: 36px;
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
  filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
}

.waypoint-marker-pin {
  width: 28px;
  height: 28px;
  background: #FF5722;
  border-radius: 50% 50% 50% 0;
  transform: rotate(-45deg);
  border: 3px solid #FFFFFF;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.waypoint-marker-icon {
  transform: rotate(45deg);
  font-size: 14px;
  line-height: 1;
}

.waypoint-marker:hover .waypoint-marker-inner {
  transform: scale(1.15) translateY(-3px);
  filter: drop-shadow(0 6px 12px rgba(255, 87, 34, 0.5));
}

@keyframes waypointAppear {
  from { opacity: 0; transform: scale(0.3) translateY(10px); }
  to   { opacity: 1; transform: scale(1) translateY(0); }
}

.waypoint-marker-inner {
  animation: waypointAppear 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}



/* === Mini-cartes d'aper√ßu pour styles === */
.map-style-section .map-style-options {
  display: grid;
  grid-template-columns: 1fr;
  gap: 0.5rem;
}
.map-style-section .map-style-option {
  display: grid;
  grid-template-columns: 120px 1fr;
  align-items: center;
  column-gap: 0.75rem;
  padding: 0.5rem;
}
.map-style-thumb {
  width: 120px;
  height: 80px;
  border-radius: var(--radius-md, 8px);
  overflow: hidden;
  border: 1px solid var(--color-border-light, #E5E5EA);
  box-shadow: var(--shadow-sm, 0 1px 2px rgba(0,0,0,0.04));
}
.map-style-thumb-inner {
  width: 100%;
  height: 100%;
  pointer-events: none; /* clics passent au bouton */
}
.map-style-label-text {
  font-size: 0.9rem;
  font-weight: 500;
}
.map-style-option.active .map-style-thumb {
  outline: 2px solid var(--color-primary, #0066FF);
  outline-offset: -2px;
}
@media (max-width: 480px) {
  .map-style-section .map-style-option {
    grid-template-columns: 100px 1fr;
  }
  .map-style-thumb { width: 100px; height: 66px; }
}


/* === Vignettes pleine largeur & responsives === */
.map-style-section .map-style-options {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.map-style-section .map-style-option {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 0.5rem;
  padding: 0.5rem;
}
.map-style-thumb {
  width: 100%;
  height: 160px;
  border-radius: var(--radius-md, 8px);
  overflow: hidden;
  border: 1px solid var(--color-border-light, #E5E5EA);
  box-shadow: var(--shadow-sm, 0 1px 2px rgba(0,0,0,0.04));
}
.map-style-thumb-inner {
  width: 100%;
  height: 100%;
  pointer-events: none;
}
@media (min-width: 1024px) {
  .map-style-thumb { height: 180px; }
}
@media (max-width: 480px) {
  .map-style-thumb { height: 140px; }
}


/* === Map Style Options: Look & Feel aligned with app === */
.map-style-section .map-style-option {
  position: relative;
  background: var(--color-background-elevated, #FFFFFF);
  border: 1px solid var(--color-border-light, #F2F2F7);
  border-radius: var(--radius-lg, 12px);
  padding: 0.625rem;
  box-shadow: var(--shadow-sm, 0 1px 2px rgba(0,0,0,0.04));
  transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease, background 0.2s ease;
}

.map-style-section .map-style-option:hover {
  transform: translateY(-1px);
  box-shadow: var(--shadow-md, 0 4px 12px rgba(0,0,0,0.08));
  border-color: var(--color-border, #E5E5EA);
  background: var(--color-background, #FFFFFF);
}

.map-style-section .map-style-option:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm, 0 1px 2px rgba(0,0,0,0.04));
}

.map-style-section .map-style-option:focus-visible {
  outline: 2px solid var(--color-primary, #0066FF);
  outline-offset: 2px;
}

/* label zone */
.map-style-section .map-style-label-text {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 0.93rem;
  font-weight: 600;
  color: var(--color-text-primary, #1A1A1A);
}

/* Tag "par d√©faut" sur Voyager */
#map-style-section .map-style-option[data-style="voyager"] .map-style-label-text::after {
  content: "Par d√©faut";
  font-size: 0.75rem;
  font-weight: 700;
  color: var(--color-primary, #0066FF);
  background: var(--color-primary-light, #E6F0FF);
  padding: 0.125rem 0.5rem;
  border-radius: 999px;
  border: 1px solid rgba(0,102,255,0.25);
}

/* Active card state: subtle elevation + border accent + thumb outline already present */
.map-style-section .map-style-option.active {
  border-color: rgba(0, 102, 255, 0.35);
  box-shadow: 0 6px 16px rgba(0, 102, 255, 0.12);
  background: linear-gradient(0deg, rgba(0,102,255,0.022), rgba(0,102,255,0.022)), var(--color-background-elevated, #FFFFFF);
}

.map-style-section .map-style-option.active .map-style-label-text {
  color: var(--color-primary, #0066FF);
}

/* Thumb polish */
.map-style-thumb {
  border-radius: var(--radius-md, 8px);
  overflow: hidden;
  border: 1px solid var(--color-border-light, #E5E5EA);
  background: var(--color-background, #FFFFFF);
}

.map-style-option.active .map-style-thumb {
  border-color: rgba(0, 102, 255, 0.35);
  box-shadow: 0 2px 10px rgba(0,102,255,0.15);
}

/* Small "chevron" affordance */
.map-style-section .map-style-option::after {
  content: "‚Ä∫";
  position: absolute;
  right: 0.75rem;
  bottom: 0.5rem;
  font-size: 1rem;
  color: var(--color-text-muted, #8E8E93);
  opacity: 0.6;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

.map-style-section .map-style-option:hover::after {
  transform: translateX(2px);
  opacity: 0.9;
}

/* Compact spacing on narrow screens */
@media (max-width: 480px) {
  .map-style-section .map-style-option {
    padding: 0.5rem;
    border-radius: var(--radius-md, 8px);
  }
  .map-style-section .map-style-label-text {
    font-size: 0.9rem;
  }
}

/* Dark mode refinement */
/*
@media (prefers-color-scheme: dark) {
  .map-style-section .map-style-option {
    background: rgba(44,44,46,0.9);
    border-color: rgba(255,255,255,0.08);
    box-shadow: none;
  }
  .map-style-section .map-style-option:hover {
    background: rgba(44,44,46,1);
    border-color: rgba(255,255,255,0.14);
    box-shadow: 0 6px 16px rgba(0,0,0,0.45);
  }
  .map-style-section .map-style-option.active {
    border-color: rgba(10,132,255,0.45);
    background: linear-gradient(0deg, rgba(10,132,255,0.08), rgba(10,132,255,0.08)), rgba(44,44,46,1);
    box-shadow: 0 8px 20px rgba(10,132,255,0.25);
  }
  .map-style-section .map-style-option::after {
    color: rgba(235,235,245,0.6);
  }
  #map-style-section .map-style-option[data-style="voyager"] .map-style-label-text::after {
    color: #0A84FF;
    background: rgba(10,132,255,0.15);
    border-color: rgba(10,132,255,0.35);
  }
}
*/

</style>
<style>
/* ==================== DESIGN MODERNE - VARIABLES AM√âLIOR√âES ==================== */
:root {
  --color-geo: #2196F3;
  --color-trace: #FF6B35;
  --color-map: #4CAF50;
  --color-poi: #9C27B0;
  --color-waypoint: #E91E63;
  --color-roadbook: #1565C0;
  --color-primary: #0066FF;
  --color-primary-hover: #0052CC;
  --color-primary-light: #E3F2FD;
  --color-background: #FFFFFF;
  --color-background-alt: #F5F7FA;
  --color-background-elevated: #FFFFFF;
  --color-surface: #FAFBFC;
  --color-text-primary: #1A202C;
  --color-text-secondary: #4A5568;
  --color-text-muted: #718096;
  --color-border: #E2E8F0;
  --color-border-light: #EDF2F7;
  --shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-sm: 0 2px 4px 0 rgba(0, 0, 0, 0.06);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.08);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 0.75rem;
  --spacing-lg: 1rem;
  --spacing-xl: 1.5rem;
  --spacing-2xl: 2rem;
  --radius-sm: 6px;
  --radius-md: 10px;
  --radius-lg: 14px;
  --radius-xl: 18px;
}

.tools-panel {
  background: linear-gradient(to bottom, #FFFFFF 0%, #FAFBFC 100%);
  border-right: 1px solid var(--color-border-light);
  box-shadow: 2px 0 12px rgba(0, 0, 0, 0.04);
}

.panel-header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 1.5rem;
  border-bottom: none;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
}

.panel-title {
  color: white;
  font-size: 1.5rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.panel-title::before {
  content: "üß∞";
  font-size: 1.75rem;
  line-height: 1;
}

.btn-close-panel {
  color: rgba(255, 255, 255, 0.9);
  font-size: 1.5rem;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.btn-close-panel:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: rotate(90deg);
}

.panel-content {
  padding: 1rem;
  background: transparent;
}

.panel-section {
  background: var(--color-background);
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-lg);
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-sm);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
  animation: fadeIn 0.3s ease-out;
}

.panel-section::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  transition: width 0.3s ease;
}

.panel-section:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.panel-section:hover::before {
  width: 6px;
}

#geolocation-section::before {
  background: linear-gradient(to bottom, var(--color-geo), #1976D2);
}

.gpx-section::before {
  background: linear-gradient(to bottom, var(--color-trace), #E64A19);
}

#map-style-section::before {
  background: linear-gradient(to bottom, var(--color-map), #388E3C);
}

#layers-section::before {
  background: linear-gradient(to bottom, var(--color-poi), #7B1FA2);
}

#waypoints-section::before {
  background: linear-gradient(to bottom, var(--color-waypoint), #C2185B);
}

#roadbook-section::before {
  background: linear-gradient(to bottom, var(--color-roadbook), #0D47A1);
}

#trace-info-section::before {
  background: linear-gradient(to bottom, #FF9800, #F57C00);
}

.section-title {
  font-size: 0.875rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--color-text-primary);
  margin: 0 0 1rem 0;
  display: flex;
  align-items: center;
  gap: 0.625rem;
  padding-bottom: 0.75rem;
  border-bottom: 2px solid var(--color-border-light);
}

.section-title .section-icon {
  font-size: 1.25rem;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
}

#geolocation-section .section-title { color: var(--color-geo); }
.gpx-section .section-title { color: var(--color-trace); }
#map-style-section .section-title { color: var(--color-map); }
#layers-section .section-title { color: var(--color-poi); }
#waypoints-section .section-title { color: var(--color-waypoint); }
#roadbook-section .section-title { color: var(--color-roadbook); }
#trace-info-section .section-title { color: #FF9800; }

.btn {
  border-radius: var(--radius-md);
  font-weight: 600;
  font-size: 0.9rem;
  padding: 0.75rem 1.25rem;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  border: none;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  position: relative;
  overflow: hidden;
}

.btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
  transform: translateX(-100%);
  transition: transform 0.6s;
}

.btn:hover::before {
  transform: translateX(100%);
}

.btn-primary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.btn-primary:hover {
  box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
  transform: translateY(-2px);
}

.btn-secondary {
  background: var(--color-background-alt);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
}

.btn-secondary:hover {
  background: var(--color-background);
  border-color: var(--color-primary);
  color: var(--color-primary);
  box-shadow: var(--shadow-sm);
}

.badge {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 0.25rem 0.625rem;
  border-radius: 999px;
  font-size: 0.75rem;
  font-weight: 700;
  box-shadow: 0 2px 4px rgba(102, 126, 234, 0.2);
  min-width: 1.5rem;
  text-align: center;
}

.gpx-import-zone {
  background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
  border: 2px dashed var(--color-border);
  border-radius: var(--radius-xl);
  padding: 2rem 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.gpx-import-zone:hover {
  background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
  border-color: var(--color-primary);
  transform: scale(1.02);
  box-shadow: var(--shadow-lg);
}

.gpx-import-icon {
  font-size: 3rem;
  margin-bottom: 0.5rem;
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
}

.gpx-import-title {
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--color-text-primary);
  margin-bottom: 0.25rem;
}

.gpx-import-hint {
  font-size: 0.875rem;
  color: var(--color-text-muted);
}

.layer-group {
  background: var(--color-surface);
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-md);
  margin-bottom: 0.75rem;
  overflow: hidden;
  transition: all 0.2s ease;
}

.layer-group:hover {
  box-shadow: var(--shadow-sm);
}

.layer-group-header {
  background: linear-gradient(to right, rgba(102, 126, 234, 0.05), transparent);
  padding: 0.875rem 1rem;
  border-bottom: 1px solid transparent;
  transition: all 0.2s ease;
}

.layer-group-header:hover {
  background: linear-gradient(to right, rgba(102, 126, 234, 0.1), transparent);
}

.layer-group.expanded .layer-group-header {
  border-bottom-color: var(--color-border-light);
}

.layer-group-label {
  font-weight: 600;
  font-size: 0.95rem;
  color: var(--color-text-primary);
}

.toggle-switch {
  width: 46px;
  height: 26px;
  background: #CBD5E0;
  border-radius: 13px;
  position: relative;
  transition: background 0.3s ease;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.toggle-switch::after {
  content: '';
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: white;
  top: 3px;
  left: 3px;
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.toggle-input:checked + .toggle-switch {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.toggle-input:checked + .toggle-switch::after {
  transform: translateX(20px);
}

.info-list {
  background: var(--color-surface);
  border-radius: var(--radius-md);
  padding: 1rem;
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 0.75rem 1rem;
}

.info-list dt {
  font-weight: 600;
  color: var(--color-text-secondary);
  font-size: 0.875rem;
}

.info-list dd {
  color: var(--color-text-primary);
  font-weight: 500;
}

.waypoint-item {
  background: white;
  border: 1px solid var(--color-border-light);
  border-left: 3px solid var(--color-waypoint);
  border-radius: var(--radius-md);
  padding: 0.75rem;
  display: grid;
  grid-template-columns: auto 1fr auto auto;
  align-items: center;
  gap: 0.75rem;
  transition: all 0.2s ease;
}

.waypoint-icon {
  font-size: 1.5rem;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
}

.elevation-profile {
  background: white;
  border-top: 3px solid var(--color-primary);
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.08);
}

.elevation-header {
  background: linear-gradient(to right, rgba(102, 126, 234, 0.05), transparent);
  border-bottom: 1px solid var(--color-border-light);
  padding: 1rem 1.5rem;
}

.elevation-title h3 {
  font-weight: 600;
  color: var(--color-text-primary);
}

.roadbook-step {
  background: white;
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-lg);
  padding: 1rem;
  box-shadow: var(--shadow-xs);
  transition: all 0.2s ease;
}

.roadbook-step:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

.roadbook-step[data-type="start"] {
  border-left: 4px solid #4CAF50;
  background: linear-gradient(to right, rgba(76, 175, 80, 0.05), white);
}

.roadbook-step[data-type="waypoint"] {
  border-left: 4px solid var(--color-waypoint);
}

.roadbook-step[data-type="end"] {
  border-left: 4px solid #FF5722;
  background: linear-gradient(to right, rgba(255, 87, 34, 0.05), white);
}

.panel-footer {
  margin-top: auto;
  padding: 1rem 1.5rem;
  border-top: 1px solid var(--color-border-light);
  background: var(--color-background);
  color: var(--color-text-muted);
  font-size: 0.85rem;
  line-height: 1.5;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.panel-footer a {
  color: var(--color-primary);
  font-weight: 600;
  text-decoration: none;
}

.panel-footer-links {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.25rem;
}

.panel-footer-separator {
  color: var(--color-border);
  font-weight: 600;
}
.panel-footer a:hover {
  text-decoration: underline;
}

.panel-version {
  font-weight: 600;
  color: var(--color-text-secondary);
}

@media (max-width: 767px) {
  .panel-header {
    padding: 1.25rem;
  }

  .panel-title {
    font-size: 1.25rem;
  }

  .panel-section {
    padding: 1rem;
    border-radius: var(--radius-md);
  }

  .section-title {
    font-size: 0.8125rem;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.panel-content::-webkit-scrollbar {
  width: 8px;
}

.panel-content::-webkit-scrollbar-track {
  background: var(--color-background-alt);
  border-radius: 4px;
}

.panel-content::-webkit-scrollbar-thumb {
  background: linear-gradient(to bottom, #667eea, #764ba2);
  border-radius: 4px;
}

.panel-content::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(to bottom, #5568d3, #653b8b);
}
</style>
<!-- Modern Compact UI Overrides -->
<style>
:root {
  /* Couleurs primaires - Bleu moderne plus satur√© */
  --color-primary: #0066FF;
  --color-primary-hover: #0052CC;
  --color-primary-light: #E6F0FF;
  
  /* Couleurs secondaires - Gris modernes */
  --color-secondary: #F7F8FA;
  --color-secondary-hover: #E8EAED;
  
  /* Couleurs de danger */
  --color-danger: #FF3B30;
  --color-danger-hover: #E62E24;
  
  /* Backgrounds */
  --color-background: #FFFFFF;
  --color-background-alt: #FAFBFC;
  --color-background-elevated: #FFFFFF;
  
  /* Textes */
  --color-text-primary: #1A1A1A;
  --color-text-secondary: #4A4A4A;
  --color-text-muted: #8E8E93;
  
  /* Bordures */
  --color-border: #E5E5EA;
  --color-border-light: #F2F2F7;
  
  /* Ombres modernis√©es */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
  
  /* Bordures arrondies plus subtiles */
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;
  
  /* Espacements compacts */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 0.75rem;
  --spacing-lg: 1rem;
  --spacing-xl: 1.5rem;
}

/* 2. Typographie modernis√©e */
html, body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  font-size: 14px;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.panel-title {
  font-size: 1.25rem;
  font-weight: 700;
  letter-spacing: -0.02em;
}

.section-title {
  font-size: 0.95rem;
  font-weight: 600;
  letter-spacing: -0.01em;
  text-transform: uppercase;
  color: var(--color-text-muted);
}

/* 3. Panneau lat√©ral compact */
.panel-header {
  padding: 1rem 1.25rem;
  background: var(--color-background);
  border-bottom: 1px solid var(--color-border-light);
  backdrop-filter: blur(10px);
}

.panel-content {
  padding: 0.75rem 1rem;
}

.panel-section {
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--color-border-light);
}

.tools-panel {
  width: 280px;
  min-width: 280px;
}

@media (min-width: 768px) and (max-width: 1023px) {
  .tools-panel {
    width: 260px;
    min-width: 260px;
  }
}

/* 4. Boutons modernis√©s */
.btn {
  padding: 0.625rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  border-radius: var(--radius-md);
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  border: none;
  cursor: pointer;
}

.btn:not(:disabled):active {
  transform: scale(0.98);
}

.btn-primary {
  background: var(--color-primary);
  color: #FFFFFF;
  box-shadow: 0 1px 3px rgba(0, 102, 255, 0.2);
}

.btn-primary:not(:disabled):hover {
  background: var(--color-primary-hover);
  box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
  transform: translateY(-1px);
}

.btn-secondary {
  background: var(--color-secondary);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
}

.btn-small {
  padding: 0.375rem 0.75rem;
  font-size: 0.8125rem;
}

/* 5. Cartes et conteneurs modernis√©s */
.layer-group {
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-md);
  background: var(--color-background-elevated);
  overflow: hidden;
  margin-bottom: 0.5rem;
  box-shadow: var(--shadow-sm);
  transition: all 0.2s ease;
}

.layer-group:hover {
  box-shadow: var(--shadow-md);
}

.layer-group-header {
  padding: 0.625rem 0.75rem;
  background: var(--color-background-alt);
  border: none;
  transition: background 0.15s ease;
}

.layer-group-content {
  padding: 0 0.75rem;
}

.layer-group.expanded .layer-group-content {
  padding: 0.625rem 0.75rem;
}

/* File info modernis√© */
.file-info {
  margin-top: 0.75rem;
  padding: 0.75rem;
  border-radius: var(--radius-md);
  background: var(--color-background-alt);
  border: 1px solid var(--color-border-light);
}

/* 6. Toggles et contr√¥les modernis√©s */
.toggle-switch {
  width: 40px;
  height: 22px;
  border-radius: 11px;
  background: #E5E5EA;
}

.toggle-switch::after {
  width: 16px;
  height: 16px;
  top: 3px;
  left: 3px;
}

.toggle-input:checked + .toggle-switch::after {
  transform: translateX(18px);
}

.layer-toggle {
  padding: 0.375rem 0.25rem;
  gap: 0.625rem;
}

.toggle-text {
  font-size: 0.875rem;
}

.toggle-icon {
  font-size: 1rem;
}

/* 7. Waypoints et listes compactes */
.waypoints-list {
  max-height: 200px;
  gap: 0.375rem;
}

.waypoint-item {
  padding: 0.5rem;
  gap: 0.5rem;
  border-radius: var(--radius-md);
  background: var(--color-background-elevated);
  border: 1px solid var(--color-border-light);
}

/* 8. Info-list modernis√©e */
.info-list {
  grid-template-columns: auto 1fr;
  row-gap: 0.625rem;
  column-gap: 0.75rem;
  font-size: 0.875rem;
}

.info-list dt {
  font-weight: 600;
  font-size: 0.8125rem;
  color: var(--color-text-muted);
}

/* 9. Badge modernis√© */
.badge {
  min-width: 1.5rem;
  padding: 0.125rem 0.375rem;
  border-radius: 999px;
  background: var(--color-primary);
  color: #FFFFFF;
  font-size: 0.75rem;
  font-weight: 600;
  box-shadow: 0 1px 3px rgba(0, 102, 255, 0.2);
}

/* 10. Profil d'√©l√©vation compact */
.elevation-profile {
  height: 180px;
}

.elevation-header {
  padding: 0.625rem 1rem;
  min-height: 36px;
}

.elevation-title h3 {
  font-size: 0.9375rem;
  font-weight: 600;
}

.elevation-stats-quick {
  gap: 1.25rem;
}

.stat-item {
  font-size: 0.8125rem;
}

@media (max-width: 767px) {
  .elevation-profile {
    height: 140px;
  }
}

/* 11. Bouton POI refresh modernis√© */
.poi-refresh-button {
  left: 50%;
  top:5rem;
  transform: translateX(-50%);
  padding: 0.5rem 0.875rem;
  background: rgba(0, 102, 255, 0.95);
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
  backdrop-filter: blur(10px);
}

.poi-refresh-button:hover {
  background: rgba(0, 82, 204, 0.95);
  transform: translateX(-50%) translateY(-2px);
  box-shadow: 0 6px 16px rgba(0, 102, 255, 0.4);
}

/* 12. Indicateurs et messages compacts */
.layer-loading,
.layer-error,
.layer-info {
  padding: 0.5rem 0.625rem;
  border-radius: var(--radius-md);
  font-size: 0.8125rem;
}

.layer-loading {
  background: var(--color-primary-light);
  color: var(--color-primary);
}

.message {
  min-height: 2.5rem;
  padding: 0.625rem 0.875rem;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
}

/* 13. Drop zone modernis√©e */
.drop-zone {
  margin-top: 0.75rem;
  padding: 1rem;
  border: 2px dashed var(--color-border);
  border-radius: var(--radius-lg);
  background: var(--color-background-alt);
  transition: all 0.2s ease;
}

.drop-zone.dragover {
  border-color: var(--color-primary);
  background: var(--color-primary-light);
  transform: scale(1.01);
}

/* 14. Popups POI modernis√©s */
.poi-popup-container .leaflet-popup-content-wrapper {
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  padding: 0;
}

.poi-popup {
  font-size: 0.875rem;
  min-width: 200px;
}

.poi-header {
  padding-bottom: 0.625rem;
  margin-bottom: 0.625rem;
}

.poi-details {
  gap: 0.375rem;
  margin-bottom: 0.625rem;
}

.poi-row {
  font-size: 0.8125rem;
}

/* 15. Animations fluides */
* {
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

.layer-group,
.waypoint-item,
.poi-marker {
  animation: fadeIn 0.2s ease-out;
}

/* 16. Scrollbars modernis√©es */
.panel-content::-webkit-scrollbar,
.waypoints-list::-webkit-scrollbar {
  width: 6px;
}

.panel-content::-webkit-scrollbar-track,
.waypoints-list::-webkit-scrollbar-track {
  background: transparent;
}

.panel-content::-webkit-scrollbar-thumb,
.waypoints-list::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: 3px;
}

.panel-content::-webkit-scrollbar-thumb:hover,
.waypoints-list::-webkit-scrollbar-thumb:hover {
  background: var(--color-text-muted);
}
</style>
<style>
/* === Collapsible Sections === */
.collapsible-section {
  position: relative;
}

.collapsible-section .section-header-with-action {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.collapsible-section .section-header-with-action .section-header-toggle {
  flex: 1;
}

.collapsible-section .section-header-toggle {
  width: 100%;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 0;
  background: transparent;
  border: none;
  cursor: pointer;
  user-select: none;
  transition: background 0.2s ease;
  text-align: left;
}

.collapsible-section .section-header-toggle:hover {
  background: rgba(0, 0, 0, 0.02);
  border-radius: var(--radius-md);
}

.collapsible-section .section-header-toggle:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
  border-radius: var(--radius-md);
}

.collapsible-section .section-header-icon {
  font-size: 1.1rem;
  line-height: 1;
  flex-shrink: 0;
}

.collapsible-section .section-title {
  margin: 0;
  flex: 1;
  font-size: 0.95rem;
  font-weight: 600;
  letter-spacing: -0.01em;
  text-transform: uppercase;
  color: var(--color-text-muted);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.collapsible-section .section-title .badge {
  font-size: 0.75rem;
  margin-left: 0.25rem;
}

.collapsible-section .section-header-chevron {
  font-size: 0.8rem;
  color: var(--color-text-muted);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  flex-shrink: 0;
}

.collapsible-section.expanded .section-header-chevron {
  transform: rotate(180deg);
}

.section-collapsible-content {
  max-height: 0;
  overflow: hidden;
  opacity: 0;
  transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
  will-change: max-height;
}

.collapsible-section.expanded .section-collapsible-content {
  max-height: 5000px;
  opacity: 1;
}

#layers-section .section-collapsible-content {
  padding-top: 0;
}

#layers-section.expanded .section-collapsible-content {
  max-height: 6000px;
  padding-top: 0.5rem;
}

#waypoints-section .section-collapsible-content {
  padding-top: 0;
}

#map-style-section .section-collapsible-content {
  padding-top: 0;
}

#map-style-section.expanded .section-collapsible-content {
  padding-top: 0.5rem;
}

#waypoints-section.expanded .section-collapsible-content {
  max-height: 2000px;
  padding-top: 0.5rem;
}

.collapsible-section.expanded .section-collapsible-content > * {
  animation: slideInContent 0.3s ease-out;
}

@keyframes slideInContent {
  from {
    opacity: 0;
    transform: translateY(-8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@media (prefers-color-scheme: dark) {
  .collapsible-section .section-header-toggle:hover {
    background: rgba(255, 255, 255, 0.05);
  }
}
</style>
<style>
/* === ROADBOOK SECTION === */

.roadbook-export-btn {
  margin-left: auto;
  margin-right: 0.5rem;
  opacity: 0.7;
  transition: opacity 0.2s ease, transform 0.15s ease;
  font-size: 1rem;
  line-height: 1;
}

.roadbook-export-btn:hover,
.roadbook-export-btn:focus-visible {
  opacity: 1;
  transform: scale(1.05);
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}

.roadbook-export-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
  transform: none;
}

.roadbook-export-btn.copied {
  animation: copySuccess 0.6s ease;
}

@keyframes copySuccess {
  0%,
  100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.15);
    background: var(--color-primary-light);
  }
}

.roadbook-empty {
  padding: 2rem 1rem;
  text-align: center;
}

.roadbook-empty-text {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.75rem;
  color: var(--color-text-muted);
  font-size: 0.9rem;
  margin: 0;
}

.roadbook-empty-icon {
  font-size: 2.5rem;
  opacity: 0.5;
}

.roadbook-list {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  padding: 0.5rem 0;
}

.roadbook-step {
  display: grid;
  grid-template-columns: 48px 1fr;
  gap: 0.75rem;
  padding: 0.75rem;
  background: var(--color-background-elevated, #fff);
  border: 1px solid var(--color-border-light, #E5E5EA);
  border-radius: var(--radius-md, 8px);
  box-shadow: var(--shadow-sm);
  transition: all 0.2s ease;
}

.roadbook-step:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.roadbook-step[data-type="start"] {
  border-left: 3px solid #4CAF50;
  background: linear-gradient(90deg, rgba(76, 175, 80, 0.05) 0%, var(--color-background-elevated, #fff) 10%);
}

.roadbook-step[data-type="waypoint"] {
  border-left: 3px solid #FF5722;
}

.roadbook-step[data-type="end"] {
  border-left: 3px solid #FF5722;
  background: linear-gradient(90deg, rgba(255, 87, 34, 0.05) 0%, var(--color-background-elevated, #fff) 10%);
}

.roadbook-step-marker {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
}

.roadbook-step-icon {
  font-size: 1.75rem;
  line-height: 1;
}

.roadbook-step-number {
  font-size: 0.75rem;
  font-weight: 700;
  color: var(--color-text-muted);
  background: var(--color-background-alt);
  padding: 0.125rem 0.375rem;
  border-radius: 999px;
  min-width: 24px;
  text-align: center;
}

.roadbook-step-content {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  min-width: 0;
}

.roadbook-step-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
}

.roadbook-step-name {
  margin: 0;
  font-size: 0.95rem;
  font-weight: 600;
  color: var(--color-text-primary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.roadbook-step-center-btn {
  flex-shrink: 0;
  border: none;
  background: transparent;
  font-size: 1rem;
  cursor: pointer;
  padding: 0.25rem;
  border-radius: 4px;
  transition: all 0.2s ease;
  opacity: 0;
}

.roadbook-step:hover .roadbook-step-center-btn {
  opacity: 1;
}

.roadbook-step-center-btn:hover {
  background: var(--color-primary-light);
  transform: scale(1.1);
}

.roadbook-step-distances {
  display: flex;
  flex-direction: column;
  gap: 0.375rem;
}

.roadbook-distance-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.85rem;
}

.roadbook-distance-label {
  color: var(--color-text-muted);
}

.roadbook-distance-value {
  font-weight: 600;
  color: var(--color-text-primary);
}

.roadbook-distance-cumul .roadbook-distance-value {
  color: var(--color-primary);
  font-size: 0.95rem;
}

.roadbook-distance-segment {
  padding-left: 0.5rem;
  border-left: 2px solid var(--color-border-light);
}

.roadbook-distance-segment .roadbook-distance-label {
  font-size: 0.8rem;
}

.roadbook-distance-segment .roadbook-distance-value {
  color: var(--color-text-secondary);
  font-size: 0.85rem;
}

.roadbook-step-elevation {
  display: flex;
  align-items: center;
  gap: 0.375rem;
  padding-top: 0.375rem;
  border-top: 1px dashed var(--color-border-light);
  font-size: 0.85rem;
}

.roadbook-elevation-label {
  color: var(--color-text-muted);
}

.roadbook-elevation-value {
  font-weight: 600;
  color: var(--color-text-secondary);
}

@media (max-width: 480px) {
  .roadbook-step {
    grid-template-columns: 40px 1fr;
    gap: 0.5rem;
    padding: 0.625rem;
  }

  .roadbook-step-icon {
    font-size: 1.5rem;
  }

  .roadbook-distance-item {
    font-size: 0.8rem;
  }

  .roadbook-distance-cumul .roadbook-distance-value {
    font-size: 0.9rem;
  }
}
</style>
<!-- Layer Indicators - unified styles (replaced multiple conflicting blocks) -->
<style id="layer-indicators-unified">
/* === LAYER INDICATORS - Position & Visibilit√© (UNIFI√â) === */

/* Container des indicateurs - toujours au-dessus de tout */
.layer-indicators {
  position: fixed !important;
  z-index: 1100 !important; /* Au-dessus de tout (POI button = 900, panel = 1000) */
  
  /* Centr√© horizontalement */
  left: 50% !important;
  transform: translateX(-50%) !important;
  top: 50% !important;
  
  /* Dimensions */
  max-width: 500px;
  width: auto;
  
  /* Layout vertical */
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  gap: 0.5rem !important;
  
  /* Pas de pointer-events sur le container, seulement sur les enfants */
  pointer-events: none !important;
}

/* Tous les messages individuels sont interactifs */
.layer-indicators > * {
  pointer-events: auto !important;
  width: 100%;
  text-align: center;
}

/* === STYLES DES INDICATEURS INDIVIDUELS === */

/* Loading - TOUJOURS VISIBLE quand display:flex est appliqu√© par JS */
.layer-loading {
  display: none; /* Cach√© par d√©faut, JS met display:flex */
  /* Positionn√©e FIXED au centre de l'√©cran, au-dessus de tout */
  position: fixed !important;
  z-index: 1200 !important; /* Au-dessus du reste */
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 0.5rem;
  padding: 0.75rem 1rem;
  border-radius: var(--radius-md, 8px);
  font-size: 0.95rem;
  font-weight: 600;
  width: min(90vw, 1000px);
  /*width: auto;*/
  /* Glassmorphism - bien visible */
  background: rgba(0, 102, 255, 0.95) !important;
  color: #FFFFFF !important;
  backdrop-filter: blur(6px);
  border: 1px solid rgba(255, 255, 255, 0.2);
  /* Ombre forte pour contraste */
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45) !important;
  /* Permettre les interactions avec le chargement */
  pointer-events: auto !important;
  /* Animation d'apparition */
  animation: slideDown 0.3s ease-out;
}

/* S'assurer que le loading est visible m√™me avec des conflits de style */
.layer-loading[style*="display: flex"],
.layer-loading[style*="display:flex"] {
  display: flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  position: fixed !important;
  z-index: 1200 !important;
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  pointer-events: auto !important;
}

/* Error */
.layer-error {
  display: none;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md, 8px);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 59, 48, 0.95) !important;
  color: #FFFFFF !important;
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
  animation: slideDown 0.3s ease-out;
  position: fixed !important;
  z-index: 1200 !important; /* Au-dessus du reste */
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  align-items: center !important;
  justify-content: center !important;
  width: min(90vw, 1000px);

}

/* Info */
.layer-info {
  display: none;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md, 8px);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 149, 0, 0.95) !important;
  color: #FFFFFF !important;
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(255, 149, 0, 0.3);
  animation: slideDown 0.3s ease-out;
  position: fixed !important;
  z-index: 1200 !important; /* Au-dessus du reste */
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  align-items: center !important;
  justify-content: center !important;
    width: min(90vw, 1000px);

}

/* Zoom info */
#layers-zoom-info,
.layer-zoom-info {
  display: none;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md, 8px);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 204, 0, 0.95) !important;
  color: #1A1A1A !important;
  border: 1px solid rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(255, 204, 0, 0.3);
  animation: slideDown 0.3s ease-out;
  width: min(90vw, 1000px);

}

/* Spinner animation */
.layer-loading .loading-spinner {
  display: inline-block;
  animation: spin 1s linear infinite;
  font-size: 1rem;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes slideDown {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* === RESPONSIVE MOBILE === */
@media (max-width: 767px) {
  .layer-indicators {
    top: 4.5rem !important; /* Sous le bouton menu */
    left: 1rem !important;
    right: 1rem !important;
    transform: none !important;
    max-width: none !important;
    width: auto !important;
  }
  
  .layer-loading,
  .layer-error,
  .layer-info,
  #layers-zoom-info,
  .layer-zoom-info {
    padding: 0.5rem 0.75rem;
    font-size: 0.8125rem;
  }
}

/* === DARK MODE === */
@media (prefers-color-scheme: dark) {
  .layer-loading { 
    background: rgba(10, 132, 255, 0.95) !important; 
  }
  .layer-error { 
    background: rgba(255, 69, 58, 0.95) !important; 
  }
  .layer-info { 
    background: rgba(255, 159, 10, 0.95) !important; 
  }
  #layers-zoom-info,
  .layer-zoom-info { 
    background: rgba(255, 214, 10, 0.95) !important; 
    color: #1A1A1A !important; 
  }
}
</style>
<script>
// === Empilement dynamique : calcule la hauteur totale des indicateurs visibles
(function() {
  function isVisible(el) {
    if (!el) return false;
    const cs = getComputedStyle(el);
    return cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0';
  }

  function updateButtonPosition() {
    const stack = document.querySelector('.layer-indicators');
    const btn = document.querySelector('.poi-refresh-button');
    if (!stack || !btn) return;

    // Mesurer uniquement les √©l√©ments visibles dans la pile
    const items = Array.from(stack.children).filter(isVisible);
    const gap = parseFloat(getComputedStyle(stack).gap || '8'); // px
    const stackTop = stack.getBoundingClientRect().top + window.scrollY; // position initiale top

    // Hauteur totale = somme des hauteurs + gaps
    let total = 0;
    items.forEach((el, idx) => {
      total += el.offsetHeight;
      if (idx < items.length - 1) total += gap;
    });

    // Positionner le bouton sous la pile (si pile vide, coller au top de la pile)
    const topPx = Math.round((stackTop || 16) + total);
    btn.style.top = topPx + 'px';
  }

  // Observer les mutations de visibilit√©/changement de texte/contenu
  const observer = new MutationObserver(() => {
    requestAnimationFrame(updateButtonPosition);
  });

  function init() {
    const stack = document.querySelector('.layer-indicators');
    const btn = document.querySelector('.poi-refresh-button');
    if (!stack || !btn) return;

    observer.observe(stack, { attributes: true, childList: true, subtree: true, attributeFilter: ['style', 'class'] });

    // Ajuster √† l'ouverture/fermeture du panneau (resize / orientation)
    window.addEventListener('resize', () => requestAnimationFrame(updateButtonPosition));
    window.addEventListener('orientationchange', () => requestAnimationFrame(updateButtonPosition));

    // Premier calcul
    updateButtonPosition();

    // Exposer une fonction globale l√©g√®re si le code existant veut forcer un recalcul
    window.__updatePoiButtonPosition = updateButtonPosition;
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

// === Map Style Control ===

// D√©finitions des fonds de carte gratuits (100% sans cl√© API)
const mapStyles = {
  cyclosm: {
    name: 'CyclOSM',
    url: 'https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png',
    attribution: '&copy; OpenStreetMap | CyclOSM',
    maxZoom: 20
  },
  osm: {
    name: 'OpenStreetMap',
    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    attribution: '&copy; OpenStreetMap contributors',
    maxZoom: 19
  },
  topo: {
    name: 'OpenTopoMap',
    url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
    attribution: '&copy; OpenStreetMap | OpenTopoMap',
    maxZoom: 17
  },
  voyager: {
    name: 'CARTO Voyager',
    url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
    attribution: '&copy; OpenStreetMap | CARTO',
    maxZoom: 20
  },  satellite: {
    name: 'Esri Imagery',
    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    attribution: '&copy; Esri, Maxar, Earthstar Geographics',
    maxZoom: 19
  },
  hybrid: {
    name: 'Esri Hybrid',
    layers: [
      { url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', maxZoom: 19 },
      { url: 'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', maxZoom: 19 }
    ],
    attribution: '&copy; Esri, Maxar, Earthstar Geographics',
    maxZoom: 19
  }
};

// √âtat du contr√¥le
const mapStyleControl = {
  currentStyle: 'voyager',
  tileLayers: [],
  isOpen: false,
  toggleButton: null,
  panel: null,
  options: []
};

function changeMapStyle(styleId) {
  if (!mapStyles[styleId]) return;

  // retirer anciennes couches
  mapStyleControl.tileLayers.forEach(layer => { if (map.hasLayer(layer)) map.removeLayer(layer); });
  mapStyleControl.tileLayers = [];

  const style = mapStyles[styleId];
  if (style.layers) {
    style.layers.forEach(ld => {
      const layer = L.tileLayer(ld.url, { maxZoom: ld.maxZoom, attribution: style.attribution || '' }).addTo(map);
      mapStyleControl.tileLayers.push(layer);
    });
  } else {
    const layer = L.tileLayer(style.url, { maxZoom: style.maxZoom, attribution: style.attribution }).addTo(map);
    mapStyleControl.tileLayers.push(layer);
  }

  mapStyleControl.currentStyle = styleId;
  updateMapStyleUI(styleId);
  try { localStorage.setItem('gpx_map_style', styleId); } catch(_) {}
}

function updateMapStyleUI(active) {
  mapStyleControl.options.forEach(btn => {
    const id = btn.getAttribute('data-style');
    if (id === active) btn.classList.add('active'); else btn.classList.remove('active');
  });
}

function toggleMapStylePanel(forceState) {
  const shouldOpen = forceState !== undefined ? forceState : !mapStyleControl.isOpen;
  mapStyleControl.panel.style.display = shouldOpen ? 'block' : 'none';
  mapStyleControl.toggleButton.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
  mapStyleControl.isOpen = shouldOpen;
}

function loadMapStylePreference() {
  try { const v = localStorage.getItem('gpx_map_style'); return (v && mapStyles[v]) ? v : 'voyager'; } catch(_) { return 'voyager'; }
}

function initMapStyleControl() {
  mapStyleControl.toggleButton = document.getElementById('map-style-toggle');
  mapStyleControl.panel = document.getElementById('map-style-panel');
  mapStyleControl.options = Array.from(document.querySelectorAll('.map-style-option'));

  if (!mapStyleControl.toggleButton || !mapStyleControl.panel) return;

  // appliquer pr√©f√©rence
  changeMapStyle(loadMapStylePreference() || 'voyager');

  // events
  mapStyleControl.toggleButton.addEventListener('click', (e) => { e.stopPropagation(); toggleMapStylePanel(); });
  mapStyleControl.options.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const id = btn.getAttribute('data-style');
      if (id) { changeMapStyle(id); toggleMapStylePanel(false); }
    });
  });
  document.addEventListener('click', (e) => {
    if (mapStyleControl.isOpen) {
      const inside = mapStyleControl.panel.contains(e.target) || mapStyleControl.toggleButton.contains(e.target);
      if (!inside) toggleMapStylePanel(false);
    }
  });
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && mapStyleControl.isOpen) toggleMapStylePanel(false); });
}

document.addEventListener('DOMContentLoaded', () => { try { attachWaypointPersistence(); } catch(e){} });
</script>
<style>
/* === G√©olocalisation : styles === */
.geolocation-toggle { padding: 0.5rem 0; }
.geolocation-info {
  margin-top: 0.75rem; padding: 0.75rem; border-radius: var(--radius-md);
  background: var(--color-background-alt); border: 1px solid var(--color-border-light);
}
.geolocation-status {
  display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: var(--color-text-secondary);
}
.geolocation-status .status-icon { font-size: 1rem; }
.geolocation-status.active .status-icon { animation: pulse 2s ease-in-out infinite; }
.geolocation-status.error { color: var(--color-danger); }
.geolocation-error {
  margin-top: 0.75rem; padding: 0.625rem 0.875rem; border-radius: var(--radius-md);
  background: rgba(255, 59, 48, 0.1); color: var(--color-danger); font-size: 0.875rem;
  border: 1px solid rgba(255, 59, 48, 0.2);
}
@keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:.5;} }

/* Marqueur de position */
.user-location-marker { border: none !important; background: transparent !important; }
.user-location-marker-inner {
  width: 100%; height: 100%; border-radius: 50%; background: #4285F4; border: 3px solid #ffffff;
  box-shadow: 0 2px 8px rgba(66,133,244,0.4); animation: locationPulse 2s ease-in-out infinite;
}
@keyframes locationPulse { 0%,100%{transform:scale(1);opacity:1;} 50%{transform:scale(1.1);opacity:.8;} }
.user-location-accuracy { fill: rgba(66,133,244,0.15); stroke: rgba(66,133,244,0.3); stroke-width: 2; }
</style>
<style>
/* Sidebar widening & preset select layout overrides */
.tools-panel { width: 460px !important; min-width: 460px !important; }
@media (max-width: 1024px) {
  .tools-panel { width: 92vw !important; max-width: 460px !important; }
}
@media (max-width: 767px) {
  .tools-panel { width: 95vw !important; max-width: 460px !important; }
  .layer-presets { flex-direction: column !important; align-items: stretch !important; }
}
.layer-presets { display: flex; gap: 0.5rem; align-items: center; }
.layer-presets label { flex: 0 0 auto; margin-right: 0.25rem; }
.preset-select { flex: 1 1 auto; width: 100%; }
</style>
<style>
/* ===== Mobile Portrait Sidebar Compatibility (overrides) ===== */
@media (max-width: 600px) and (orientation: portrait) {
  .tools-panel {
    position: fixed;
    inset: 0 auto 0 0;            /* top:0; left:0; full height */
    width: 100vw !important;
    max-width: 100vw !important;
    min-width: 0 !important;
    height: 100dvh !important;    /* account for mobile browser UI */
    border-right: none !important;
    box-shadow: 0 0 24px rgba(0,0,0,0.15) !important;
    z-index: 2200 !important;
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    transform: translateX(-100%); /* respect existing open/close behavior */
  }
  .tools-panel.open {
    transform: translateX(0);
  }

  .panel-content {
    padding: 0.75rem 1rem !important;
  }

  /* Presets layout: vertical, full width */
  .layer-presets {
    display: flex !important;
    flex-direction: column !important;
    align-items: stretch !important;
    gap: 0.5rem !important;
  }
  .layer-presets label { margin-right: 0 !important; }
  .preset-select { width: 100% !important; min-height: 40px; }

  /* Buttons row wraps gracefully */
  .layer-global-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  /* Slightly smaller section titles to save space */
  .section-title {
    font-size: 1rem !important;
    line-height: 1.25rem !important;
  }
}
</style>
<script id="map-style-control-defs">
// === Map Style Control (defs preloaded) ===
(function(){
  if (window.__MAP_STYLE_CONTROL_DEFINED__) return;
  window.__MAP_STYLE_CONTROL_DEFINED__ = true;

  window.mapStyles = {
    cyclosm: { name:'CyclOSM', url:'https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', attribution:'&copy; OpenStreetMap | CyclOSM | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:20 },
    osm: { name:'OpenStreetMap', url:'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', attribution:'&copy; OpenStreetMap contributors | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:19 },
    topo: { name:'OpenTopoMap', url:'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attribution:'&copy; OpenStreetMap | OpenTopoMap | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:17 },
    voyager: { name:'CARTO Voyager', url:'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', attribution:'&copy; OpenStreetMap | CARTO | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:20 },
    satellite: { name:'Esri Imagery', url:'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', attribution:'&copy; Esri, Maxar, Earthstar Geographics | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:19 },
    hybrid: { name:'Esri Hybrid', layers:[
      { url:'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', maxZoom:19 },
      { url:'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', maxZoom:19 }
    ], attribution:'&copy; Esri, Maxar, Earthstar Geographics | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:19 }
  };

  window.mapStyleControl = { currentStyle: 'voyager', tileLayers:[], isOpen:false, toggleButton:null, panel:null, options:[] };

  window.changeMapStyle = function(styleId){
    if (!window.map || !window.mapStyles[styleId]) return;
    // remove old
    window.mapStyleControl.tileLayers.forEach(l => { if (window.map.hasLayer(l)) window.map.removeLayer(l); });
    window.mapStyleControl.tileLayers = [];
    const style = window.mapStyles[styleId];
    if (style.layers) {
      style.layers.forEach(ld => {
        const layer = L.tileLayer(ld.url, { maxZoom: ld.maxZoom, attribution: style.attribution || '' }).addTo(window.map);
        window.mapStyleControl.tileLayers.push(layer);
      });
    } else {
      const layer = L.tileLayer(style.url, { maxZoom: style.maxZoom, attribution: style.attribution }).addTo(window.map);
      window.mapStyleControl.tileLayers.push(layer);
    }
    window.mapStyleControl.currentStyle = styleId;
    window.updateMapStyleUI(styleId);
    try { localStorage.setItem('gpx_map_style', styleId); } catch(_) {}
  };

  window.updateMapStyleUI = function(active){
    (window.mapStyleControl.options || []).forEach(btn => {
      const id = btn.getAttribute('data-style');
      if (id === active) btn.classList.add('active'); else btn.classList.remove('active');
    });
  };

  window.toggleMapStylePanel = function(forceState){
    const shouldOpen = forceState !== undefined ? forceState : !window.mapStyleControl.isOpen;
    if (!window.mapStyleControl.panel || !window.mapStyleControl.toggleButton) return;
    window.mapStyleControl.panel.style.display = shouldOpen ? 'block' : 'none';
    window.mapStyleControl.toggleButton.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    window.mapStyleControl.isOpen = shouldOpen;
  };

  window.loadMapStylePreference = function(){
    try { const v = localStorage.getItem('gpx_map_style'); return (v && window.mapStyles[v]) ? v : 'voyager'; } catch(_) { return 'voyager'; }
  };

  window.initMapStyleControl = function(){
    window.mapStyleControl.toggleButton = document.getElementById('map-style-toggle');
    window.mapStyleControl.panel = document.getElementById('map-style-panel');
    window.mapStyleControl.options = Array.from(document.querySelectorAll('.map-style-option'));
    if (!window.mapStyleControl.toggleButton || !window.mapStyleControl.panel) return;

    // appliquer pr√©f√©rence
    window.changeMapStyle(window.loadMapStylePreference());

    // events
    window.mapStyleControl.toggleButton.addEventListener('click', (e) => { e.stopPropagation(); window.toggleMapStylePanel(); });
    window.mapStyleControl.options.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const id = btn.getAttribute('data-style');
        if (id) { window.changeMapStyle(id); window.toggleMapStylePanel(false); }
      });
    });
    document.addEventListener('click', (e) => {
      if (window.mapStyleControl.isOpen) {
        const inside = window.mapStyleControl.panel.contains(e.target) || window.mapStyleControl.toggleButton.contains(e.target);
        if (!inside) window.toggleMapStylePanel(false);
      }
    });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && window.mapStyleControl.isOpen) window.toggleMapStylePanel(false); });
  };
})();
</script>
<style>
  /* Ensure elevation canvas has a minimum render size after reload */
  #elevation-canvas {
    min-height: 220px;
    width: 100%;
    display: block;
  }
</style>
<style>
  /* Elevation panel responsive sizing */
  #elevation-profile {
    overflow: hidden;
  }
  #elevation-canvas {
    width: 100%;
    display: block;
    /* height is set dynamically by JS; this is a safe fallback */
    max-height: 40vh;
  }
</style>
<style>
  /* Viewport-aware elevation sizing */
  #elevation-profile { overflow: hidden; }
  #elevation-canvas { width: 100%; display: block; }
</style>
<style>
  /* Elevation container should auto-size to its content */
  #elevation-profile { overflow: visible; }
  #elevation-content {
    height: auto !important;
    max-height: none !important;
    overflow: visible !important;
  }
</style>
<style>
  /* Canvas fills its parent container */
  #elevation-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  /* Parent controls height; provide a safe default you can override */
  #elevation-content {
    --elev-content-height: 260px;
    height: var(--elev-content-height);
  }
</style>
<style>
/* === Trace Start/End Markers === */
.trace-start-marker,
.trace-end-marker,
.trace-combined-marker { border: none !important; background: transparent !important; }

.trace-start-marker-inner,
.trace-end-marker-inner,
.trace-combined-marker-inner {
  width: 32px; height: 32px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  border: 3px solid #FFFFFF;
  box-shadow: 0 3px 8px rgba(0,0,0,.12);
  transition: transform .2s cubic-bezier(.34,1.56,.64,1);
  animation: markerAppear .4s cubic-bezier(.34,1.56,.64,1);
}

.trace-start-marker-inner { background: #4CAF50; box-shadow: 0 3px 8px rgba(76,175,80,0.4); }
.trace-end-marker-inner   { background: #FF5722; box-shadow: 0 3px 8px rgba(255,87,34,0.4); }
.trace-combined-marker-inner {
  background: linear-gradient(135deg, #4CAF50 0%, #FF5722 100%);
}

.trace-start-marker-icon,
.trace-end-marker-icon,
.trace-combined-marker-icon {
  font-size: 18px; line-height: 1;
  filter: drop-shadow(0 1px 2px rgba(0,0,0,.3));
}

/* Hover */
.trace-start-marker:hover .trace-start-marker-inner,
.trace-end-marker:hover .trace-end-marker-inner,
.trace-combined-marker:hover .trace-combined-marker-inner {
  transform: scale(1.15);
}

/* Apparition */
@keyframes markerAppear {
  from { opacity: 0; transform: scale(0.3); }
  to   { opacity: 1; transform: scale(1); }
}

/* Popup */
.trace-marker-popup { min-width: 200px; }
.trace-marker-popup-header {
  display:flex; align-items:center; gap:.5rem; padding-bottom:.5rem;
  border-bottom:1px solid var(--color-border); margin-bottom:.5rem;
}
.trace-marker-popup-title { font-size:1rem; font-weight:600; color:var(--color-text-primary); }
.trace-marker-popup-details { display:flex; flex-direction:column; gap:.375rem; margin-bottom:.5rem; }
.trace-marker-popup-row { display:flex; gap:.5rem; font-size:.875rem; }
.trace-marker-popup-label { color:var(--color-text-muted); min-width:70px; }
.trace-marker-popup-value { color:var(--color-text-primary); font-weight:500; }
.trace-marker-popup-button { width:100%; margin-top:.5rem; }
</style>


<style id="map-topbar-styles">
.map-wrapper {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
}
.map-topbar {
  height: 48px;
  background: #ffffff;
  border-bottom: 1px solid var(--color-border, #E5E5EA);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 16px;
  font-weight: 700;
  font-size: 1rem;
  color: #667eea;
  flex-shrink: 0;
  z-index: 10;
}
#map {
  flex: 1;
  height: auto;
  position: relative;
}
/* Controls slight offset */
#map .leaflet-top { top: 8px; }
@media (max-width: 767px) {
  .map-topbar { height: 56px; }
}
</style>

<style>
@media (max-width: 767px) {
  /* Positionne le bouton menu sous la barre horizontale */
  .btn-menu {
    top: 4.5rem !important; /* ajuste selon la hauteur de ta topbar */
    z-index: 1200 !important; /* s‚Äôassure qu‚Äôil reste cliquable */
  }
}
</style>
<style>
.panel-header {
  height: 48px;
  padding: 0 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
  color: #ffffff;
  border-bottom: none;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
}

.panel-title {
  color: #ffffff !important;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.panel-title::before {
  content: "üß∞";
  font-size: 1.75rem;
  line-height: 1;
}

.btn-close-panel {
  display: none;
  color: rgba(255, 255, 255, 0.9);
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  width: 36px;
  height: 36px;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.btn-close-panel:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: rotate(90deg);
}

@media (max-width: 767px) {
  .panel-header {
    height: 56px;
    padding: 0 14px;
  }

  .btn-close-panel {
    display: flex;
    align-items: center;
    justify-content: center;
  }
}
</style>

</head>
<body>
<div class="app-container">
<aside aria-label="Panneau d'outils" class="tools-panel" id="tools-panel" role="complementary">
<header class="panel-header">
<h2 class="panel-title">Outils</h2>
<button aria-label="Fermer le panneau" class="btn-close-panel" id="close-panel">‚úï</button>
</header>
<div class="panel-content">
<section class="panel-section geolocation-section" id="geolocation-section">
<h3 class="section-title">Ma position</h3>
<label class="layer-toggle geolocation-toggle">
<input aria-label="Activer la g√©olocalisation en temps r√©el" class="toggle-input" id="geolocation-toggle" type="checkbox"/>
<span class="toggle-switch"></span>
<span class="toggle-text">
<span aria-hidden="true" class="toggle-icon">üìç</span>
      Activer la localisation
    </span>
</label>
<div class="geolocation-info" id="geolocation-info" style="display: none;">
<div class="geolocation-status" id="geolocation-status">
<span class="status-icon">üîÑ</span>
<span class="status-text">Recherche de position...</span>
</div>
<button class="btn btn-secondary btn-small" disabled="" id="center-on-position" style="margin-top: 0.5rem;" type="button">
<span aria-hidden="true">üéØ</span>
      Centrer sur ma position
    </button>
</div>
<div class="geolocation-error" id="geolocation-error" style="display: none;"></div>
</section>
<section class="panel-section gpx-section">
<h3 class="section-title">
<span class="section-icon" aria-hidden="true">üìç</span>
        Trace GPX
      </h3>
<div class="gpx-empty-state" id="gpx-empty-state">
<div aria-label="Importer une trace GPX" class="gpx-import-zone" id="gpx-import-zone" role="button" tabindex="0">
<span aria-hidden="true" class="gpx-import-icon">üìÅ</span>
<span class="gpx-import-title">Importer une trace GPX</span>
<span class="gpx-import-hint">Glissez un fichier .gpx ou cliquez pour parcourir</span>
</div>
</div>
<div class="gpx-loaded-state hidden" id="gpx-loaded-state">
<div class="trace-summary" id="gpx-trace-summary">
<div class="trace-filename" id="gpx-trace-filename">‚Äî</div>
<div class="trace-stats">
<span aria-hidden="true" class="icon">üìä</span>
<span id="gpx-trace-distance">‚Äî</span>
<span aria-hidden="true">‚Ä¢</span>
<span id="gpx-trace-elevation">‚Äî</span>
</div>
</div>
<div class="gpx-actions">
<button class="gpx-action-btn gpx-action-btn--export" id="gpx-export-action" type="button">
<span aria-hidden="true" class="icon">üíæ</span>
<span class="label">Exporter</span>
</button>
<button class="gpx-action-btn" id="gpx-replace-action" type="button">
<span aria-hidden="true" class="icon">üîÑ</span>
<span class="label">Remplacer</span>
</button>
<button class="gpx-action-btn gpx-action-btn--danger" id="clear-trace-button" type="button">
<span aria-hidden="true" class="icon">üóëÔ∏è</span>
<span class="label">Effacer</span>
</button>
</div>
</div>
</section>
<section class="panel-section map-style-section collapsible-section" id="map-style-section">
<button aria-controls="map-style-content" aria-expanded="false" class="section-header-toggle" type="button">
<span class="section-header-icon">üó∫Ô∏è</span>
<h3 class="section-title">Style de carte</h3>
<span class="section-header-chevron">‚ñº</span>
</button>
<div class="section-collapsible-content" id="map-style-content">
<div class="map-style-options">
<button class="map-style-option" data-style="voyager" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-voyager"></div></div><span class="map-style-label-text">üó∫Ô∏è Voyager</span></button>
<button class="map-style-option" data-style="cyclosm" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-cyclosm"></div></div><span class="map-style-label-text">üö¥ CyclOSM</span></button>
<button class="map-style-option" data-style="osm" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-osm"></div></div><span class="map-style-label-text">üåç OpenStreetMap</span></button>
<button class="map-style-option" data-style="topo" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-topo"></div></div><span class="map-style-label-text">‚õ∞Ô∏è OpenTopoMap</span></button>
<button class="map-style-option" data-style="satellite" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-satellite"></div></div><span class="map-style-label-text">üõ∞Ô∏è Esri Imagery</span></button>
<button class="map-style-option" data-style="hybrid" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-hybrid"></div></div><span class="map-style-label-text">üõ∞Ô∏è+üèôÔ∏è Esri Hybrid</span></button>
</div>
</div>
</section>
<section class="panel-section" id="layers-section-placeholder"></section>
<section class="panel-section collapsible-section" id="waypoints-section" style="display: none;">
<button aria-controls="waypoints-content" aria-expanded="false" class="section-header-toggle" type="button">
<span class="section-header-icon">üìç</span>
<h3 class="section-title">Waypoints <span class="badge" id="waypoint-count">0</span></h3>
<span class="section-header-chevron">‚ñº</span>
</button>
<div class="section-collapsible-content" id="waypoints-content">
<div class="waypoints-list" id="waypoints-list"></div>
<button class="btn btn-secondary btn-small" id="clear-waypoints">Effacer tous les waypoints</button>
</div>
</section>
<section class="panel-section collapsible-section" id="roadbook-section" style="display: none;">
<div class="section-header-with-action">
<button aria-controls="roadbook-content" aria-expanded="false" class="section-header-toggle" type="button">
<span class="section-header-icon">üìã</span>
<h3 class="section-title">Roadbook <span class="badge" id="roadbook-step-count">0</span></h3>
<span class="section-header-chevron">‚ñº</span>
</button>
<button class="btn-icon-small roadbook-export-btn" id="roadbook-export-text" type="button" title="Copier le roadbook en texte" aria-label="Copier le roadbook au format texte" disabled>üìã</button>
</div>
<div class="section-collapsible-content" id="roadbook-content">
<div class="roadbook-empty" id="roadbook-empty">
<p class="roadbook-empty-text">
<span class="roadbook-empty-icon">üó∫Ô∏è</span>
        Aucun waypoint sur le parcours
      </p>
</div>
<div class="roadbook-list" id="roadbook-list">
</div>
</div>
</section>
<section class="panel-section" id="trace-info-section" style="display: none;">
<h3 class="section-title">Informations</h3>
<dl class="info-list">
<dt>Nom de la trace</dt>
<dd>
<span class="trace-name" id="trace-name">‚Äî</span>
<span aria-hidden="true" class="trace-name-help" title="Le nom provient d'abord du fichier GPX, puis du nom de fichier, ou d'un nom par d√©faut.">
                ‚ÑπÔ∏è
              </span>
</dd>
<dt>Nom du fichier</dt>
<dd class="file-name" id="file-name">‚Äî</dd>
<dt>Distance totale</dt>
<dd class="stat-highlight" id="trace-distance">‚Äî</dd>
<dt>D√©nivel√© positif (D+)</dt>
<dd class="stat-highlight" id="trace-elevation-gain">‚Äî</dd>
<dt>D√©nivel√© n√©gatif (D-)</dt>
<dd class="stat-highlight" id="trace-elevation-loss">‚Äî</dd>
<dt>Altitude</dt>
<dd id="trace-altitude-range">‚Äî</dd>
<dt>Nombre de points</dt>
<dd id="point-count">‚Äî</dd>
<dt>Type</dt>
<dd id="trace-type">‚Äî</dd>
</dl>
<div class="mini-elevation-profile" id="mini-elevation-profile" style="display: none;">
<h4 class="mini-profile-title">Profil d'√©l√©vation</h4>
<div class="mini-profile-canvas-wrapper">
<canvas aria-label="Aper√ßu du profil d'√©l√©vation de la trace" id="mini-elevation-canvas" role="img"></canvas>
</div>
<div class="sr-only" id="mini-elevation-description">
          Graphique montrant l'√©volution de l'altitude sur la distance totale de la trace.
          Altitude minimale : <span id="mini-aria-min">‚Äî</span>, maximale : <span id="mini-aria-max">‚Äî</span>.
        </div>
</div>
</section>
<section class="panel-section panel-messages">
<div aria-live="polite" class="message hidden" id="message" role="status"></div>
</section>
</div>
<footer class="panel-footer">
<div class="panel-footer-links" role="list">
<span role="listitem"><a href="https://lamouche.fr" rel="author noopener" target="_blank">D√©velopp√© par Benoit Lamouche</a></span>
<span class="panel-footer-separator" aria-hidden="true">‚Ä¢</span>
<span role="listitem"><a href="https://www.strava.com/athletes/4347458" rel="noopener" target="_blank">Strava</a></span>
<span class="panel-footer-separator" aria-hidden="true">‚Ä¢</span>
<span role="listitem"><a href="https://paypal.me/blamouche" rel="noopener" target="_blank">Offre moi une bi√®re üç∫</a></span>
</div>
<span class="panel-version">Version 1.0.0</span>
</footer>
</aside>
<main class="map-container">
<div class="map-main">
<div class="map-wrapper"><div class="map-topbar">
<span class="map-topbar-title"><h1 style="margin:0;">Cycling Companion</h1></span>
</div><div id="map"></div></div>
<div class="map-style-section">
<div class="map-style-section-title">Routes &amp; Cyclisme</div>
<button class="map-style-option" data-style="cyclosm" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-cyclosm"></div></div><span class="map-style-label-text"><span class="map-style-check">‚úì</span>
<span class="map-style-label">CyclOSM</span>
<span class="map-style-badge">‚≠ê</span></span></button>
<button class="map-style-option" data-style="osm" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-osm"></div></div><span class="map-style-label-text"><span class="map-style-check">‚úì</span>
<span class="map-style-label">OpenStreetMap</span></span></button>
<button class="map-style-option" data-style="topo" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-topo"></div></div><span class="map-style-label-text"><span class="map-style-check">‚úì</span>
<span class="map-style-label">OpenTopoMap</span></span></button>
<button class="map-style-option" data-style="voyager" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-voyager"></div></div><span class="map-style-label-text"><span class="map-style-check">‚úì</span>
<span class="map-style-label">CARTO Voyager</span></span></button>
</div>
<div class="map-style-section">
<div class="map-style-section-title">üõ∞Ô∏è Satellite</div>
<button class="map-style-option" data-style="satellite" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-satellite"></div></div><span class="map-style-label-text"><span class="map-style-check">‚úì</span>
<span class="map-style-label">Esri Imagery</span></span></button>
<button class="map-style-option" data-style="hybrid" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-hybrid"></div></div><span class="map-style-label-text"><span class="map-style-check">‚úì</span>
<span class="map-style-label">Esri Hybrid</span>
<span class="map-style-badge">‚≠ê</span></span></button>
</div>
</div>
</main></div>
<button aria-label="Recharger les points d'int√©r√™t" class="poi-refresh-button" id="poi-refresh-button" type="button">
<span aria-hidden="true">üîÑ</span>
          Recharger les POI
        </button>
<button aria-expanded="false" aria-label="Ouvrir le panneau" class="btn-menu" id="menu-toggle">‚ò∞</button>
<div aria-hidden="true" class="elevation-profile" id="elevation-profile">
<div class="elevation-header" id="elevation-header">
<div class="elevation-title" title="Profil altim√©trique">
<span aria-hidden="true" class="elevation-icon">üìä</span>
<h3>Profil altim√©trique</h3>
</div>
<div class="elevation-stats-quick">
<span class="stat-item">
<span class="stat-label">Distance :</span>
<span class="stat-value" id="profile-distance">‚Äî</span>
</span>
<span class="stat-item">
<span class="stat-label">D+ :</span>
<span class="stat-value" id="profile-elevation-gain">‚Äî</span>
</span>
<span class="stat-item">
<span class="stat-label">D- :</span>
<span class="stat-value" id="profile-elevation-loss">‚Äî</span>
</span>
</div>
<button aria-expanded="true" aria-label="R√©duire le profil" class="btn-collapse" id="elevation-collapse" type="button">
<span aria-hidden="true">‚ñº</span>
</button>
</div>
<div class="elevation-content" id="elevation-content">
<canvas aria-describedby="elevation-description" aria-label="Graphique du profil altim√©trique de la trace" id="elevation-canvas" role="img" tabindex="0"></canvas>
<div class="sr-only" id="elevation-description">
            Le graphique montre l'√©l√©vation en m√®tres en fonction de la distance parcourue en kilom√®tres.
            Distance totale : <span id="aria-distance">‚Äî</span>.
            D√©nivel√© positif : <span id="aria-d-plus">‚Äî</span>.
            Altitude minimum : <span id="aria-min">‚Äî</span>.
            Altitude maximum : <span id="aria-max">‚Äî</span>.
          </div>
<div class="elevation-tooltip" id="elevation-tooltip" style="display: none;">
<div class="tooltip-row">
<span class="tooltip-label">Distance :</span>
<span class="tooltip-value" id="tooltip-distance">‚Äî</span>
</div>
<div class="tooltip-row">
<span class="tooltip-label">Altitude :</span>
<span class="tooltip-value" id="tooltip-elevation">‚Äî</span>
</div>
</div>
</div>
</div>
<div class="modal-backdrop hidden" id="export-modal-backdrop"></div>
<div aria-labelledby="export-modal-title" aria-modal="true" class="export-modal hidden" id="export-modal" role="dialog">
<div class="export-modal-header">
<h4 id="export-modal-title"><span aria-hidden="true">üíæ</span>Exporter la trace</h4>
<button aria-label="Fermer la fen√™tre d'export" class="btn-icon-small" id="export-modal-close" type="button">‚úï</button>
</div>
<div class="export-modal-content">
<label for="export-file-name">
        Nom du fichier
        <input autocomplete="off" id="export-file-name" type="text" value=""/>
      </label>
<label class="checkbox-label" for="export-include-waypoints">
<input checked="" id="export-include-waypoints" type="checkbox"/>
<span id="export-waypoints-label">Inclure les waypoints (0)</span>
</label>
<div class="export-preview">
<span aria-hidden="true">üìÑ</span>
<span id="export-preview-name">trace_with_waypoints.gpx</span>
</div>
</div>
<div class="export-modal-actions">
<button class="btn btn-secondary" id="export-modal-cancel" type="button">Annuler</button>
<button class="btn btn-primary" id="export-modal-download" type="button">T√©l√©charger</button>
</div>
</div>
<input accept=".gpx" hidden="" id="file-input" type="file"/>
<!-- Leaflet JS -->
<script crossorigin="" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
<script>
    /**
     * Convertit un √©l√©ment XML GPX en GeoJSON Feature.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertPoint(element, featureType) {
      if (!element) {
        return null;
      }

      const lat = parseFloat(element.getAttribute('lat'));
      const lon = parseFloat(element.getAttribute('lon'));

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }

      const properties = { kind: featureType };

      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const ele = element.querySelector('ele');
      if (ele && ele.textContent.trim()) {
        const elevation = parseFloat(ele.textContent.trim());
        if (Number.isFinite(elevation)) {
          properties.ele = elevation;
        }
      }

      const time = element.querySelector('time');
      if (time && time.textContent.trim()) {
        properties.time = time.textContent.trim();
      }

      return {
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [lon, lat]
        },
        properties
      };
    }

    /**
     * Convertit une liste de points GPX en coordonn√©es GeoJSON.
     * @param {NodeListOf<Element>} points
     * @returns {number[][]}
     */
    function extractCoordinates(points) {
      const coordinates = [];
      points.forEach((point) => {
        const lat = parseFloat(point.getAttribute('lat'));
        const lon = parseFloat(point.getAttribute('lon'));
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          coordinates.push([lon, lat]);
        }
      });
      return coordinates;
    }

    /**
     * Convertit un √©l√©ment GPX en GeoJSON pour les routes ou pistes.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertLinearFeature(element, featureType) {
      if (!element) {
        return null;
      }

      const properties = { kind: featureType };
      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const segments = [];

      if (featureType === 'track') {
        const trksegs = element.querySelectorAll('trkseg');
        trksegs.forEach((segment) => {
          const coords = extractCoordinates(segment.querySelectorAll('trkpt'));
          if (coords.length > 1) {
            segments.push(coords);
          }
        });
      } else if (featureType === 'route') {
        const coords = extractCoordinates(element.querySelectorAll('rtept'));
        if (coords.length > 1) {
          segments.push(coords);
        }
      }

      if (segments.length === 0) {
        return null;
      }

      const geometry =
        segments.length === 1
          ? { type: 'LineString', coordinates: segments[0] }
          : { type: 'MultiLineString', coordinates: segments };

      return {
        type: 'Feature',
        geometry,
        properties
      };
    }

    /**
     * R√©alise une conversion minimale GPX -> GeoJSON pour les traces, routes et waypoints.
     * @param {XMLDocument} xml
     * @returns {GeoJSON.FeatureCollection}
     */
    function convertGpxToGeoJSON(xml) {
      const features = [];

      xml.querySelectorAll('wpt').forEach((wpt) => {
        const feature = convertPoint(wpt, 'waypoint');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('rte').forEach((route) => {
        const feature = convertLinearFeature(route, 'route');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('trk').forEach((track) => {
        const feature = convertLinearFeature(track, 'track');
        if (feature) {
          features.push(feature);
        }
      });

      return {
        type: 'FeatureCollection',
        features
      };
    }

    const OVERPASS_ENDPOINTS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://overpass.openstreetmap.fr/api/interpreter'
    ];

    const POI_GROUPS = {
      bike_services: { id: 'bike_services', label: 'Services v√©lo', icon: 'üö¥', defaultExpanded: true, order: 1 },
      resources: { id: 'resources', label: 'Ressources', icon: 'üíß', defaultExpanded: true, order: 2 },
      accommodation_outdoor: { id: 'accommodation_outdoor', label: 'H√©bergement outdoor', icon: 'üèïÔ∏è', defaultExpanded: true, order: 3 },
      accommodation: { id: 'accommodation', label: 'H√©bergement', icon: 'üè®', defaultExpanded: false, order: 4 },
      sanitary: { id: 'sanitary', label: 'Sanitaires', icon: 'üöª', defaultExpanded: true, order: 5 },
      food_shop: { id: 'food_shop', label: 'Alimentation', icon: 'üõí', defaultExpanded: true, order: 6 },
      food_service: { id: 'food_service', label: 'Restauration', icon: 'üç¥', defaultExpanded: false, order: 7 },
      health: { id: 'health', label: 'Sant√©', icon: 'üíä', defaultExpanded: true, order: 8 },
      heritage: { id: 'heritage', label: 'Patrimoine', icon: 'ü™¶', defaultExpanded: false, order: 9 }
    };

    const POI_CATEGORIES = {bicycle_repair: {
        id: 'bicycle_repair',
        label: 'Stations r√©paration',
        icon: 'üîß',
        color: '#FF6B00',
        group: 'bike_services',
        tags: { amenity: 'bicycle_repair_station' },
        priority: 'high',
        minZoom: 12
      },
      bicycle_shop: {
        id: 'bicycle_shop',
        label: 'Magasins v√©lo',
        icon: 'üö≤',
        color: '#FF8C00',
        group: 'bike_services',
        tags: { shop: 'bicycle' },
        priority: 'high',
        minZoom: 12
      },
      drinking_water: {
        id: 'drinking_water',
        label: 'Eau potable',
        icon: 'üíß',
        color: '#2196F3',
        group: 'resources',
        tags: { amenity: 'drinking_water' },
        priority: 'high',
        minZoom: 11
      },
      camp_site: {
        id: 'camp_site',
        label: 'Camping',
        icon: 'üèïÔ∏è',
        color: '#4CAF50',
        group: 'accommodation_outdoor',
        tags: { tourism: 'camp_site' },
        excludeTags: { backcountry: 'yes' },
        priority: 'high',
        minZoom: 11
      },
      camp_site_backcountry: {
        id: 'camp_site_backcountry',
        label: 'Bivouac autoris√©',
        icon: '‚õ∫',
        color: '#66BB6A',
        group: 'accommodation_outdoor',
        tags: { tourism: 'camp_site', backcountry: 'yes' },
        priority: 'high',
        minZoom: 11
      },
      wilderness_hut: {
        id: 'wilderness_hut',
        label: 'Refuge',
        icon: 'üõñ',
        color: '#8D6E63',
        group: 'accommodation_outdoor',
        tags: { tourism: 'wilderness_hut' },
        priority: 'high',
        minZoom: 11
      },
      alpine_hut: {
        id: 'alpine_hut',
        label: 'Refuge alpin',
        icon: 'üèîÔ∏è',
        color: '#795548',
        group: 'accommodation_outdoor',
        tags: { tourism: 'alpine_hut' },
        priority: 'high',
        minZoom: 11
      },
      hotel: {
        id: 'hotel',
        label: 'H√¥tel',
        icon: 'üè®',
        color: '#9C27B0',
        group: 'accommodation',
        tags: { tourism: 'hotel' },
        priority: 'medium',
        minZoom: 12
      },
      hostel: {
        id: 'hostel',
        label: 'Auberge de jeunesse',
        icon: 'üè†',
        color: '#AB47BC',
        group: 'accommodation',
        tags: { tourism: 'hostel' },
        priority: 'medium',
        minZoom: 12
      },
      guest_house: {
        id: 'guest_house',
        label: "Chambre d'h√¥tes",
        icon: 'üè°',
        color: '#BA68C8',
        group: 'accommodation',
        tags: { tourism: 'guest_house' },
        priority: 'medium',
        minZoom: 13
      },
      toilets: {
        id: 'toilets',
        label: 'Toilettes',
        icon: 'üöª',
        color: '#607D8B',
        group: 'sanitary',
        tags: { amenity: 'toilets' },
        priority: 'high',
        minZoom: 12
      },
      shower: {
        id: 'shower',
        label: 'Douches',
        icon: 'üöø',
        color: '#78909C',
        group: 'sanitary',
        tags: { amenity: 'shower' },
        priority: 'medium',
        minZoom: 13
      },
      supermarket: {
        id: 'supermarket',
        label: 'Supermarch√©',
        icon: 'üõí',
        color: '#FF5252',
        group: 'food_shop',
        tags: { shop: 'supermarket' },
        priority: 'high',
        minZoom: 12
      },
      convenience: {
        id: 'convenience',
        label: '√âpicerie',
        icon: 'üè™',
        color: '#FF7043',
        group: 'food_shop',
        tags: { shop: 'convenience' },
        priority: 'high',
        minZoom: 12
      },
      restaurant: {
        id: 'restaurant',
        label: 'Restaurant',
        icon: 'üç¥',
        color: '#FFC107',
        group: 'food_service',
        tags: { amenity: 'restaurant' },
        priority: 'medium',
        minZoom: 13
      },
      cafe: {
        id: 'cafe',
        label: 'Caf√©',
        icon: '‚òï',
        color: '#FFD54F',
        group: 'food_service',
        tags: { amenity: 'cafe' },
        priority: 'medium',
        minZoom: 13
      },
      fast_food: {
        id: 'fast_food',
        label: 'Fast-food',
        icon: 'üçî',
        color: '#FFEB3B',
        group: 'food_service',
        tags: { amenity: 'fast_food' },
        priority: 'low',
        minZoom: 13
      },
      pharmacy: {
        id: 'pharmacy',
        label: 'Pharmacie',
        icon: 'üíä',
        color: '#00C853',
        group: 'health',
        tags: { amenity: 'pharmacy' },
        priority: 'high',
        minZoom: 12
      },

      hospital: {
        id: 'hospital',
        label: 'H√¥pital',
        icon: 'üè•',
        color: '#E53935',
        group: 'health',
        tags: { amenity: 'hospital' },
        priority: 'high',
        minZoom: 11
      },

      cemetery: {
        id: 'cemetery',
        label: 'Cimeti√®re',
        icon: 'ü™¶',
        color: '#6A1B9A',
        group: 'heritage',
        tags: { landuse: 'cemetery' },
        priority: 'low',
        minZoom: 12
      },
      grave_yard: {
        id: 'grave_yard',
        label: 'Petit cimeti√®re',
        icon: '‚õ™',
        color: '#757575',
        group: 'heritage',
        tags: { amenity: 'grave_yard' },
        priority: 'low',
        minZoom: 12
      }
    };


    const LAYER_PRESETS = {
  need_water: {
    label: "J'ai besoin d'eau",
    icon: 'üíß',
    categories: [
      'drinking_water',
      'cemetery',
      'grave_yard',
      'convenience'
    ]
  },
  need_food: {
    label: 'J\'ai besoin de manger',
    icon: 'üçΩÔ∏è',
    categories: [
      'supermarket',
      'convenience',
      'restaurant',
      'fast_food'
    ]
  },
  need_repair: {
    label: 'J\'ai besoin de r√©parer',
    icon: 'üîß',
    categories: [
      'bicycle_repair',
      'bicycle_shop'
    ]
  },
  need_accommodation: {
    label: 'J\'ai besoin d\'un h√©bergement',
    icon: 'üèïÔ∏è',
    categories: [
      'camp_site',
      'wilderness_hut',
      'alpine_hut',
      'hotel',
      'hostel',
      'guest_house'
    ]
  },
  need_health: {
    label: 'J\'ai besoin de me soigner',
    icon: 'üè•',
    categories: [
      'pharmacy',
      'hospital'
    ]
  }
};

    const POI_SETTINGS = {
      debounceMs: 2000,
      minZoomDefault: 11,
      maxTotalItems: 500,
      maxItemsPerCategory: 120,
      cacheTtlMs: 10 * 60 * 1000,
      maxCacheEntries: 15,
      areaLimitDegSq: 0.12,
      maxRetries: 2,
      requestTimeoutMs: 12000
    };

    const poiCache = {
      data: new Map(),
      set(key, value) {
        this.data.set(key, { value, timestamp: Date.now() });
      },
      get(key) {
        const entry = this.data.get(key);
        if (!entry) {
          return null;
        }
        if (Date.now() - entry.timestamp > POI_SETTINGS.cacheTtlMs) {
          this.data.delete(key);
          return null;
        }
        return entry.value;
      },
      prune(maxEntries) {
        if (this.data.size <= maxEntries) {
          return;
        }
        const sorted = Array.from(this.data.entries()).sort(
          (a, b) => a[1].timestamp - b[1].timestamp
        );
        while (sorted.length > maxEntries) {
          const [keyToDelete] = sorted.shift();
          this.data.delete(keyToDelete);
        }
      },
      clear() {
        this.data.clear();
      }
    };

    const poiRequestLimiter = {
      lastRequest: 0,
      minInterval: 1500
    };

    const poiManager = {
      activeCategories: new Set(),
      expandedGroups: new Set(),
      layerGroups: new Map(),
      counts: new Map(),
      debounceTimer: null,
      abortController: null,
      currentRequestId: 0,
      loading: false,
      enabled: false,
      refreshPending: false,
      suppressRefreshPrompt: false,
      stats: {
        totalLoaded: 0,
        currentDisplayed: 0,
        requestCount: 0,
        errorCount: 0
      }
    };

    let layersSectionElement = null;
    let layersLoadingElement = null;
    let layersErrorElement = null;
    let layersInfoElement = null;
    let layersZoomInfoElement = null;
    let presetSelectElement = null;
    let isApplyingPreset = false;

    function getDefaultExpandedGroups() {
      return new Set(
        Object.values(POI_GROUPS)
          .filter((group) => group.defaultExpanded)
          .map((group) => group.id)
      );
    }

    function getDefaultActiveCategories() {
      return new Set(['cemetery', 'grave_yard']);
    }

    function loadLayerPreferences() {
      try {
        const raw = localStorage.getItem('gpx_layer_preferences');
        if (!raw) {
          return null;
        }
        const parsed = JSON.parse(raw);
        const active = new Set(
          Array.isArray(parsed.activeCategories)
            ? parsed.activeCategories.filter((id) => POI_CATEGORIES[id])
            : []
        );
        const expanded = new Set(
          Array.isArray(parsed.expandedGroups)
            ? parsed.expandedGroups.filter((id) => POI_GROUPS[id])
            : []
        );
        return { active, expanded };
      } catch (error) {
        console.warn('Impossible de charger les pr√©f√©rences:', error);
        return null;
      }
    }

    function saveLayerPreferences() {
      const data = {
        activeCategories: Array.from(poiManager.activeCategories),
        expandedGroups: Array.from(poiManager.expandedGroups)
      };
      try {
        localStorage.setItem('gpx_layer_preferences', JSON.stringify(data));
      } catch (error) {
        console.warn('Impossible de sauvegarder les pr√©f√©rences:', error);
      }
    }

    function relocateLayerIndicators() {
      try {
        const mapContainer = document.querySelector('.map-container');
        if (!mapContainer) {
          return;
        }
        const indicators = document.querySelector('.layer-indicators');
        if (indicators) {
          if (!mapContainer.contains(indicators)) {
            mapContainer.appendChild(indicators);
          }
        }
      } catch (error) {
        console.warn('relocateLayerIndicators:', error);
      }
    }
    document.addEventListener('DOMContentLoaded', relocateLayerIndicators);

    function generateLayersHTML() {
      const groups = Object.values(POI_GROUPS).sort((a, b) => a.order - b.order);
      let html = `
        <section class="panel-section layer-section collapsible-section expanded" id="layers-section">
          <button class="section-header-toggle" type="button" aria-expanded="true" aria-controls="layers-content">
            <span class="section-header-icon">üóÇÔ∏è</span>
            <h3 class="section-title">Calques et affichage</h3>
            <span class="section-header-chevron">‚ñº</span>
          </button>
          <div class="section-collapsible-content" id="layers-content">
            <div class="layer-global-actions">
              <button type="button" class="btn btn-secondary btn-small" id="layers-enable-all">Activer tout</button>
              <button type="button" class="btn btn-secondary btn-small" id="layers-disable-all">D√©sactiver tout</button>
            </div>
            
            <div class="layer-presets">
              <label for="preset-select">Profil :</label>
              <select id="preset-select" class="preset-select">
                <option value="">Personnalis√©</option>`;
      Object.entries(LAYER_PRESETS).forEach(([presetId, preset]) => {
        html += `
                <option value="${presetId}">${preset.icon} ${preset.label}</option>`;
      });
      html += `
              </select>

            </div>`;
      groups.forEach((group) => {
        const categories = Object.values(POI_CATEGORIES).filter((category) => category.group === group.id);
        if (categories.length === 0) {
          return;
        }
        const isExpanded = poiManager.expandedGroups.has(group.id);
        html += `
            <div class="layer-group ${isExpanded ? 'expanded' : ''}" data-group="${group.id}">
              <button class="layer-group-header" type="button" data-group="${group.id}" aria-expanded="${isExpanded ? 'true' : 'false'}">
                <span class="layer-group-icon">${group.icon}</span>
                <span class="layer-group-label">${group.label}</span>
                <span class="layer-group-count">(${categories.length})</span>
                <span class="layer-group-chevron">‚ñº</span>
              </button>
              <div class="layer-group-content">`;
        categories.forEach((category) => {
          const isChecked = poiManager.activeCategories.has(category.id) ? 'checked' : '';
          html += `
                <label class="layer-toggle" data-category="${category.id}">
                  <input
                    type="checkbox"
                    id="layer-${category.id}"
                    class="toggle-input layer-checkbox"
                    data-category="${category.id}"
                    ${isChecked}
                  />
                  <span class="toggle-switch"></span>
                  <span class="toggle-text">
                    <span class="toggle-icon" aria-hidden="true">${category.icon}</span>
                    ${category.label}
                  </span>
                  <span class="toggle-count" id="count-${category.id}" style="display: none;">(0)</span>
                </label>`;
        });
        html += `
              </div>
            </div>`;
      });
      html += `
          </div>
          <div class="layer-indicators">
              <div class="layer-loading" id="layers-loading" style="display: none;">
                <span class="loading-spinner" aria-hidden="true">‚è≥</span>
                Chargement des POI...
              </div>
              <div class="layer-error" id="layers-error" style="display: none;" role="alert"></div>
              <div class="layer-info" id="layers-info" style="display: none;"></div>
              <div class="layer-info" id="layers-zoom-info" style="display: none;"></div>
            </div>
        </section>
`;
      return html;
    }

    function attachLayerEventHandlers() {
      const enableAllButton = document.getElementById('layers-enable-all');
      const disableAllButton = document.getElementById('layers-disable-all');
      if (enableAllButton) {
        enableAllButton.addEventListener('click', () => enableAllCategories());
      }
      if (disableAllButton) {
        disableAllButton.addEventListener('click', () => disableAllCategories());
      }
      if (presetSelectElement) {
        presetSelectElement.addEventListener('change', handlePresetChange);
      }
      document.querySelectorAll('.layer-group-header').forEach((header) => {
        header.addEventListener('click', () => {
          const groupId = header.getAttribute('data-group');
          toggleGroupExpanded(groupId);
        });
      });
      document.querySelectorAll('.layer-checkbox').forEach((checkbox) => {
        checkbox.addEventListener('change', handleCategoryCheckboxChange);
      });
    }

    function renderLayersSection() {
      const placeholder = document.getElementById('layers-section-placeholder');
      if (!placeholder) {
        return;
      }
      placeholder.outerHTML = generateLayersHTML();
      layersSectionElement = document.getElementById('layers-section');
      layersLoadingElement = document.getElementById('layers-loading');
      layersErrorElement = document.getElementById('layers-error');
      layersInfoElement = document.getElementById('layers-info');
      layersZoomInfoElement = document.getElementById('layers-zoom-info');
      presetSelectElement = document.getElementById('preset-select');
      attachLayerEventHandlers();
      hideLayersIndicators();
      updateAllPOICounts();
      updatePresetSelection();
      if (window.collapsibleSectionsAPI?.init) {
        window.collapsibleSectionsAPI.init('layers');
      }
      relocateLayerIndicators();
    }

    function ensureLayerGroup(categoryId) {
      if (!poiManager.layerGroups.has(categoryId)) {
        poiManager.layerGroups.set(categoryId, L.layerGroup());
      }
      return poiManager.layerGroups.get(categoryId);
    }

    function setCategoryCheckboxState(categoryId, isChecked) {
      const checkbox = document.getElementById(`layer-${categoryId}`);
      if (checkbox) {
        checkbox.checked = Boolean(isChecked);
      }
    }

    function updateCategoryCountUI(categoryId, count) {
      const element = document.getElementById(`count-${categoryId}`);
      if (!element) {
        return;
      }
      if (count > 0) {
        element.textContent = `(${count})`;
        element.style.display = 'inline';
      } else {
        element.style.display = 'none';
      }
    }

    function updateAllPOICounts() {
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        const count = poiManager.counts.get(categoryId) || 0;
        updateCategoryCountUI(categoryId, count);
      });
    }

    function hideLayersIndicators() {
      hideLayersLoading();
      hideLayersError();
      hideLayersInfo();
      hideLayersZoomInfo();
    }

    function showLayersLoading() {
      if (layersLoadingElement) {
        layersLoadingElement.style.display = 'flex';
      }
    }

    function hideLayersLoading() {
      if (layersLoadingElement) {
        layersLoadingElement.style.display = 'none';
      }
    }

    function showLayersError(message) {
      if (layersErrorElement) {
        layersErrorElement.textContent = `‚ö†Ô∏è ${message}`;
        layersErrorElement.style.display = 'block';
      }
    }

    function hideLayersError() {
      if (layersErrorElement) {
        layersErrorElement.style.display = 'none';
        layersErrorElement.textContent = '';
      }
    }

    function showLayersInfo(message) {
      if (layersInfoElement) {
        layersInfoElement.textContent = message;
        layersInfoElement.style.display = 'block';
      }
    }

    function hideLayersInfo() {
      if (layersInfoElement) {
        layersInfoElement.style.display = 'none';
        layersInfoElement.textContent = '';
      }
    }

    function showLayersZoomInfo(minZoom) {
      if (!layersZoomInfoElement) return;
      // Si le zoom actuel est >= 13, masquer l'info m√™me si appel√©e
      try {
        if (typeof map !== 'undefined' && map && typeof map.getZoom === 'function') {
          const currentZoom = map.getZoom();
          if (currentZoom >= 13) {
            // s'assurer que l'√©l√©ment est cach√©
            layersZoomInfoElement.style.display = 'none';
            layersZoomInfoElement.textContent = '';
            return;
          }
        }
      } catch (e) {
        // ignore errors reading map zoom
      }
      layersZoomInfoElement.textContent = `‚ÑπÔ∏è Zoomez davantage pour voir les POI (zoom ‚â• ${minZoom})`;
      layersZoomInfoElement.style.display = 'block';
    }

    function hideLayersZoomInfo() {
      if (layersZoomInfoElement) {
        layersZoomInfoElement.style.display = 'none';
        layersZoomInfoElement.textContent = '';
      }
    }

    function showPoiRefreshButton() {
      if (!poiRefreshButton) {
        return;
      }
      poiRefreshButton.style.display = 'block';
      poiRefreshButton.setAttribute('aria-hidden', 'false');
    }

    function hidePoiRefreshButton() {
      if (!poiRefreshButton) {
        return;
      }
      poiRefreshButton.style.display = 'none';
      poiRefreshButton.setAttribute('aria-hidden', 'true');
    }

    function toggleGroupExpanded(groupId) {
      if (!groupId || !POI_GROUPS[groupId]) {
        return;
      }
      if (poiManager.expandedGroups.has(groupId)) {
        poiManager.expandedGroups.delete(groupId);
      } else {
        poiManager.expandedGroups.add(groupId);
      }
      saveLayerPreferences();
      const groupElement = document.querySelector(`.layer-group[data-group="${groupId}"]`);
      if (groupElement) {
        const header = groupElement.querySelector('.layer-group-header');
        const expanded = poiManager.expandedGroups.has(groupId);
        groupElement.classList.toggle('expanded', expanded);
        if (header) {
          header.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        }
      }
    }

    function handleCategoryCheckboxChange(event) {
      const checkbox = event.target;
      const categoryId = checkbox.getAttribute('data-category');
      setCategoryEnabled(categoryId, checkbox.checked);
    }

    function handlePresetChange(event) {
      const presetId = event.target.value;
      if (!presetId) {
        updatePresetSelection();
        return;
      }
      applyPreset(presetId);
    }

    function updatePresetSelection() {
      if (!presetSelectElement || isApplyingPreset) {
        return;
      }
      const active = Array.from(poiManager.activeCategories).sort();
      let matched = '';
      Object.entries(LAYER_PRESETS).some(([presetId, preset]) => {
        const presetCategories = preset.categories.filter((id) => POI_CATEGORIES[id]).sort();
        if (
          presetCategories.length === active.length &&
          presetCategories.every((value, index) => value === active[index])
        ) {
          matched = presetId;
          return true;
        }
        return false;
      });
      presetSelectElement.value = matched;
    }

    function applyPreset(presetId) {
      const preset = LAYER_PRESETS[presetId];
      if (!preset) {
        return;
      }
      isApplyingPreset = true;
      cancelPendingPOILoad();
      disableAllCategories({ triggerLoad: false, persist: false, skipPresetSync: true });
      preset.categories.forEach((categoryId) => {
        if (POI_CATEGORIES[categoryId]) {
          setCategoryEnabled(categoryId, true, { triggerLoad: false, persist: false, skipPresetSync: true });
        }
      });
      saveLayerPreferences();
      isApplyingPreset = false;
      updatePresetSelection();
      loadPOIForCurrentView(true);
    }

    function enableAllCategories() {
      cancelPendingPOILoad();
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        setCategoryEnabled(categoryId, true, { triggerLoad: false, persist: false, skipPresetSync: true });
      });
      saveLayerPreferences();
      updatePresetSelection();
      loadPOIForCurrentView(true);
    }

    function disableAllCategories(options = {}) {
      const { triggerLoad = true, persist = true, skipPresetSync = false } = options;
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        setCategoryEnabled(categoryId, false, { triggerLoad: false, persist: false, skipPresetSync: true });
      });
      if (persist) {
        saveLayerPreferences();
      }
      if (!skipPresetSync) {
        updatePresetSelection();
      }
      if (triggerLoad) {
        clearAllPOILayers();
        hideLayersIndicators();
      }
    }

    function setCategoryEnabled(categoryId, enabled, options = {}) {
      const { triggerLoad = true, persist = true, skipPresetSync = false } = options;
      const category = POI_CATEGORIES[categoryId];
      if (!category) {
        return;
      }
      const isActive = poiManager.activeCategories.has(categoryId);
      if (enabled === isActive) {
        setCategoryCheckboxState(categoryId, enabled);
        return;
      }
      if (enabled) {
        poiManager.activeCategories.add(categoryId);
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
        poiManager.counts.set(categoryId, poiManager.counts.get(categoryId) || 0);
        setCategoryCheckboxState(categoryId, true);
      } else {
        poiManager.activeCategories.delete(categoryId);
        const layerGroup = poiManager.layerGroups.get(categoryId);
        if (layerGroup) {
          layerGroup.clearLayers();
          if (map.hasLayer(layerGroup)) {
            map.removeLayer(layerGroup);
          }
        }
        poiManager.counts.set(categoryId, 0);
        setCategoryCheckboxState(categoryId, false);
      }
      if (persist) {
        saveLayerPreferences();
      }
      if (!skipPresetSync) {
        updatePresetSelection();
      }
      updateCategoryCountUI(categoryId, poiManager.counts.get(categoryId) || 0);
      if (triggerLoad) {
        cancelPendingPOILoad();
        loadPOIForCurrentView(true);
      }
    }

    function clearAllPOILayers() {
      poiManager.layerGroups.forEach((layerGroup, categoryId) => {
        layerGroup.clearLayers();
        if (!poiManager.activeCategories.has(categoryId) && map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
      });
      poiManager.counts.clear();
      updateAllPOICounts();
    }

    function cancelPendingPOILoad() {
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
        poiManager.debounceTimer = null;
      }
      if (poiManager.abortController) {
        poiManager.abortController.abort();
        poiManager.abortController = null;
      }
      poiManager.loading = false;
      hideLayersLoading();
    }

    function getMinZoomForActiveCategories() {
      let minZoom = POI_SETTINGS.minZoomDefault;
      poiManager.activeCategories.forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (category && category.minZoom) {
          minZoom = Math.max(minZoom, category.minZoom);
        }
      });
      return minZoom;
    }

    function isBoundsTooLarge(bounds) {
      const north = bounds.getNorth();
      const south = bounds.getSouth();
      const east = bounds.getEast();
      const west = bounds.getWest();
      const latDiff = Math.abs(north - south);
      const lngDiff = Math.abs(east - west);
      return latDiff * lngDiff > POI_SETTINGS.areaLimitDegSq;
    }

    function handlePOIViewportChange() {
      if (!poiManager.enabled) {
        return;
      }
      // If user zoomed sufficiently, hide the zoom-info alert immediately
      try {
        if (typeof map !== 'undefined' && map && typeof map.getZoom === 'function') {
          if (map.getZoom() >= 13) {
            hideLayersZoomInfo();
          }
        }
      } catch (e) {
        // ignore
      }
      if (poiManager.suppressRefreshPrompt) {
        poiManager.suppressRefreshPrompt = false;
        return;
      }
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
      }
      poiManager.debounceTimer = setTimeout(() => {
        if (poiManager.activeCategories.size === 0 || poiManager.loading) {
          poiManager.refreshPending = false;
          hidePoiRefreshButton();
          return;
        }
        poiManager.refreshPending = true;
        showPoiRefreshButton();
      }, POI_SETTINGS.debounceMs);
    }

    function buildCacheKey(bounds, activeCategories) {
      const precision = 3;
      const boundsKey = [
        bounds.getSouth().toFixed(precision),
        bounds.getWest().toFixed(precision),
        bounds.getNorth().toFixed(precision),
        bounds.getEast().toFixed(precision)
      ].join(',');
      const categoriesKey = Array.from(activeCategories).sort().join(',');
      return `${boundsKey}|${categoriesKey}`;
    }

    function buildMultiCategoryOverpassQuery(bounds, activeCategories) {
      if (!activeCategories || activeCategories.size === 0) {
        return null;
      }
      const south = bounds.getSouth();
      const west = bounds.getWest();
      const north = bounds.getNorth();
      const east = bounds.getEast();
      const bbox = `${south},${west},${north},${east}`;
      const queryParts = [];
      Array.from(activeCategories).forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          return;
        }
        const required = Object.entries(category.tags);
        const excludes = Object.entries(category.excludeTags || {});
        const filters = required
          .map(([key, value]) => `["${key}"="${value}"]`)
          .join('');
        const excludeFilters = excludes
          .map(([key, value]) => `["${key}"!="${value}"]`)
          .join('');
        ['node', 'way', 'relation'].forEach((type) => {
          queryParts.push(`${type}${filters}${excludeFilters};`);
        });
      });
      if (queryParts.length === 0) {
        return null;
      }
      return `
        [out:json][timeout:25][bbox:${bbox}];
        (
          ${queryParts.join('\n          ')}
        );
        out center;
      `.trim();
    }

    async function loadPOIForCurrentView(force = false) {
      if (!poiManager.enabled) {
        return;
      }
      if (poiManager.loading && !force) {
        return;
      }
      if (poiManager.activeCategories.size === 0) {
        clearAllPOILayers();
        hideLayersIndicators();
        return;
      }
      const bounds = map.getBounds();
      const minZoom = getMinZoomForActiveCategories();
      if (map.getZoom() < minZoom) {
        clearAllPOILayers();
        showLayersZoomInfo(minZoom);
        hideLayersLoading();
        return;
      }
      if (isBoundsTooLarge(bounds)) {
        clearAllPOILayers();
        showLayersError('Zone trop grande, veuillez zoomer davantage.');
        hideLayersLoading();
        return;
      }
      hideLayersZoomInfo();
      hideLayersError();
      hideLayersInfo();
      const cacheKey = buildCacheKey(bounds, poiManager.activeCategories);
      const cached = poiCache.get(cacheKey);
      if (cached) {
        displayMultiCategoryPOIs(cached);
        return;
      }
      const requestId = ++poiManager.currentRequestId;
      poiManager.loading = true;
      showLayersLoading();
      try {
        const pois = await fetchPOIsFromOverpass(bounds, poiManager.activeCategories);
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiCache.set(cacheKey, pois);
        poiCache.prune(POI_SETTINGS.maxCacheEntries);
        displayMultiCategoryPOIs(pois);
        poiManager.stats.totalLoaded += pois.length;
        poiManager.stats.requestCount += 1;
      } catch (error) {
        if (error && error.name === 'AbortError') {
          return;
        }
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiManager.stats.errorCount += 1;
        clearAllPOILayers();
        showLayersError(error?.message || 'Impossible de charger les POI.');
      } finally {
        if (poiManager.currentRequestId === requestId) {
          poiManager.loading = false;
          hideLayersLoading();
          poiManager.abortController = null;
        }
      }
    }

    async function enforceRequestThrottle() {
      const now = Date.now();
      const elapsed = now - poiRequestLimiter.lastRequest;
      if (elapsed < poiRequestLimiter.minInterval) {
        await new Promise((resolve) => setTimeout(resolve, poiRequestLimiter.minInterval - elapsed));
      }
      poiRequestLimiter.lastRequest = Date.now();
    }

    async function fetchPOIsFromOverpass(bounds, activeCategories) {
      const query = buildMultiCategoryOverpassQuery(bounds, activeCategories);
      if (!query) {
        return [];
      }
      let lastError = null;
      const activeSnapshot = new Set(activeCategories);
      for (let attempt = 0; attempt <= POI_SETTINGS.maxRetries; attempt++) {
        const endpoint = OVERPASS_ENDPOINTS[attempt % OVERPASS_ENDPOINTS.length];
        const controller = new AbortController();
        poiManager.abortController = controller;
        let timedOut = false;
        const timeoutId = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, POI_SETTINGS.requestTimeoutMs);
        try {
          await enforceRequestThrottle();
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `data=${encodeURIComponent(query)}`,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            if (response.status === 429) {
              lastError = new Error('Trop de requ√™tes. Veuillez patienter quelques instants.');
            } else if (response.status === 504) {
              lastError = new Error('Timeout du serveur. Essayez de zoomer davantage.');
            } else {
              lastError = new Error(`Erreur HTTP ${response.status}`);
            }
            continue;
          }
          const data = await response.json();
          const elements = Array.isArray(data?.elements) ? data.elements : [];
          const parsed = elements
            .map((element) => parseMultiCategoryPOI(element, activeSnapshot))
            .filter(Boolean);
          return parsed;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            if (timedOut) {
              lastError = new Error('Timeout de la requ√™te');
              continue;
            }
            throw error;
          }
          lastError =
            error instanceof Error
              ? error
              : new Error('Erreur inconnue lors du chargement des POI.');
        } finally {
          if (poiManager.abortController === controller) {
            poiManager.abortController = null;
          }
        }
      }
      throw lastError || new Error('Impossible de r√©cup√©rer les POI.');
    }

    function parseMultiCategoryPOI(element, activeCategoryIds) {
      if (!element || !element.tags) {
        return null;
      }
      const tags = element.tags;
      let lat;
      let lon;
      if (element.type === 'node') {
        lat = element.lat;
        lon = element.lon;
      } else if (element.center) {
        lat = element.center.lat;
        lon = element.center.lon;
      }
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }
      const orderedCategories = Array.from(activeCategoryIds).sort();
      for (const categoryId of orderedCategories) {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          continue;
        }
        const requiredEntries = Object.entries(category.tags);
        let matches = true;
        for (const [key, value] of requiredEntries) {
          if (tags[key] !== value) {
            matches = false;
            break;
          }
        }
        if (!matches) {
          continue;
        }
        const excludeEntries = Object.entries(category.excludeTags || {});
        let excluded = false;
        for (const [key, value] of excludeEntries) {
          if (tags[key] === value) {
            excluded = true;
            break;
          }
        }
        if (excluded) {
          continue;
        }
        const addressParts = [];
        if (tags['addr:housenumber'] && tags['addr:street']) {
          addressParts.push(`${tags['addr:housenumber']} ${tags['addr:street']}`);
        } else if (tags['addr:street']) {
          addressParts.push(tags['addr:street']);
        }
        if (tags['addr:city']) {
          addressParts.push(tags['addr:city']);
        }
        const metadata = {
          opening_hours: tags.opening_hours || null,
          phone: tags.phone || tags.contact_phone || null,
          website: tags.website || tags.contact_website || null,
          capacity: tags.capacity || null,
          fee: tags.fee || null,
          access: tags.access || null,
          drinking_water: tags.drinking_water || null,
          shower: tags.shower || null,
          toilets: tags.toilets || null,
          cuisine: tags.cuisine || null
        };
        return {
          id: element.id,
          osmType: element.type,
          lat,
          lon,
          categoryId,
          name: tags.name || 'Sans nom',
          address: addressParts.join(', ') || null,
          metadata
        };
      }
      return null;
    }

    function createMultiCategoryPOIMarker(poi, category) {
      if (!poi || !category) {
        return null;
      }
      const icon = L.divIcon({
        className: 'poi-marker',
        html: `
          <div class="poi-marker-inner" style="background-color: ${category.color};">
            <span class="poi-marker-icon">${category.icon}</span>
          </div>
        `,
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      });
      const marker = L.marker([poi.lat, poi.lon], {
        icon,
        opacity: 0.9,
        title: poi.name
      });
      marker.bindPopup(createMultiCategoryPOIPopup(poi, category), {
        maxWidth: 320,
        className: 'poi-popup-container'
      });
      if (poi.name) {
        marker.bindTooltip(poi.name, {
          direction: 'top',
          offset: [0, -14]
        });
      }
      return marker;
    }

    function createMultiCategoryPOIPopup(poi, category) {
      const meta = poi.metadata || {};
      let html = `
        <div class="poi-popup">
          <div class="poi-header">
            <span class="poi-icon" aria-hidden="true">${category.icon}</span>
            <strong class="poi-name">${escapeHtml(poi.name)}</strong>
          </div>
          <div class="poi-details">
            <div class="poi-row">
              <span class="poi-label">Type :</span>
              <span class="poi-value">${escapeHtml(category.label)}</span>
            </div>`;
      if (poi.address) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Adresse :</span>
              <span class="poi-value">${escapeHtml(poi.address)}</span>
            </div>`;
      }
      if (meta.opening_hours) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Horaires :</span>
              <span class="poi-value">${escapeHtml(meta.opening_hours)}</span>
            </div>`;
      }
      if (meta.phone) {
        html += `
            <div class="poi-row">
              <span class="poi-label">T√©l√©phone :</span>
              <span class="poi-value"><a href="tel:${escapeHtml(meta.phone)}">${escapeHtml(meta.phone)}</a></span>
            </div>`;
      }
      if (meta.website) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Site web :</span>
              <span class="poi-value"><a href="${escapeHtml(meta.website)}" target="_blank" rel="noopener">üîó</a></span>
            </div>`;
      }
      if (meta.capacity) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Capacit√© :</span>
              <span class="poi-value">${escapeHtml(meta.capacity)}</span>
            </div>`;
      }
      if (meta.fee) {
        const feeLabel = meta.fee === 'yes' ? 'Payant' : meta.fee === 'no' ? 'Gratuit' : escapeHtml(meta.fee);
        html += `
            <div class="poi-row">
              <span class="poi-label">Tarif :</span>
              <span class="poi-value">${feeLabel}</span>
            </div>`;
      }
      if (meta.access && meta.access !== 'yes') {
        html += `
            <div class="poi-row">
              <span class="poi-label">Acc√®s :</span>
              <span class="poi-value">${escapeHtml(meta.access)}</span>
            </div>`;
      }
      if (meta.cuisine) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Cuisine :</span>
              <span class="poi-value">${escapeHtml(meta.cuisine)}</span>
            </div>`;
      }
      const services = [];
      if (meta.drinking_water === 'yes') services.push('üíß Eau potable');
      if (meta.shower === 'yes') services.push('üöø Douches');
      if (meta.toilets === 'yes') services.push('üöª Toilettes');
      if (services.length > 0) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Services :</span>
              <span class="poi-value">${services.join(' ‚Ä¢ ')}</span>
            </div>`;
      }
      html += `
          </div>
          <div class="poi-footer">
            <small>
              <a href="https://www.openstreetmap.org/${poi.osmType}/${poi.id}" target="_blank" rel="noopener noreferrer">
                Voir sur OpenStreetMap ‚Üó
              </a>
            </small>
          </div>
        </div>`;
      return html;
    }

    function displayMultiCategoryPOIs(pois) {
      poiManager.counts.clear();
      poiManager.layerGroups.forEach((layerGroup, categoryId) => {
        if (poiManager.activeCategories.has(categoryId)) {
          layerGroup.clearLayers();
        } else if (map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
      });
      if (!Array.isArray(pois) || pois.length === 0) {
        updateAllPOICounts();
        hideLayersInfo();
        return;
      }
      let workingPois = pois.slice();
      let totalLimited = false;
      if (workingPois.length > POI_SETTINGS.maxTotalItems) {
        workingPois = workingPois.slice(0, POI_SETTINGS.maxTotalItems);
        totalLimited = true;
      }
      const grouped = new Map();
      workingPois.forEach((poi) => {
        if (!poi || !poiManager.activeCategories.has(poi.categoryId)) {
          return;
        }
        if (!grouped.has(poi.categoryId)) {
          grouped.set(poi.categoryId, []);
        }
        grouped.get(poi.categoryId).push(poi);
      });
      let categoryLimited = false;
      let total = 0;
      poiManager.activeCategories.forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          return;
        }
        const items = grouped.get(categoryId) || [];
        let limitedItems = items;
        if (items.length > POI_SETTINGS.maxItemsPerCategory) {
          limitedItems = items.slice(0, POI_SETTINGS.maxItemsPerCategory);
          categoryLimited = true;
        }
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
        layerGroup.clearLayers();
        limitedItems.forEach((poi) => {
          const marker = createMultiCategoryPOIMarker(poi, category);
          if (marker) {
            marker.poi = poi;
            layerGroup.addLayer(marker);
          }
        });
        poiManager.counts.set(categoryId, limitedItems.length);
        total += limitedItems.length;
      });
      updateAllPOICounts();
      if (total === 0) {
        hideLayersInfo();
      } else if (totalLimited) {
        showLayersInfo(
          `Trop de points d'int√©r√™t (${pois.length}), limitation √† ${POI_SETTINGS.maxTotalItems}. Zoomez pour plus de d√©tails.`
        );
      } else if (categoryLimited) {
        showLayersInfo('Certaines cat√©gories contiennent de nombreux POI. Zoomez pour plus de d√©tails.');
      } else {
        hideLayersInfo();
      }
      poiManager.stats.currentDisplayed = total;
    }

    function initPOIManager() {
      const prefs = loadLayerPreferences();
      poiManager.expandedGroups = prefs ? new Set(prefs.expanded) : getDefaultExpandedGroups();
      poiManager.activeCategories = prefs ? new Set(prefs.active) : getDefaultActiveCategories();
      renderLayersSection();
      poiManager.activeCategories.forEach((categoryId) => {
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
      });
      updatePresetSelection();
      poiManager.enabled = true;
      map.on('moveend', handlePOIViewportChange);
      map.on('zoomend', handlePOIViewportChange);
      if (poiManager.activeCategories.size > 0) {
        loadPOIForCurrentView(true);
      } else {
        hideLayersIndicators();
      }
    }

    const map = L.map('map').setView([48.8566, 2.3522], 12);
  // Expose Leaflet map globally for style control
  window.map = map;


  // Initialiser le contr√¥le de style AVANT POI/GPX
  requestAnimationFrame(()=>{ if (window.initMapStyleControl) window.initMapStyleControl(); });

    map.zoomControl.setPosition('topright');

    // Couche de tuiles OpenStreetMap avec attribution obligatoire
    const fileInput = document.getElementById('file-input');
    const messageBox = document.getElementById('message');
    const gpxImportZone = document.getElementById('gpx-import-zone');
    const gpxEmptyState = document.getElementById('gpx-empty-state');
    const gpxLoadedState = document.getElementById('gpx-loaded-state');
    const gpxTraceFilename = document.getElementById('gpx-trace-filename');
    const gpxTraceDistance = document.getElementById('gpx-trace-distance');
    const gpxTraceElevation = document.getElementById('gpx-trace-elevation');
    const exportActionButton = document.getElementById('gpx-export-action');
    const replaceActionButton = document.getElementById('gpx-replace-action');
    const clearTraceButton = document.getElementById('clear-trace-button');
    const exportModal = document.getElementById('export-modal');
    const exportModalBackdrop = document.getElementById('export-modal-backdrop');
    const exportModalClose = document.getElementById('export-modal-close');
    const exportModalCancel = document.getElementById('export-modal-cancel');
    const exportModalDownload = document.getElementById('export-modal-download');
    const exportFileNameInput = document.getElementById('export-file-name');
    const exportIncludeWaypoints = document.getElementById('export-include-waypoints');
    const exportPreviewName = document.getElementById('export-preview-name');
    const exportWaypointsLabel = document.getElementById('export-waypoints-label');
    const toolsPanel = document.getElementById('tools-panel');
    const menuToggle = document.getElementById('menu-toggle');
    const closePanel = document.getElementById('close-panel');
    const traceFileNameLabel = document.getElementById('file-name');
    const waypointsSection = document.getElementById('waypoints-section');
    const waypointsList = document.getElementById('waypoints-list');
    const waypointCountLabel = document.getElementById('waypoint-count');
    const clearWaypointsButton = document.getElementById('clear-waypoints');
    const traceInfoSection = document.getElementById('trace-info-section');
    const traceNameLabel = document.getElementById('trace-name');
    const pointCountLabel = document.getElementById('point-count');
    const traceTypeLabel = document.getElementById('trace-type');
    const traceDistanceLabel = document.getElementById('trace-distance');
    const traceElevationGainLabel = document.getElementById('trace-elevation-gain');
    const traceElevationLossLabel = document.getElementById('trace-elevation-loss');
    const traceAltitudeRangeLabel = document.getElementById('trace-altitude-range');
    const ariaDistance = document.getElementById('aria-distance');
    const ariaDPlus = document.getElementById('aria-d-plus');
    const ariaMin = document.getElementById('aria-min');
    const ariaMax = document.getElementById('aria-max');
    const profileDistanceValue = document.getElementById('profile-distance');
    const profileElevationGainValue = document.getElementById('profile-elevation-gain');
    const profileElevationLossValue = document.getElementById('profile-elevation-loss');
    const elevationProfile = document.getElementById('elevation-profile');
    const elevationHeader = document.getElementById('elevation-header');
    const elevationCollapseButton = document.getElementById('elevation-collapse');
    const elevationContent = document.getElementById('elevation-content');
    const elevationCanvas = document.getElementById('elevation-canvas');
    const elevationTooltip = document.getElementById('elevation-tooltip');
    const poiRefreshButton = document.getElementById('poi-refresh-button');
    const miniElevationProfile = document.getElementById('mini-elevation-profile');
    const miniElevationCanvas = document.getElementById('mini-elevation-canvas');
    const miniAriaMin = document.getElementById('mini-aria-min');
    const miniAriaMax = document.getElementById('mini-aria-max');

    // Activer le bouton "Recharger les POI"
    if (poiRefreshButton) {
      poiRefreshButton.addEventListener('click', () => {
        // R√©initialise l'√©tat et recharge les POI pour la vue courante
        poiManager.refreshPending = false;
        hidePoiRefreshButton();
        loadPOIForCurrentView(true);
      });
    }


    let backdropElement = null;

    const waypointLayerGroup = L.layerGroup().addTo(map);
// === PERSISTENCE WAYPOINTS ‚Äî debounce & group hooks (defined early) ===
if (typeof window.__saveWpTimer === 'undefined') window.__saveWpTimer = null;
function saveTraceDebounced(delay = 120) {
  if (typeof saveTraceToLocalStorage !== 'function') return;
  clearTimeout(window.__saveWpTimer);
  window.__saveWpTimer = setTimeout(() => {
    try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); }
  }, delay);
}
function attachWaypointPersistence() {
  try {
    if (!waypointLayerGroup || typeof waypointLayerGroup.on !== 'function') return;
    waypointLayerGroup.off('layeradd', saveTraceDebounced);
    waypointLayerGroup.off('layerremove', saveTraceDebounced);
    waypointLayerGroup.on('layeradd', () => saveTraceDebounced());
    waypointLayerGroup.on('layerremove', () => saveTraceDebounced());
    saveTraceDebounced(10);
  } catch (e) { console.warn('attachWaypointPersistence:', e); }
}
// Attach once after map init
attachWaypointPersistence();
    let waypointCounter = 1;

let gpxLayerGroup = null;
let arrowLayerGroup = null;
let currentGpxDocument = null;
let currentGpxFileName = '';
let currentGeojson = null;
let currentTraceName = '';
let traceNameSource = '';

// Exposer les variables importantes sur window pour la sauvegarde
window.currentGpxDocument = null;
window.currentGpxFileName = '';
window.currentTraceName = '';
window.traceNameSource = '';
let currentElevationData = null;
let elevationHoverMarker = null;
let elevationMouseMoveHandler = null;
let elevationMouseLeaveHandler = null;


    setExportAvailability(false);
    updateWaypointsList();
    updateTraceInfo(null);

    // Debounced refresh of elevation profiles when waypoints change
    if (typeof window.__refreshProfileTimer === 'undefined') window.__refreshProfileTimer = null;
    function refreshElevationProfiles(delay = 120) {
      clearTimeout(window.__refreshProfileTimer);
      window.__refreshProfileTimer = setTimeout(() => {
        try {
          // redraw main profile and mini profile
          if (typeof renderElevationProfile === 'function') {
            renderElevationProfile();
          }
          if (typeof updateMiniElevationProfile === 'function') {
            updateMiniElevationProfile();
          }
        } catch (e) {
          console.warn('refreshElevationProfiles:', e);
        }
      }, delay);
    }

    /**
     * Affiche un message utilisateur discret.
     * @param {string} text
     * @param {boolean} isError
     */
    function showMessage(text, isError = false, isHtml = false) {
      if (!messageBox) {
        return;
      }
      const content = text == null ? '' : String(text);
      const trimmed = content.trim();
      if (!trimmed) {
        messageBox.classList.add('hidden');
        messageBox.textContent = '';
        messageBox.classList.remove('error');
        return;
      }
      if (isHtml) {
        messageBox.innerHTML = content;
      } else {
        messageBox.textContent = trimmed;
      }
      messageBox.classList.remove('hidden');
      messageBox.classList.toggle('error', Boolean(isError));
    }

    /**
     * Efface les couches GPX pr√©c√©demment ajout√©es.
     */
    function clearPreviousLayers() {  try { removeTraceEndpointMarkers(); } catch(e) { console.warn('removeTraceEndpointMarkers:', e); }

      if (gpxLayerGroup) {
        map.removeLayer(gpxLayerGroup);
        gpxLayerGroup = null;
      }
      if (arrowLayerGroup) {
        map.removeLayer(arrowLayerGroup);
        arrowLayerGroup = null;
      }
      waypointLayerGroup.clearLayers();
      waypointCounter = 1;
      currentGeojson = null;
      updateWaypointsList();
      updateTraceInfo(null);
      resetElevationDisplay();
    }

    function setExportAvailability(isEnabled) {
      const hasTrace = Boolean(isEnabled);
      if (exportActionButton) {
        exportActionButton.disabled = !hasTrace;
      }
      if (replaceActionButton) {
        replaceActionButton.disabled = !hasTrace;
      }
      if (clearTraceButton) {
        clearTraceButton.disabled = !hasTrace;
        if (typeof clearTraceButton.__resetConfirmState === 'function') {
          clearTraceButton.__resetConfirmState();
        }
      }
      if (gpxEmptyState) {
        gpxEmptyState.classList.toggle('hidden', hasTrace);
      }
      if (gpxLoadedState) {
        gpxLoadedState.classList.toggle('hidden', !hasTrace);
      }
      if (!hasTrace) {
        if (gpxTraceFilename) {
          gpxTraceFilename.textContent = 'Aucune trace charg√©e';
        }
        if (gpxTraceDistance) {
          gpxTraceDistance.textContent = '‚Äî';
        }
        if (gpxTraceElevation) {
          gpxTraceElevation.textContent = '‚Äî';
        }
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '‚Äî';
        }
        resetElevationDisplay();
      } else if (traceFileNameLabel && currentGpxFileName) {
        traceFileNameLabel.textContent = currentGpxFileName;
      }
    }

    function normalizeLatLngSegments(latlngs) {
      if (!Array.isArray(latlngs)) {
        return [];
      }
      if (latlngs.length === 0) {
        return [];
      }
      const first = latlngs[0];
      if (Array.isArray(first)) {
        return latlngs;
      }
      return [latlngs];
    }

    function computeBearingDegrees(startLatLng, endLatLng) {
      const toRadians = (value) => (value * Math.PI) / 180;
      const toDegrees = (value) => (value * 180) / Math.PI;
      const phi1 = toRadians(startLatLng.lat);
      const phi2 = toRadians(endLatLng.lat);
      const deltaLambda = toRadians(endLatLng.lng - startLatLng.lng);
      const y = Math.sin(deltaLambda) * Math.cos(phi2);
      const x =
        Math.cos(phi1) * Math.sin(phi2) -
        Math.sin(phi1) * Math.cos(phi2) * Math.cos(deltaLambda);
      const theta = Math.atan2(y, x);
      return (toDegrees(theta) + 360) % 360;
    }

    function escapeHtml(value) {
      if (value === null || value === undefined) {
        return '';
      }
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function sanitizeFileName(name) {
      if (!name) {
        return 'trace';
      }
      const sanitized =
        name
          .replace(/[<>:"/\\|?*]/g, '_')
          .replace(/\s+/g, '_')
          .replace(/_+/g, '_')
          .replace(/^_|_$/g, '')
          .substring(0, 100) || 'trace';
      return sanitized;
    }

    function extractTraceName(xmlDoc, fileName) {
      if (xmlDoc) {
        const trackNames = xmlDoc.querySelectorAll('trk > name');
        for (const trackName of trackNames) {
          const value = trackName.textContent && trackName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-track' };
          }
        }

        const routeNames = xmlDoc.querySelectorAll('rte > name');
        for (const routeName of routeNames) {
          const value = routeName.textContent && routeName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-route' };
          }
        }

        const metadataName = xmlDoc.querySelector('metadata > name');
        if (metadataName) {
          const value = metadataName.textContent && metadataName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-metadata' };
          }
        }
      }

      if (fileName) {
        const withoutExtension = fileName.replace(/\.gpx$/i, '');
        if (withoutExtension.trim()) {
          return { name: withoutExtension.trim(), source: 'filename' };
        }
      }

      return { name: 'Trace sans nom', source: 'default' };
    }

    function displayTraceName(traceName, source) {
      if (!traceNameLabel) {
        return;
      }
      const safeName = traceName || '‚Äî';
      traceNameLabel.textContent = safeName;
      let tooltip = '';
      switch (source) {
        case 'gpx-track':
        case 'gpx-route':
        case 'gpx-metadata':
          tooltip = 'Nom extrait du fichier GPX';
          break;
        case 'filename':
          tooltip = 'Nom bas√© sur le nom de fichier';
          break;
        case 'default':
        default:
          tooltip = 'Nom par d√©faut (aucune information disponible)';
          break;
      }
      traceNameLabel.setAttribute('title', tooltip);
      traceNameLabel.className = `trace-name trace-name--${source || 'default'}`;
    }

    function haversineDistance(pointA, pointB) {
      if (!pointA || !pointB) {
        return 0;
      }
      const R = 6371000;
      const lat1 = (pointA.lat * Math.PI) / 180;
      const lat2 = (pointB.lat * Math.PI) / 180;
      const dLat = ((pointB.lat - pointA.lat) * Math.PI) / 180;
      const dLng = ((pointB.lng - pointA.lng) * Math.PI) / 180;

      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function calculateElevationStats(points) {
      if (!Array.isArray(points) || points.length === 0) {
        return null;
      }

      let elevationGain = 0;
      let elevationLoss = 0;
      let minElevation = Infinity;
      let maxElevation = -Infinity;
      let sumElevation = 0;

      points.forEach((point, index) => {
        const elevation = point.elevation;
        if (elevation < minElevation) {
          minElevation = elevation;
        }
        if (elevation > maxElevation) {
          maxElevation = elevation;
        }
        sumElevation += elevation;

        if (index > 0) {
          const diff = elevation - points[index - 1].elevation;
          if (diff > 0) {
            elevationGain += diff;
          } else if (diff < 0) {
            elevationLoss += Math.abs(diff);
          }
        }
      });

      return {
        totalDistance: Math.round(points[points.length - 1].distance),
        elevationGain: Math.round(elevationGain),
        elevationLoss: Math.round(elevationLoss),
        minElevation: Math.round(minElevation),
        maxElevation: Math.round(maxElevation),
        avgElevation: Math.round(sumElevation / points.length)
      };
    }

    function simplifyElevationData(points, maxPoints = 1500) {
      if (!Array.isArray(points) || points.length <= maxPoints) {
        return points || [];
      }
      const step = Math.max(1, Math.floor(points.length / maxPoints));
      const simplified = [];
      for (let i = 0; i < points.length; i += step) {
        simplified.push(points[i]);
      }
      if (simplified[simplified.length - 1] !== points[points.length - 1]) {
        simplified.push(points[points.length - 1]);
      }
      return simplified;
    }

    function extractElevationData(geojson, gpxDoc) {
      if (!geojson || !Array.isArray(geojson.features) || !gpxDoc) {
        return null;
      }

      const trackPoints = Array.from(gpxDoc.querySelectorAll('trkpt, rtept'));
      const elevationMap = new Map();
      trackPoints.forEach((trkpt) => {
        const lat = parseFloat(trkpt.getAttribute('lat'));
        const lng = parseFloat(trkpt.getAttribute('lon'));
        const eleNode = trkpt.querySelector('ele');
        if (!Number.isFinite(lat) || !Number.isFinite(lng) || !eleNode) {
          return;
        }
        const elevation = parseFloat(eleNode.textContent);
        if (!Number.isFinite(elevation)) {
          return;
        }
        const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
        elevationMap.set(key, elevation);
      });

      if (elevationMap.size === 0) {
        return null;
      }

      const points = [];
      let previousPoint = null;
      let cumulativeDistance = 0;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
          const elevation = elevationMap.get(key);
          if (!Number.isFinite(elevation)) {
            previousPoint = { lat, lng };
            return;
          }

          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }

          points.push({
            distance: cumulativeDistance,
            elevation,
            lat,
            lng,
            index: points.length
          });

          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (points.length < 2) {
        return null;
      }

      const stats = calculateElevationStats(points);
      if (!stats) {
        return null;
      }

      const simplifiedPoints = simplifyElevationData(points);
      return { points: simplifiedPoints, stats };
    }

    function calculateDistanceOnly(geojson) {
      if (!geojson || !Array.isArray(geojson.features)) {
        return null;
      }
      let cumulativeDistance = 0;
      let previousPoint = null;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }
          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (cumulativeDistance === 0) {
        return null;
      }
      return { distance: cumulativeDistance };
    }

    function updateElevationStats(stats) {
      if (
        !traceDistanceLabel ||
        !traceElevationGainLabel ||
        !traceElevationLossLabel ||
        !traceAltitudeRangeLabel ||
        !profileDistanceValue ||
        !profileElevationGainValue ||
        !profileElevationLossValue
      ) {
        return;
      }

      if (!stats) {
        traceDistanceLabel.textContent = '‚Äî';
        traceElevationGainLabel.textContent = '‚Äî';
        traceElevationLossLabel.textContent = '‚Äî';
        traceAltitudeRangeLabel.textContent = '‚Äî';
        profileDistanceValue.textContent = '‚Äî';
        profileElevationGainValue.textContent = '‚Äî';
        profileElevationLossValue.textContent = '‚Äî';
        if (ariaDistance) ariaDistance.textContent = '‚Äî';
        if (ariaDPlus) ariaDPlus.textContent = '‚Äî';
        if (ariaMin) ariaMin.textContent = '‚Äî';
        if (ariaMax) ariaMax.textContent = '‚Äî';
        if (gpxTraceDistance) gpxTraceDistance.textContent = '‚Äî';
        if (gpxTraceElevation) gpxTraceElevation.textContent = '‚Äî';
        if (elevationProfile) {
          elevationProfile.classList.remove('visible');
          elevationProfile.setAttribute('aria-hidden', 'true');
        }
        updateMiniElevationProfile();
        return;
      }

      const distanceKm = stats.totalDistance / 1000;
      const distanceLabel = `${distanceKm.toFixed(2)} km`;
      traceDistanceLabel.textContent = distanceLabel;
      traceElevationGainLabel.textContent = `${stats.elevationGain} m`;
      traceElevationLossLabel.textContent = `${stats.elevationLoss} m`;
      traceAltitudeRangeLabel.textContent = `${stats.minElevation} m - ${stats.maxElevation} m`;
      if (gpxTraceDistance) {
        gpxTraceDistance.textContent = distanceLabel;
      }
      if (gpxTraceElevation) {
        gpxTraceElevation.textContent = `D+ ${stats.elevationGain} m`;
      }

      profileDistanceValue.textContent = `${distanceKm.toFixed(2)} km`;
      profileElevationGainValue.textContent = `${stats.elevationGain} m`;
      profileElevationLossValue.textContent = `${stats.elevationLoss} m`;

      if (ariaDistance) ariaDistance.textContent = `${distanceKm.toFixed(2)} km`;
      if (ariaDPlus) ariaDPlus.textContent = `${stats.elevationGain} m`;
      if (ariaMin) ariaMin.textContent = `${stats.minElevation} m`;
      if (ariaMax) ariaMax.textContent = `${stats.maxElevation} m`;

      if (elevationProfile) {
        elevationProfile.classList.add('visible');
        elevationProfile.setAttribute('aria-hidden', 'false');
      }
      updateMiniElevationProfile();
    }

    function resetElevationDisplay() {
      currentElevationData = null;
      if (elevationHoverMarker) {
        map.removeLayer(elevationHoverMarker);
        elevationHoverMarker = null;
      }
      removeElevationInteraction();
      updateElevationStats(null);
      if (elevationTooltip) {
        elevationTooltip.style.display = 'none';
      }
      if (elevationContent && elevationCanvas) {
        const ctx = elevationCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, elevationCanvas.width, elevationCanvas.height);
        }
      }
      if (elevationProfile) {
        elevationProfile.classList.remove('collapsed');
        elevationProfile.setAttribute('aria-hidden', 'true');
      }
      if (elevationCollapseButton) {
        elevationCollapseButton.setAttribute('aria-expanded', 'true');
        elevationCollapseButton.setAttribute('aria-label', 'R√©duire le profil');
      }
      map.invalidateSize();
      if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
        window.roadbookManager.update();
      }
    }

    function drawElevationProfile(canvas, points, stats) {
      if (!canvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return;
      }

      const width = canvas.width;
      const height = canvas.height;

      ctx.clearRect(0, 0, width, height);

      const margin = { top: 20, right: 20, bottom: 40, left: 60 };
      const chartWidth = Math.max(10, width - margin.left - margin.right);
      const chartHeight = Math.max(10, height - margin.top - margin.bottom);
      const maxDistance = stats.totalDistance || 1;
      const minEle = stats.minElevation - 20;
      const maxEle = stats.maxElevation + 20;

      const xScale = (distance) =>
        margin.left + (Math.min(distance, maxDistance) / maxDistance) * chartWidth;
      const yScale = (elevation) =>
        margin.top + chartHeight - ((elevation - minEle) / (maxEle - minEle)) * chartHeight;

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.lineWidth = 1;

      const elevationStep = Math.max(10, Math.ceil((maxEle - minEle) / 5 / 50) * 50);
      for (let ele = Math.ceil(minEle / elevationStep) * elevationStep; ele <= maxEle; ele += elevationStep) {
        const y = yScale(ele);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(width - margin.right, y);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(`${Math.round(ele)} m`, margin.left - 5, y + 4);
      }

      const distanceStepRaw = Math.max(100, Math.ceil(maxDistance / 5 / 1000) * 1000);
      for (let dist = 0; dist <= maxDistance; dist += distanceStepRaw) {
        const x = xScale(dist);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, height - margin.bottom);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${(dist / 1000).toFixed(1)} km`, x, height - margin.bottom + 18);
      }

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.lineTo(xScale(points[points.length - 1].distance), height - margin.bottom);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, margin.top, 0, height - margin.bottom);
      gradient.addColorStop(0, 'rgba(25, 118, 210, 0.3)');
      gradient.addColorStop(1, 'rgba(25, 118, 210, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.strokeStyle = '#1976d2';
      ctx.lineWidth = 2;
      ctx.stroke();

      // --- Draw waypoints on profile ---
      try {
        if (typeof getWaypointMarkers === 'function') {
          const markers = getWaypointMarkers() || [];
          if (Array.isArray(markers) && markers.length > 0) {
            markers.forEach((marker, mi) => {
              try {
                const latlng = marker.getLatLng ? marker.getLatLng() : null;
                if (!latlng) return;

                // find the closest elevation point by geographic distance
                let closest = null;
                let closestDist = Infinity;
                for (let i = 0; i < points.length; i++) {
                  const p = points[i];
                  const d = haversineDistance({ lat: p.lat, lng: p.lng }, { lat: latlng.lat, lng: latlng.lng });
                  if (d < closestDist) {
                    closestDist = d;
                    closest = p;
                  }
                }
                if (!closest) return;

                const x = xScale(closest.distance);
                const y = yScale(closest.elevation);

                // vertical tick
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255,87,34,0.9)';
                ctx.lineWidth = 1;
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, height - margin.bottom);
                ctx.stroke();

                // small circle marker on the profile line
                ctx.beginPath();
                ctx.fillStyle = '#FF5722';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // label (waypoint name or index)
                const label = marker.waypointName || `WP ${mi + 1}`;
                ctx.fillStyle = '#212121';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                // draw background for readability
                const textWidth = ctx.measureText(label).width;
                ctx.fillStyle = 'rgba(255,255,255,0.85)';
                ctx.fillRect(x - textWidth / 2 - 6, margin.top + 4, textWidth + 12, 18);
                ctx.fillStyle = '#212121';
                ctx.fillText(label, x, margin.top + 16);
              } catch (e) {
                // ignore marker-specific errors
              }
            });
          }
        }
      } catch (e) {
        // ignore rendering errors so profile still draws
      }

      ctx.fillStyle = '#424242';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Distance (km)', width / 2, height - 8);

      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Altitude (m)', 0, 0);
      ctx.restore();
    }

    function drawMiniElevationProfile(canvas, points, stats) {
      if (!canvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      const parentWidth = canvas.offsetWidth || canvas.parentElement?.offsetWidth || 0;
      const parentHeight = canvas.offsetHeight || canvas.parentElement?.offsetHeight || 0;
      if (!parentWidth || !parentHeight) {
        return;
      }

      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(parentWidth * dpr);
      canvas.height = Math.floor(parentHeight * dpr);

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return;
      }

      ctx.save();
      ctx.scale(dpr, dpr);

      const width = parentWidth;
      const height = parentHeight;

      ctx.clearRect(0, 0, width, height);

      const margin = { top: 10, right: 10, bottom: 25, left: 40 };
      const chartWidth = Math.max(10, width - margin.left - margin.right);
      const chartHeight = Math.max(10, height - margin.top - margin.bottom);

      const maxDistance = stats.totalDistance || 1;
      const minEle = Math.min(stats.minElevation, stats.maxElevation) - 20;
      const maxEle = Math.max(stats.minElevation, stats.maxElevation) + 20;
      const range = Math.max(1, maxEle - minEle);

      const xScale = (distance) =>
        margin.left + (Math.min(distance, maxDistance) / maxDistance) * chartWidth;
      const yScale = (elevation) =>
        margin.top + chartHeight - ((elevation - minEle) / range) * chartHeight;

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.lineWidth = 1;
      const elevationSteps = 2;
      for (let i = 0; i <= elevationSteps; i++) {
        const ele = minEle + (range * i) / elevationSteps;
        const y = yScale(ele);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(width - margin.right, y);
        ctx.stroke();
        ctx.fillStyle = '#999';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(`${Math.round(ele)}m`, margin.left - 5, y + 3);
      }

      ctx.fillStyle = '#999';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('0km', margin.left, height - 5);
      ctx.fillText(`${(maxDistance / 1000).toFixed(1)}km`, width - margin.right, height - 5);

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.lineTo(xScale(points[points.length - 1].distance), height - margin.bottom);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, margin.top, 0, height - margin.bottom);
      gradient.addColorStop(0, 'rgba(25, 118, 210, 0.15)');
      gradient.addColorStop(1, 'rgba(25, 118, 210, 0.02)');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.strokeStyle = '#1976d2';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Draw compact waypoint markers on mini profile
      try {
        if (typeof getWaypointMarkers === 'function') {
          const markers = getWaypointMarkers() || [];
          markers.forEach((marker) => {
            try {
              const latlng = marker.getLatLng ? marker.getLatLng() : null;
              if (!latlng) return;
              let closest = null;
              let closestDist = Infinity;
              for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const d = haversineDistance({ lat: p.lat, lng: p.lng }, { lat: latlng.lat, lng: latlng.lng });
                if (d < closestDist) {
                  closestDist = d;
                  closest = p;
                }
              }
              if (!closest) return;
              const x = xScale(closest.distance);
              const y = yScale(closest.elevation);
              // tiny tick
              ctx.beginPath();
              ctx.strokeStyle = 'rgba(255,87,34,0.9)';
              ctx.lineWidth = 1;
              ctx.moveTo(x, y - 6);
              ctx.lineTo(x, y + 6);
              ctx.stroke();
              // small dot
              ctx.beginPath();
              ctx.fillStyle = '#FF5722';
              ctx.arc(x, y, 3, 0, Math.PI * 2);
              ctx.fill();
            } catch (e) {}
          });
        }
      } catch (e) {}

      ctx.restore();
    }

    function updateMiniElevationProfile() {
      if (!miniElevationProfile || !miniElevationCanvas) {
        return;
      }

      const hasData =
        currentElevationData &&
        Array.isArray(currentElevationData.points) &&
        currentElevationData.points.length >= 2 &&
        currentElevationData.stats;

      if (!hasData) {
        miniElevationProfile.style.display = 'none';
        if (miniAriaMin) miniAriaMin.textContent = '‚Äî';
        if (miniAriaMax) miniAriaMax.textContent = '‚Äî';
        return;
      }

      const simplified =
        typeof simplifyElevationData === 'function'
          ? simplifyElevationData(currentElevationData.points, 150)
          : currentElevationData.points;

      if (!Array.isArray(simplified) || simplified.length < 2) {
        miniElevationProfile.style.display = 'none';
        return;
      }

      miniElevationProfile.style.display = 'block';
      const stats = currentElevationData.stats;
      if (miniAriaMin) {
        miniAriaMin.textContent = Number.isFinite(stats.minElevation)
          ? `${stats.minElevation} m`
          : '‚Äî';
      }
      if (miniAriaMax) {
        miniAriaMax.textContent = Number.isFinite(stats.maxElevation)
          ? `${stats.maxElevation} m`
          : '‚Äî';
      }

      requestAnimationFrame(() => {
        drawMiniElevationProfile(miniElevationCanvas, simplified, stats);
      });
    }

    function renderElevationProfile() {
      if (
        !currentElevationData ||
        !currentElevationData.points ||
        !currentElevationData.stats ||
        !elevationCanvas ||
        !elevationProfile
      ) {
        return;
      }
      if (
        elevationProfile.classList.contains('collapsed') ||
        !elevationProfile.classList.contains('visible')
      ) {
        return;
      }
      sizeCanvasToParent();
      drawElevationProfile(elevationCanvas, currentElevationData.points, currentElevationData.stats);
      setupElevationInteraction(currentElevationData.points, currentElevationData.stats);
    }

    function findClosestElevationPoint(canvas, points, stats, event) {
      if (!canvas || !points || !stats) {
        return null;
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const margin = { left: 60, right: 20 };
      const chartWidth = canvas.width - margin.left - margin.right;
      const relativeX = x - margin.left;
      if (relativeX < 0 || relativeX > chartWidth) {
        return null;
      }
      const distance = (relativeX / chartWidth) * stats.totalDistance;
      let closestPoint = points[0];
      let minDiff = Math.abs(points[0].distance - distance);
      for (let i = 1; i < points.length; i++) {
        const diff = Math.abs(points[i].distance - distance);
        if (diff < minDiff) {
          minDiff = diff;
          closestPoint = points[i];
        }
      }
      return { point: closestPoint, canvasX: x };
    }

    function removeElevationInteraction() {
      if (!elevationCanvas) {
        return;
      }
      if (elevationMouseMoveHandler) {
        elevationCanvas.removeEventListener('mousemove', elevationMouseMoveHandler);
      }
      if (elevationMouseLeaveHandler) {
        elevationCanvas.removeEventListener('mouseleave', elevationMouseLeaveHandler);
      }
      elevationMouseMoveHandler = null;
      elevationMouseLeaveHandler = null;
    }

    function setupElevationInteraction(points, stats) {
      if (!elevationCanvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      removeElevationInteraction();

      elevationMouseMoveHandler = (event) => {
        const result = findClosestElevationPoint(elevationCanvas, points, stats, event);
        if (!result) {
          if (elevationTooltip) {
            elevationTooltip.style.display = 'none';
          }
          if (elevationHoverMarker) {
            map.removeLayer(elevationHoverMarker);
            elevationHoverMarker = null;
          }
          return;
        }

        const { point, canvasX } = result;
        if (elevationTooltip) {
          const rect = elevationCanvas.getBoundingClientRect();
          elevationTooltip.style.display = 'block';
          elevationTooltip.style.left = `${canvasX + 15}px`;
          elevationTooltip.style.top = `${event.clientY - rect.top + 15}px`;
          const distanceElement = document.getElementById('tooltip-distance');
          const elevationElement = document.getElementById('tooltip-elevation');
          if (distanceElement) {
            distanceElement.textContent = `${(point.distance / 1000).toFixed(2)} km`;
          }
          if (elevationElement) {
            elevationElement.textContent = `${point.elevation.toFixed(0)} m`;
          }
        }

        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
        }
        elevationHoverMarker = L.circleMarker([point.lat, point.lng], {
          radius: 7,
          fillColor: '#ff5722',
          fillOpacity: 0.9,
          color: '#ffffff',
          weight: 2,
          interactive: false
        }).addTo(map);
      };

      elevationMouseLeaveHandler = () => {
        if (elevationTooltip) {
          elevationTooltip.style.display = 'none';
        }
        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
          elevationHoverMarker = null;
        }
      };

      elevationCanvas.addEventListener('mousemove', elevationMouseMoveHandler);
      elevationCanvas.addEventListener('mouseleave', elevationMouseLeaveHandler);
    }

    function setElevationCollapsed(collapsed) {
      if (!elevationProfile || !elevationCollapseButton) {
        return;
      }
      if (!elevationProfile.classList.contains('visible') && !collapsed) {
        return;
      }

      elevationProfile.classList.toggle('collapsed', collapsed);
      elevationCollapseButton.setAttribute('aria-expanded', String(!collapsed));
      elevationCollapseButton.setAttribute(
        'aria-label',
        collapsed ? 'Agrandir le profil' : 'R√©duire le profil'
      );

      if (!collapsed) {
        requestAnimationFrame(() => {
          renderElevationProfile();
          map.invalidateSize();
        });
      } else {
        removeElevationInteraction();
        map.invalidateSize();
      }
    }

    function createWaypointPopupHtml(name) {
      const safeName = escapeHtml(name);
      return `
        <div class="waypoint-popup">
          <label for="waypoint-name-input">Nom du waypoint</label>
          <input id="waypoint-name-input" class="waypoint-name-input" type="text" value="${safeName}" />
          <div class="waypoint-popup-buttons">
            <button type="button" data-action="save">Enregistrer</button>
            <button type="button" data-action="delete">Supprimer</button>
          </div>
        </div>
      `;
    }

    function attachWaypointPopupHandlers(marker, popup) {
      const container = popup.getElement();
      if (!container) {
        return;
      }

      const input = container.querySelector('.waypoint-name-input');
      if (input) {
        input.value = marker.waypointName;
        input.focus();
        input.select();
      }

      const saveAction = () => {
        const newName = input && input.value.trim() ? input.value.trim() : marker.waypointName;
        marker.waypointName = newName;
        marker.setPopupContent(createWaypointPopupHtml(marker.waypointName));
        marker.openPopup();
        updateWaypointsList();
        try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
      };

      const deleteAction = () => {
        waypointLayerGroup.removeLayer(marker);
        map.closePopup(popup);
        updateWaypointsList();
        try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
      
        // Sauvegarde imm√©diate (sans debounce) pour figer l‚Äô√©tat
        if (typeof saveTraceToLocalStorage === 'function') {
          try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); }
        }
      };

      if (input) {
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveAction();
          }
        });
      }

      const saveButton = container.querySelector('[data-action="save"]');
      if (saveButton) {
        saveButton.addEventListener('click', saveAction);
      }

      const deleteButton = container.querySelector('[data-action="delete"]');
      if (deleteButton) {
        deleteButton.addEventListener('click', deleteAction);
      }
    }

    
function createWaypointMarker(latlng, name = '') {
  const trimmedName = name && name.trim() ? name.trim() : '';
  const finalName = trimmedName || `Waypoint ${waypointCounter}`;
  waypointCounter += 1;

  // Cr√©er l'ic√¥ne personnalis√©e
  const icon = L.divIcon({
    className: 'waypoint-marker',
    html: `
      <div class="waypoint-marker-inner">
        <div class="waypoint-marker-pin">
          <span class="waypoint-marker-icon">üìç</span>
        </div>
      </div>
    `,
    iconSize: [28, 36],
    iconAnchor: [14, 36],
    popupAnchor: [0, -36]
  });

  const marker = L.marker(latlng, { 
    icon: icon,
    draggable: false, 
    bubblingMouseEvents: false,
    riseOnHover: true
  });
  
  marker.waypointName = finalName;
  marker.bindPopup(createWaypointPopupHtml(finalName));
  marker.on('popupopen', (event) => {
    attachWaypointPopupHandlers(marker, event.popup);
  });
  marker.bindTooltip(
    () => marker.waypointName,
    {
      direction: 'top',
      offset: [0, -36]
    }
  );

  waypointLayerGroup.addLayer(marker);
  updateWaypointsList();
  try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
  
  if (typeof marker.on === 'function') {
    marker.on('remove', () => { if (typeof saveTraceDebounced === 'function') saveTraceDebounced(50); });
  }
// Auto-save right after waypoint creation
  if (typeof saveTraceToLocalStorage === 'function') {
    setTimeout(() => saveTraceToLocalStorage(), 50);
  }
  return marker;
}


    function addWaypointsFromFeatures(features) {
      if (!Array.isArray(features)) {
        return;
      }
      features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const properties = feature.properties || {};
        const baseName = properties.name || properties.description || '';

        if (feature.geometry.type === 'Point') {
          const coords = feature.geometry.coordinates;
          if (Array.isArray(coords) && coords.length >= 2) {
            createWaypointMarker(L.latLng(coords[1], coords[0]), baseName);
          }
        } else if (feature.geometry.type === 'MultiPoint') {
          const points = feature.geometry.coordinates || [];
          points.forEach((coords, index) => {
            if (Array.isArray(coords) && coords.length >= 2) {
              const name = baseName ? `${baseName} (${index + 1})` : '';
              createWaypointMarker(L.latLng(coords[1], coords[0]), name);
            }
          });
        }
      });
    }

    function handleAddWaypointFromTrack(latlng) {
      const suggestedName = `Waypoint ${waypointCounter}`;
      const userInput = prompt('Nom du waypoint ?', suggestedName);
      if (userInput === null) {
        return;
      }
      const finalName = userInput.trim() ? userInput.trim() : suggestedName;
      const marker = createWaypointMarker(latlng, finalName);
      marker.openPopup();
    }

    function getWaypointMarkers() {
      const markers = [];
      waypointLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          markers.push(layer);
        } else if (layer && typeof layer.getLayers === 'function') {
          layer.getLayers().forEach((child) => {
            if (child instanceof L.Marker) {
              markers.push(child);
            }
          });
        }
      });
      return markers;
    }

    function updateWaypointsList() {
      if (!waypointsList || !waypointCountLabel || !waypointsSection) {
        return;
      }

      const markers = getWaypointMarkers();
      waypointCountLabel.textContent = markers.length;

      const hasWaypoints = markers.length > 0;
      waypointsSection.style.display = hasWaypoints ? 'block' : 'none';

      if (hasWaypoints) {
        const configBefore = window.collapsibleSections?.waypoints;
        if (window.collapsibleSectionsAPI?.init && (!configBefore || !configBefore.initialized)) {
          window.collapsibleSectionsAPI.init('waypoints');
        }
        const config = window.collapsibleSections?.waypoints;
        if (config && !config.isExpanded) {
          if (typeof setSectionExpanded === 'function') {
            setSectionExpanded('waypoints', true, true);
          }
          if (typeof saveSectionState === 'function') {
            saveSectionState('waypoints', true);
          }
        }
      }

      waypointsList.innerHTML = '';

      markers.forEach((marker) => {
        const item = document.createElement('div');
        item.className = 'waypoint-item';
        item.innerHTML = `
          <span class="waypoint-icon" aria-hidden="true">üìç</span>
          <span class="waypoint-name">${escapeHtml(marker.waypointName)}</span>
          <button class="btn-icon-small" data-action="center" title="Centrer">üéØ</button>
          <button class="btn-icon-small" data-action="delete" title="Supprimer">üóëÔ∏è</button>
        `;

        const centerButton = item.querySelector('[data-action="center"]');
        if (centerButton) {
          centerButton.addEventListener('click', () => {
            const latlng = marker.getLatLng();
            if (latlng) {
              map.setView(latlng, Math.max(map.getZoom(), 16));
              marker.openPopup();
            }
          });
        }

        const deleteButton = item.querySelector('[data-action="delete"]');
        if (deleteButton) {
          deleteButton.addEventListener('click', () => {
            waypointLayerGroup.removeLayer(marker);
            updateWaypointsList();
            try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
            if (typeof saveTraceDebounced === 'function') {
              saveTraceDebounced(50);
            }
            if (typeof saveTraceToLocalStorage === 'function') {
              try {
                saveTraceToLocalStorage();
              } catch (error) {
                console.warn(error);
              }
            }
          });
        }

        waypointsList.appendChild(item);
      });

      if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
        window.roadbookManager.update();
      }
    }

    function updateTraceInfo(info) {
      if (!traceInfoSection || !traceNameLabel || !pointCountLabel || !traceTypeLabel) {
        return;
      }

      if (!info) {
        traceInfoSection.style.display = 'none';
        displayTraceName('‚Äî', 'default');
        pointCountLabel.textContent = '‚Äî';
        traceTypeLabel.textContent = '‚Äî';
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '‚Äî';
        }
        if (gpxTraceFilename) {
          gpxTraceFilename.textContent = 'Aucune trace charg√©e';
        }
        return;
      }

      traceInfoSection.style.display = 'block';
      displayTraceName(currentTraceName || info.name || '‚Äî', traceNameSource || 'default');
      pointCountLabel.textContent = Number.isFinite(info.pointCount) ? info.pointCount : '‚Äî';
      traceTypeLabel.textContent = info.type || '‚Äî';
    if (traceFileNameLabel) {
      traceFileNameLabel.textContent = currentGpxFileName || '‚Äî';
    }
    if (gpxTraceFilename) {
      gpxTraceFilename.textContent = currentGpxFileName || info.name || 'Trace GPX';
    }
  }

  const roadbookManager = {
    section: null,
    listContainer: null,
    emptyState: null,
    stepCount: null,
    exportButton: null,
    exportClickHandler: null,
    steps: [],
    waypointListener: null,

    init() {
      this.section = document.getElementById('roadbook-section');
      this.listContainer = document.getElementById('roadbook-list');
      this.emptyState = document.getElementById('roadbook-empty');
      this.stepCount = document.getElementById('roadbook-step-count');
      const exportButtonElement = document.getElementById('roadbook-export-text');

      if (this.exportButton && this.exportClickHandler) {
        this.exportButton.removeEventListener('click', this.exportClickHandler);
      }

      this.exportButton = exportButtonElement || null;

      if (this.exportButton) {
        this.exportClickHandler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          exportRoadbookToText();
        };
        this.exportButton.addEventListener('click', this.exportClickHandler);
      } else {
        this.exportClickHandler = null;
      }

      if (!this.section || !this.listContainer) {
        return;
      }

      if (window.collapsibleSectionsAPI?.init) {
        window.collapsibleSectionsAPI.init('roadbook');
        if (typeof window.collapsibleSectionsAPI.collapse === 'function') {
          window.collapsibleSectionsAPI.collapse('roadbook');
        }
      }

      this.attachListeners();
      this.update();
    },

    attachListeners() {
      if (
        typeof waypointLayerGroup !== 'undefined' &&
        waypointLayerGroup &&
        typeof waypointLayerGroup.on === 'function'
      ) {
        if (this.waypointListener) {
          waypointLayerGroup.off('layeradd', this.waypointListener);
          waypointLayerGroup.off('layerremove', this.waypointListener);
        }
        this.waypointListener = () => this.update();
        waypointLayerGroup.on('layeradd', this.waypointListener);
        waypointLayerGroup.on('layerremove', this.waypointListener);
      }
    },

    updateExportButtonState() {
      if (!this.exportButton) {
        return;
      }
      const hasSteps = Array.isArray(this.steps) && this.steps.length > 0;
      this.exportButton.disabled = !hasSteps;

      if (!hasSteps) {
        if (this.exportButton.__copyResetTimeout) {
          clearTimeout(this.exportButton.__copyResetTimeout);
          this.exportButton.__copyResetTimeout = null;
        }
        this.exportButton.textContent = 'üìã';
        this.exportButton.classList.remove('copied');
      }
    },

    update() {
      this.steps = this.computeSteps();
      this.render();
    },

    computeSteps() {
      if (
        !currentElevationData ||
        !Array.isArray(currentElevationData.points) ||
        !currentElevationData.stats
      ) {
        return [];
      }

      const elevationPoints = currentElevationData.points;
      const totalDistance = Number.isFinite(currentElevationData.stats.totalDistance)
        ? currentElevationData.stats.totalDistance
        : 0;

      if (!Array.isArray(elevationPoints) || elevationPoints.length === 0) {
        return [];
      }

      const steps = [];
      const startPoint = elevationPoints[0];
      if (startPoint) {
        steps.push({
          type: 'start',
          name: 'D√©part',
          lat: startPoint.lat,
          lng: startPoint.lng,
          distance: 0,
          segmentDistance: 0,
          remainingDistance: Math.max(0, totalDistance),
          elevation: Number.isFinite(startPoint.elevation) ? startPoint.elevation : null,
          pointIndex: Number.isFinite(startPoint.index) ? startPoint.index : null
        });
      }

      const markers =
        typeof getWaypointMarkers === 'function' ? getWaypointMarkers() : [];

      const waypointSteps = markers
        .map((marker) => {
          if (!marker || typeof marker.getLatLng !== 'function') {
            return null;
          }
          const latlng = marker.getLatLng();
          const closestPoint = this.findClosestElevationPoint(latlng, elevationPoints);
          const distance = closestPoint ? closestPoint.distance : 0;
          return {
            type: 'waypoint',
            name: marker.waypointName || 'Waypoint',
            lat: latlng.lat,
            lng: latlng.lng,
            distance,
            elevation: closestPoint && Number.isFinite(closestPoint.elevation)
              ? closestPoint.elevation
              : null,
            pointIndex: closestPoint && Number.isFinite(closestPoint.index) ? closestPoint.index : null,
            marker
          };
        })
        .filter(Boolean)
        .sort((a, b) => a.distance - b.distance);

      waypointSteps.forEach((waypoint) => {
        const previousStepDistance =
          steps.length > 0 ? steps[steps.length - 1].distance : 0;
        waypoint.segmentDistance = Math.max(0, waypoint.distance - previousStepDistance);
        waypoint.remainingDistance = Math.max(0, totalDistance - waypoint.distance);
        steps.push(waypoint);
      });

      const endPoint = elevationPoints[elevationPoints.length - 1];
      if (endPoint) {
        const previousDistance = steps.length > 0 ? steps[steps.length - 1].distance : 0;
        steps.push({
          type: 'end',
          name: 'Arriv√©e',
          lat: endPoint.lat,
          lng: endPoint.lng,
          distance: Math.max(0, totalDistance),
          segmentDistance: Math.max(0, totalDistance - previousDistance),
          remainingDistance: 0,
          elevation: Number.isFinite(endPoint.elevation) ? endPoint.elevation : null,
          pointIndex: Number.isFinite(endPoint.index) ? endPoint.index : null
        });
      }

      // Calculate remaining elevation gain (D+ restant) for each step
      try {
        const findRemainingGainFromIndex = (startIdx) => {
          if (!Number.isFinite(startIdx) || startIdx < 0 || startIdx >= elevationPoints.length) return 0;
          let gain = 0;
          for (let i = startIdx + 1; i < elevationPoints.length; i++) {
            const diff = elevationPoints[i].elevation - elevationPoints[i - 1].elevation;
            if (diff > 0) gain += diff;
          }
          return Math.round(gain);
        };

        steps.forEach((s) => {
          if (Number.isFinite(s.pointIndex)) {
            s.remainingElevationGain = findRemainingGainFromIndex(s.pointIndex);
          } else {
            s.remainingElevationGain = null;
          }
        });
      } catch (e) {
        // if something goes wrong, don't block the roadbook
        steps.forEach((s) => { s.remainingElevationGain = null; });
      }

      return steps;
    },

    findClosestElevationPoint(latlng, points) {
      if (!latlng || !Array.isArray(points) || points.length === 0) {
        return null;
      }

      let closest = points[0];
      let minDistance = Infinity;

      points.forEach((point) => {
        const dist = haversineDistance(
          { lat: point.lat, lng: point.lng },
          { lat: latlng.lat, lng: latlng.lng }
        );
        if (dist < minDistance) {
          minDistance = dist;
          closest = point;
        }
      });

      return closest || null;
    },

    render() {
      if (!this.section || !this.listContainer || !this.emptyState) {
        return;
      }

      const hasSteps = this.steps.length > 0;
      this.updateExportButtonState();
      this.section.style.display = hasSteps ? 'block' : 'none';

      if (!hasSteps) {
        this.emptyState.style.display = 'block';
        this.listContainer.style.display = 'none';
        if (this.stepCount) {
          this.stepCount.textContent = '0';
        }
        return;
      }

      const waypointCount = this.steps.filter((step) => step.type === 'waypoint').length;
      if (this.stepCount) {
        this.stepCount.textContent = String(waypointCount);
      }

      if (waypointCount === 0) {
        this.emptyState.style.display = 'block';
      } else {
        this.emptyState.style.display = 'none';
      }

      this.listContainer.style.display = 'flex';
      this.listContainer.innerHTML = this.steps
        .map((step, index) => this.renderStep(step, index))
        .join('');

      this.attachStepEvents();
    },

    renderStep(step, index) {
      const icon =
        step.type === 'start' ? 'üü¢' : step.type === 'end' ? 'üèÅ' : 'üìç';

      const formatKm = (value) => {
        if (!Number.isFinite(value)) {
          return '0.00';
        }
        return (value / 1000).toFixed(2);
      };

      const distanceKm = formatKm(step.distance);
      const segmentKm = formatKm(step.segmentDistance);
      const remainingKm = formatKm(step.remainingDistance);

      const showSegment = step.type !== 'start';
      const showRemaining = step.type !== 'end' && this.steps.length > 1;
      const showElevation =
        step.elevation !== null && Number.isFinite(step.elevation);
      const showRemainingElevation =
        step.remainingElevationGain !== null && Number.isFinite(step.remainingElevationGain);

      return `
        <div class="roadbook-step" data-type="${step.type}" data-index="${index}">
          <div class="roadbook-step-marker">
            <span class="roadbook-step-icon">${icon}</span>
            <span class="roadbook-step-number">#${index + 1}</span>
          </div>
          <div class="roadbook-step-content">
            <div class="roadbook-step-header">
              <h4 class="roadbook-step-name">${escapeHtml(step.name)}</h4>
              <button class="roadbook-step-center-btn" title="Centrer sur la carte">üéØ</button>
            </div>
            <div class="roadbook-step-distances">
              <div class="roadbook-distance-item roadbook-distance-cumul">
                <span class="roadbook-distance-label">Depuis le d√©part :</span>
                <span class="roadbook-distance-value">${distanceKm} km</span>
              </div>
              ${showSegment ? `
                <div class="roadbook-distance-item roadbook-distance-segment">
                  <span class="roadbook-distance-label">Depuis la derni√®re √©tape :</span>
                  <span class="roadbook-distance-value">${segmentKm} km</span>
                </div>
              ` : ''}
              ${showRemaining ? `
                <div class="roadbook-distance-item roadbook-distance-remaining">
                  <span class="roadbook-distance-label">Jusqu'√† l'arriv√©e :</span>
                  <span class="roadbook-distance-value">${remainingKm} km</span>
                </div>
              ` : ''}
            </div>
            ${showElevation || showRemainingElevation ? `
              <div class="roadbook-step-elevation">
                ${showElevation ? `
                  <span class="roadbook-elevation-label">Altitude :</span>
                  <span class="roadbook-elevation-value">${Math.round(step.elevation)} m</span>
                ` : ''}
                ${showRemainingElevation ? `
                  <span class="roadbook-elevation-label">D+ restant :</span>
                  <span class="roadbook-elevation-value">${step.remainingElevationGain} m</span>
                ` : ''}
              </div>
            ` : ''}
          </div>
        </div>
      `;
    },

    attachStepEvents() {
      const buttons = this.listContainer.querySelectorAll('.roadbook-step-center-btn');
      buttons.forEach((button) => {
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          const stepElement = button.closest('.roadbook-step');
          if (!stepElement) {
            return;
          }
          const index = parseInt(stepElement.getAttribute('data-index'), 10);
          const step = Number.isInteger(index) ? this.steps[index] : null;
          if (!step) {
            return;
          }
          if (typeof map !== 'undefined' && map && typeof map.setView === 'function') {
            map.setView([step.lat, step.lng], Math.max(map.getZoom(), 15));
          }
          if (step.marker && typeof step.marker.openPopup === 'function') {
            step.marker.openPopup();
          }
        });
      });
    }
  };

  window.roadbookManager = roadbookManager;

  document.addEventListener('DOMContentLoaded', () => {
    if (window.roadbookManager && typeof window.roadbookManager.init === 'function') {
      window.roadbookManager.init();
    }
  });

  function exportRoadbookToText() {
    const manager = window.roadbookManager;
    if (!manager || !Array.isArray(manager.steps) || manager.steps.length === 0) {
      showMessage("Le roadbook est vide. Ajoutez des waypoints pour l'utiliser.", true);
      return;
    }

    const traceNameFromFile =
      window.currentGpxFileName && typeof window.currentGpxFileName === 'string'
        ? window.currentGpxFileName.replace(/\.gpx$/i, '')
        : '';
    const traceName =
      window.currentTraceName ||
      traceNameFromFile ||
      'Trace sans nom';

    const lines = [];
    lines.push(`üó∫Ô∏è ROADBOOK - ${traceName}`);
    lines.push('‚îÅ'.repeat(40));
    lines.push('');

    let waypointIndex = 0;

    manager.steps.forEach((step, index) => {
      if (!step) {
        return;
      }

      const icon = step.type === 'start' ? 'üü¢' : step.type === 'end' ? 'üèÅ' : 'üìç';
      const rawName = (step.name || '').trim();
      const upperName = rawName ? rawName.toUpperCase() : '';
      let headerLabel = '';

      if (step.type === 'start') {
        headerLabel = upperName && upperName !== 'D√âPART'
          ? `D√âPART - ${upperName}`
          : 'D√âPART';
      } else if (step.type === 'end') {
        headerLabel = upperName && upperName !== 'ARRIV√âE'
          ? `ARRIV√âE - ${upperName}`
          : 'ARRIV√âE';
      } else {
        waypointIndex += 1;
        const waypointName = upperName || `WAYPOINT ${waypointIndex}`;
        headerLabel = `WAYPOINT ${waypointIndex} - ${waypointName}`;
      }

      lines.push(`${icon} ${headerLabel}`);

      if (step.type === 'end') {
        lines.push(`üìç Distance totale : ${formatKmExport(step.distance)}`);
        if (Number.isFinite(step.segmentDistance) && step.segmentDistance > 0) {
          lines.push(`‚îî‚îÄ Depuis l'√©tape pr√©c√©dente : ${formatKmExport(step.segmentDistance)}`);
        }
      } else {
        lines.push(`üìç Depuis le d√©part : ${formatKmExport(step.distance)}`);

        if (step.type !== 'start' && Number.isFinite(step.segmentDistance) && step.segmentDistance >= 0) {
          lines.push(`‚îî‚îÄ Depuis l'√©tape pr√©c√©dente : ${formatKmExport(step.segmentDistance)}`);
        }

        if (step.type === 'waypoint' && Number.isFinite(step.remainingDistance) && step.remainingDistance >= 0) {
          lines.push(`‚îî‚îÄ Jusqu'√† l'arriv√©e : ${formatKmExport(step.remainingDistance)}`);
        }
      }

      if (Number.isFinite(step.elevation)) {
        lines.push(`‚õ∞Ô∏è Altitude : ${Math.round(step.elevation)} m`);
      }

      if (step.type !== 'end' && Number.isFinite(step.remainingElevationGain)) {
        lines.push(`üìà D+ restant : ${Math.round(step.remainingElevationGain)} m`);
      }

      lines.push('');
    });

    if (lines[lines.length - 1] === '') {
      lines.pop();
    }

    lines.push('‚îÅ'.repeat(40));
    const now = new Date();
    const dateStr = now.toLocaleDateString('fr-FR');
    const timeStr = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
    lines.push(`G√©n√©r√© le ${dateStr} √† ${timeStr}`);

    const text = lines.join('\n');
    copyRoadbookTextToClipboard(text);
  }

  function formatKmExport(meters) {
    if (!Number.isFinite(meters)) {
      return '0.00 km';
    }
    return (meters / 1000).toFixed(2) + ' km';
  }

  function handleRoadbookCopySuccess(button) {
    if (!button) {
      return;
    }
    button.textContent = '‚úì';
    button.classList.add('copied');

    if (button.__copyResetTimeout) {
      clearTimeout(button.__copyResetTimeout);
    }

    button.__copyResetTimeout = setTimeout(() => {
      button.textContent = 'üìã';
      button.classList.remove('copied');
      button.__copyResetTimeout = null;
    }, 2000);
  }

  function copyRoadbookTextToClipboard(text) {
    const button = document.getElementById('roadbook-export-text');

    if (!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
      fallbackCopyRoadbookText(text, button, null);
      return;
    }

    navigator.clipboard.writeText(text)
      .then(() => {
        handleRoadbookCopySuccess(button);
        showMessage('Roadbook copi√© dans le presse-papiers ‚úì', false);
      })
      .catch((err) => {
        console.error('Erreur de copie du roadbook:', err);
        fallbackCopyRoadbookText(text, button, err);
      });
  }

  function fallbackCopyRoadbookText(text, button, originalError) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.setAttribute('readonly', '');
    textarea.style.position = 'fixed';
    textarea.style.top = '-9999px';
    textarea.style.opacity = '0';

    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();

    let successful = false;

    try {
      successful = document.execCommand('copy');
    } catch (error) {
      console.error('Fallback copy failed:', error);
      successful = false;
    } finally {
      document.body.removeChild(textarea);
    }

    if (successful) {
      handleRoadbookCopySuccess(button);
      showMessage('Roadbook copi√© ‚úì', false);
      return;
    }

    if (button) {
      button.textContent = 'üìã';
      button.classList.remove('copied');
      if (button.__copyResetTimeout) {
        clearTimeout(button.__copyResetTimeout);
        button.__copyResetTimeout = null;
      }
    }

    if (originalError && originalError.name === 'NotAllowedError') {
      showMessage('Permission de copie refus√©e par le navigateur.', true);
    } else if (!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
      showMessage('Impossible de copier le texte. Essayez manuellement.', true);
    } else {
      showMessage('Erreur lors de la copie dans le presse-papiers.', true);
    }
  }

  function createArrowIconHtml(bearing) {
      const rotation = ((bearing - 90) + 360) % 360;
      return `<span class="direction-arrow" style="display:inline-block; color:#ff5722; font-size:1rem; line-height:1; text-shadow:0 0 2px rgba(0,0,0,0.5); transform-origin:center; transform: rotate(${rotation}deg);">‚û§</span>`;
    }

    function createArrowMarker(point, bearing) {
      return L.marker(point, {
        icon: L.divIcon({
          className: '',
          html: createArrowIconHtml(bearing),
          iconSize: [16, 16],
          iconAnchor: [8, 8]
        }),
        interactive: false,
        keyboard: false
      });
    }

    function createArrowMarkers(layer) {
      const arrowMarkers = [];
      const latLngs = normalizeLatLngSegments(layer.getLatLngs());
      const arrowSpacingMeters = 2500;

      latLngs.forEach((segment) => {
        if (!Array.isArray(segment) || segment.length < 2) {
          return;
        }

        let previousPoint = L.latLng(segment[0]);
        let distanceFromLastArrow = 0;
        let totalSegmentDistance = 0;
        const segmentMarkers = [];

        for (let i = 1; i < segment.length; i++) {
          const currentPoint = L.latLng(segment[i]);
          let segmentDistance = map.distance(previousPoint, currentPoint);
          let segmentStart = previousPoint;

          if (segmentDistance === 0) {
            previousPoint = currentPoint;
            continue;
          }

          totalSegmentDistance += segmentDistance;

          while (distanceFromLastArrow + segmentDistance >= arrowSpacingMeters) {
            const distanceNeeded = arrowSpacingMeters - distanceFromLastArrow;
            const ratio = distanceNeeded / segmentDistance;
            const interpolatedLat =
              segmentStart.lat + (currentPoint.lat - segmentStart.lat) * ratio;
            const interpolatedLng =
              segmentStart.lng + (currentPoint.lng - segmentStart.lng) * ratio;
            const arrowPoint = L.latLng(interpolatedLat, interpolatedLng);
            const bearing = computeBearingDegrees(segmentStart, currentPoint);

            const marker = createArrowMarker(arrowPoint, bearing);

            arrowMarkers.push(marker);
            segmentMarkers.push(marker);

            segmentStart = arrowPoint;
            segmentDistance = map.distance(segmentStart, currentPoint);
            if (segmentDistance === 0) {
              break;
            }
            distanceFromLastArrow = 0;
          }

          distanceFromLastArrow += segmentDistance;
          previousPoint = currentPoint;
        }

        if (segmentMarkers.length === 0 && totalSegmentDistance > 0) {
          const targetDistance = totalSegmentDistance / 2;
          let accumulated = 0;
          for (let i = 1; i < segment.length; i++) {
            const start = L.latLng(segment[i - 1]);
            const end = L.latLng(segment[i]);
            const distance = map.distance(start, end);
            if (distance === 0) {
              continue;
            }
            if (accumulated + distance >= targetDistance) {
              const ratio = (targetDistance - accumulated) / distance;
              const lat = start.lat + (end.lat - start.lat) * ratio;
              const lng = start.lng + (end.lng - start.lng) * ratio;
              const point = L.latLng(lat, lng);
              const bearing = computeBearingDegrees(start, end);
              const marker = createArrowMarker(point, bearing);
              arrowMarkers.push(marker);
              segmentMarkers.push(marker);
              break;
            }
            accumulated += distance;
          }
        }
      });

      return arrowMarkers;
    }

    function computeTraceInfo(lineFeatures, geojson) {
      if (!Array.isArray(lineFeatures) || lineFeatures.length === 0) {
        return null;
      }

      const first = lineFeatures[0];
      const properties = first.properties || {};
      const name = properties.name || properties.description || (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : 'Trace');
      let pointCount = 0;
      let type = properties.kind || first.geometry?.type || '‚Äî';

      lineFeatures.forEach((feature) => {
        if (!feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        if (geometry.type === 'LineString') {
          pointCount += Array.isArray(geometry.coordinates) ? geometry.coordinates.length : 0;
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            pointCount += Array.isArray(segment) ? segment.length : 0;
          });
        }
        if (!type && geometry.type) {
          type = geometry.type;
        }
        if (!properties.kind && feature.properties && feature.properties.kind) {
          type = feature.properties.kind;
        }
      });

      if (!type && geojson && Array.isArray(geojson.features)) {
        const kinds = geojson.features
          .map((feature) => feature?.properties?.kind)
          .filter(Boolean);
        if (kinds.length > 0) {
          type = kinds[0];
        }
      }

      return {
        name,
        pointCount,
        type: type || '‚Äî'
      };
    }

    function displayGeoJSON(geojsonData) {
      clearPreviousLayers();

      currentGeojson = geojsonData;

      const lineFeatures = [];
      const pointFeatures = [];

      if (geojsonData && Array.isArray(geojsonData.features)) {
        geojsonData.features.forEach((feature) => {
          const geometryType = feature && feature.geometry && feature.geometry.type;
          if (geometryType === 'LineString' || geometryType === 'MultiLineString') {
            lineFeatures.push(feature);
          } else if (geometryType === 'Point' || geometryType === 'MultiPoint') {
            pointFeatures.push(feature);
          }
        });
      }

      const linesFeatureCollection = {
        type: 'FeatureCollection',
        features: lineFeatures
      };

      gpxLayerGroup = L.geoJSON(linesFeatureCollection, {
        style: function () {
          return {
            color: '#ff5722',
            weight: 3,
            opacity: 0.9
          };
        }
      }).addTo(map);

      const arrowLayers = [];
      gpxLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
          layer.on('click', (event) => {
            if (event.originalEvent) {
              event.originalEvent.preventDefault();
              event.originalEvent.stopPropagation();
            }
            handleAddWaypointFromTrack(event.latlng);
          });

          if (
            typeof L.polylineDecorator === 'function' &&
            L.Symbol &&
            typeof L.Symbol.arrowHead === 'function'
          ) {
            const decorator = L.polylineDecorator(layer, {
              patterns: [
                {
                  offset: '5%',
                  repeat: '50%',
                  symbol: L.Symbol.arrowHead({
                    pixelSize: 10,
                    headAngle: 60,
                    polygon: false,
                    pathOptions: {
                      stroke: true,
                      color: '#ff5722',
                      weight: 2,
                      opacity: 0.9
                    }
                  })
                }
              ]
            });
            arrowLayers.push(decorator);
          } else {
            const markers = createArrowMarkers(layer);
            if (markers.length > 0) {
              arrowLayers.push(L.layerGroup(markers));
            }
          }
        }
      });

      if (arrowLayers.length > 0) {
        arrowLayerGroup = L.layerGroup(arrowLayers).addTo(map);
      }

      if (pointFeatures.length > 0) {
        addWaypointsFromFeatures(pointFeatures);
      } else {
        updateWaypointsList();
      }

      let bounds = null;
      if (gpxLayerGroup.getLayers().length > 0) {
        bounds = gpxLayerGroup.getBounds();
      }
      waypointLayerGroup.eachLayer((layer) => {
        if (typeof layer.getLatLng !== 'function') {
          return;
        }
        const latlng = layer.getLatLng();
        if (!latlng) {
          return;
        }
        if (!bounds) {
          bounds = L.latLngBounds(latlng, latlng);
        } else {
          bounds.extend(latlng);
        }
      });

      if (bounds && typeof bounds.isValid === 'function' && bounds.isValid()) {
        map.fitBounds(bounds.pad(0.1));
      }

      updateTraceInfo(computeTraceInfo(lineFeatures, geojsonData));
      currentGeojson = geojsonData;
    
    try { addTraceEndpointMarkers(geojsonData); } catch(e){ console.warn('addTraceEndpointMarkers: ', e); }
}

    /**
     * Traite le fichier GPX s√©lectionn√©.
     * @param {File} file
     */
    async function handleFile(file) {
      if (!file) {
        return;
      }

      setExportAvailability(false);
      currentGpxDocument = null;
      currentGpxFileName = '';
      currentTraceName = '';
      traceNameSource = '';
      displayTraceName('‚Äî', 'default');
      updateTraceInfo(null);

      if (!file.name.toLowerCase().endsWith('.gpx')) {
        showMessage('Veuillez s√©lectionner un fichier .gpx.', true);
        return;
      }

      const reader = new FileReader();

      reader.onload = async function (event) {
        try {
          showMessage('Chargement de la trace GPX‚Ä¶');
          const parser = new DOMParser();
          const xml = parser.parseFromString(event.target.result, 'application/xml');
          const parseError = xml.querySelector('parsererror');
          if (parseError) {
            throw new Error('Fichier GPX invalide.');
          }

          currentGpxDocument = window.currentGpxDocument = xml;
          currentGpxFileName = window.currentGpxFileName = file.name;
          if (traceFileNameLabel) {
            traceFileNameLabel.textContent = file.name;
          }
          if (gpxTraceFilename) {
            gpxTraceFilename.textContent = file.name;
          }

          const extractedTrace = extractTraceName(xml, file.name);
          currentTraceName = window.currentTraceName = extractedTrace.name;
          traceNameSource = window.traceNameSource = extractedTrace.source;
          displayTraceName(currentTraceName, traceNameSource);

          const geojson = convertGpxToGeoJSON(xml);

          if (!geojson || !geojson.features || geojson.features.length === 0) {
            throw new Error('La trace GPX est vide ou invalide.');
          }

          setExportAvailability(true);
          displayGeoJSON(geojson);
    if (typeof attachWaypointPersistence === 'function') attachWaypointPersistence();
          // Guarded elevation render after import
          if (typeof ensureElevationRendered === 'function') ensureElevationRendered(12);

          currentElevationData = currentElevationData = window.currentElevationData = extractElevationData(geojson, xml);
      let noElevationData = false;
          if (currentElevationData) {
            updateElevationStats(currentElevationData.stats);
            setElevationCollapsed(false);
            requestAnimationFrame(() => renderElevationProfile());
          } else {
            updateElevationStats(null);
            const distanceOnly = calculateDistanceOnly(geojson);
            if (distanceOnly && traceDistanceLabel) {
              const distanceKmOnly = (distanceOnly.distance / 1000).toFixed(2);
              traceDistanceLabel.textContent = `${distanceKmOnly} km`;
              if (profileDistanceValue) {
                profileDistanceValue.textContent = `${distanceKmOnly} km`;
              }
              if (ariaDistance) {
                ariaDistance.textContent = `${distanceKmOnly} km`;
              }
              if (gpxTraceDistance) {
                gpxTraceDistance.textContent = `${distanceKmOnly} km`;
              }
            } else if (gpxTraceDistance) {
              gpxTraceDistance.textContent = '‚Äî';
            }
            if (traceElevationGainLabel) {
              traceElevationGainLabel.textContent = 'N/A';
            }
            if (gpxTraceElevation) {
              gpxTraceElevation.textContent = 'D+ N/A';
            }
            if (traceElevationLossLabel) {
              traceElevationLossLabel.textContent = 'N/A';
            }
            if (traceAltitudeRangeLabel) {
              traceAltitudeRangeLabel.textContent = 'N/A';
            }
            if (profileElevationGainValue) {
              profileElevationGainValue.textContent = 'N/A';
            }
            if (profileElevationLossValue) {
              profileElevationLossValue.textContent = 'N/A';
            }
            if (ariaDPlus) {
              ariaDPlus.textContent = 'N/A';
            }
            if (ariaMin) {
              ariaMin.textContent = 'N/A';
            }
            if (ariaMax) {
              ariaMax.textContent = 'N/A';
            }
            if (elevationProfile) {
              elevationProfile.setAttribute('aria-hidden', 'true');
            }
            noElevationData = true;
          }

          if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
            window.roadbookManager.update();
          }

          let successMessage = '';
          switch (traceNameSource) {
            case 'gpx-track':
            case 'gpx-route':
            case 'gpx-metadata':
              successMessage = `Trace "<strong>${escapeHtml(currentTraceName)}</strong>" charg√©e avec succ√®s.`;
              break;
            case 'filename':
              successMessage = `Fichier "<strong>${escapeHtml(currentTraceName)}</strong>" charg√© (aucun nom dans le GPX).`;
              break;
            case 'default':
            default:
              successMessage = 'Trace charg√©e (aucun nom disponible).';
              break;
          }
          if (noElevationData) {
            successMessage += '<br><small>Cette trace ne contient pas de donn√©es d\'√©l√©vation.</small>';
          }
          showMessage(successMessage, false, true);
          
          // Sauvegarder la trace apr√®s chargement r√©ussi
          setTimeout(() => {
            if (typeof saveTraceToLocalStorage === 'function') {
              saveTraceToLocalStorage();
              console.log('Trace sauvegard√©e apr√®s import');
            }
          }, 200);

          
          // Sauvegarder automatiquement la trace charg√©e
setTimeout(() => { if (typeof saveTraceToLocalStorage === 'function') saveTraceToLocalStorage(); }, 500);
        } catch (error) {
          console.error(error);
          showMessage(error.message || 'Impossible de lire ce fichier GPX.', true);
          clearPreviousLayers();
          currentGpxDocument = null;
          currentGpxFileName = '';
          currentTraceName = '';
          traceNameSource = '';
          displayTraceName('‚Äî', 'default');
          setExportAvailability(false);
        }
      };

      reader.onerror = function () {
        showMessage('Erreur de lecture du fichier.', true);
        currentGpxDocument = null;
        currentGpxFileName = '';
        currentTraceName = '';
        traceNameSource = '';
        displayTraceName('‚Äî', 'default');
        setExportAvailability(false);
      };

      reader.readAsText(file);
    }

    function exportUpdatedGpx(options = {}) {
      if (!currentGpxDocument) {
        showMessage('Aucune trace GPX √† exporter.', true);
        return;
      }

      const includeWaypoints = options.includeWaypoints !== false;
      const requestedName = options.downloadName && options.downloadName.trim();
      const fallbackBase =
        currentTraceName ||
        (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : '') ||
        'trace';

      let finalBase = sanitizeFileName(
        requestedName ? requestedName.replace(/\.gpx$/i, '') : fallbackBase
      );
      const nameWasProvided = Boolean(requestedName);

      if (!finalBase) {
        finalBase = 'trace';
      }

      if (!nameWasProvided) {
        if (includeWaypoints && !/_with_waypoints$/i.test(finalBase)) {
          finalBase = `${finalBase}_with_waypoints`;
        } else if (!includeWaypoints && /_with_waypoints$/i.test(finalBase)) {
          finalBase = finalBase.replace(/_with_waypoints$/i, '');
        }
      }

      const downloadName = `${finalBase}.gpx`;

      const xmlDoc = currentGpxDocument.cloneNode(true);
      const gpxRoot = xmlDoc && xmlDoc.documentElement ? xmlDoc.documentElement : null;

      if (!gpxRoot) {
        showMessage('Impossible de pr√©parer le fichier GPX.', true);
        return;
      }

      const existingWaypoints = xmlDoc.querySelectorAll('wpt');
      existingWaypoints.forEach((node) => {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });

      const markers = includeWaypoints ? getWaypointMarkers() : [];
      markers.forEach((marker) => {
        if (typeof marker.getLatLng !== 'function') {
          return;
        }
        const latlng = marker.getLatLng();
        if (!latlng) {
          return;
        }

        const wptNode = xmlDoc.createElement('wpt');
        wptNode.setAttribute('lat', latlng.lat.toFixed(6));
        wptNode.setAttribute('lon', latlng.lng.toFixed(6));

        if (marker.waypointName) {
          const nameNode = xmlDoc.createElement('name');
          nameNode.textContent = marker.waypointName;
          wptNode.appendChild(nameNode);
        }

        gpxRoot.appendChild(wptNode);
      });

      const serializer = new XMLSerializer();
      let gpxString = serializer.serializeToString(xmlDoc);
      if (!gpxString.startsWith('<?xml')) {
        gpxString = `<?xml version="1.0" encoding="UTF-8"?>\n${gpxString}`;
      }

      const blob = new Blob([gpxString], { type: 'application/gpx+xml' });
      const url = URL.createObjectURL(blob);

      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = downloadName;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);

      setTimeout(() => {
        URL.revokeObjectURL(url);
      }, 0);

      showMessage(`Fichier "${downloadName}" export√©.`);
    }

    function getWaypointCount() {
      try {
        const markers = getWaypointMarkers();
        return Array.isArray(markers) ? markers.length : 0;
      } catch (error) {
        console.warn('getWaypointCount', error);
        return 0;
      }
    }

    function getSuggestedExportBase(includeWaypoints = true) {
      const baseCandidate =
        currentTraceName ||
        (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : '') ||
        'trace';
      let sanitized = sanitizeFileName(baseCandidate);
      if (!sanitized) {
        sanitized = 'trace';
      }
      if (includeWaypoints && !/_with_waypoints$/i.test(sanitized)) {
        sanitized = `${sanitized}_with_waypoints`;
      } else if (!includeWaypoints && /_with_waypoints$/i.test(sanitized)) {
        sanitized = sanitized.replace(/_with_waypoints$/i, '');
      }
      return sanitized;
    }

    function updateExportPreview() {
      if (!exportPreviewName) {
        return null;
      }
      const includeWaypoints = exportIncludeWaypoints ? exportIncludeWaypoints.checked : true;
      const rawInput = exportFileNameInput ? exportFileNameInput.value.trim() : '';
      const suggestedBase = exportFileNameInput ? exportFileNameInput.dataset.suggestedBase || '' : '';
      const sanitizedSuggested = suggestedBase
        ? sanitizeFileName(suggestedBase.replace(/\.gpx$/i, ''))
        : '';
      let sanitizedBase = rawInput
        ? sanitizeFileName(rawInput.replace(/\.gpx$/i, ''))
        : '';

      const isUsingSuggested =
        !rawInput ||
        (!!sanitizedSuggested && sanitizedBase === sanitizedSuggested);

      if (!sanitizedBase) {
        sanitizedBase = sanitizedSuggested || getSuggestedExportBase(includeWaypoints);
      }

      if (isUsingSuggested) {
        if (includeWaypoints && !/_with_waypoints$/i.test(sanitizedBase)) {
          sanitizedBase = `${sanitizedBase}_with_waypoints`;
        } else if (!includeWaypoints && /_with_waypoints$/i.test(sanitizedBase)) {
          sanitizedBase = sanitizedBase.replace(/_with_waypoints$/i, '');
        }
        if (exportFileNameInput) {
          exportFileNameInput.value = sanitizedBase;
        }
      }

      if (!sanitizedBase) {
        sanitizedBase = 'trace';
      }

      const finalName = `${sanitizedBase}.gpx`;
      exportPreviewName.textContent = finalName;
      if (exportFileNameInput) {
        exportFileNameInput.dataset.exportSanitized = sanitizedBase;
      }
      return { includeWaypoints, finalName, sanitizedBase };
    }

    function openExportModal() {
      if (!exportModal || !exportModalBackdrop) {
        return;
      }

      const waypointCount = getWaypointCount();
      const hasWaypoints = waypointCount > 0;

      if (exportWaypointsLabel) {
        exportWaypointsLabel.textContent = `Inclure les waypoints (${waypointCount})`;
      }
      if (exportIncludeWaypoints) {
        exportIncludeWaypoints.disabled = !hasWaypoints;
        exportIncludeWaypoints.checked = hasWaypoints;
      }
      if (exportFileNameInput) {
        const defaultBase = getSuggestedExportBase(exportIncludeWaypoints ? exportIncludeWaypoints.checked : true);
        exportFileNameInput.value = defaultBase;
        exportFileNameInput.dataset.suggestedBase = defaultBase;
        requestAnimationFrame(() => {
          exportFileNameInput.focus();
          exportFileNameInput.select();
        });
      }

      updateExportPreview();
      exportModal.classList.remove('hidden');
      exportModalBackdrop.classList.remove('hidden');
      document.body.classList.add('modal-open');
    }

    function closeExportModal() {
      if (exportModal) {
        exportModal.classList.add('hidden');
      }
      if (exportModalBackdrop) {
        exportModalBackdrop.classList.add('hidden');
      }
      document.body.classList.remove('modal-open');
    }

    function togglePanel(open) {
      if (!toolsPanel) {
        return;
      }
      const shouldOpen = open !== undefined ? open : !toolsPanel.classList.contains('open');
      if (shouldOpen) {
        toolsPanel.classList.add('open');
        menuToggle?.setAttribute('aria-expanded', 'true');
        if (!backdropElement) {
          backdropElement = document.createElement('div');
          backdropElement.className = 'panel-backdrop';
          backdropElement.addEventListener('click', () => {
            togglePanel(false);
          });
          document.body.appendChild(backdropElement);
        }
      } else {
        toolsPanel.classList.remove('open');
        menuToggle?.setAttribute('aria-expanded', 'false');
        if (backdropElement) {
          backdropElement.remove();
          backdropElement = null;
        }
      }
      map.invalidateSize();
    }

    initPOIManager();

    if (gpxImportZone && fileInput) {
      gpxImportZone.addEventListener('click', () => fileInput.click());
      gpxImportZone.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          fileInput.click();
        }
      });
    }

    if (replaceActionButton && fileInput) {
      replaceActionButton.addEventListener('click', () => {
        const waypointCount = getWaypointCount();
        if (waypointCount > 0) {
          const confirmReplace = confirm(
            'Remplacer la trace effacera les waypoints actuels. Continuer ?'
          );
          if (!confirmReplace) {
            return;
          }
        }
        fileInput.click();
      });
    }

    // Helper: on small screens, close the tools panel before opening modal to avoid overlay issues
    function isMobileViewport() {
      try {
        return window.matchMedia && window.matchMedia('(max-width: 767px)').matches;
      } catch (e) {
        return (window.innerWidth || document.documentElement.clientWidth) <= 767;
      }
    }

    if (exportActionButton) {
      exportActionButton.addEventListener('click', () => {
        if (!currentGpxDocument) {
          showMessage('Aucune trace GPX √† exporter.', true);
          return;
        }

        // If the panel is open on mobile, close it first so the modal isn't hidden behind it.
        const panelOpen = toolsPanel && toolsPanel.classList.contains('open');
        if (isMobileViewport() && panelOpen) {
          // Close panel and wait for the CSS transition to finish (~300ms) before opening modal
          togglePanel(false);
          // Use requestAnimationFrame + setTimeout as a small debounce to ensure the DOM updated
          window.setTimeout(() => {
            openExportModal();
          }, 320);
        } else {
          openExportModal();
        }
      });
    }

    if (exportModalClose) {
      exportModalClose.addEventListener('click', closeExportModal);
    }
    if (exportModalCancel) {
      exportModalCancel.addEventListener('click', closeExportModal);
    }
    if (exportModalBackdrop) {
      exportModalBackdrop.addEventListener('click', closeExportModal);
    }
    if (exportIncludeWaypoints) {
      exportIncludeWaypoints.addEventListener('change', () => {
        updateExportPreview();
      });
    }
    if (exportFileNameInput) {
      exportFileNameInput.addEventListener('input', () => {
        updateExportPreview();
      });
    }
    if (exportModalDownload) {
      exportModalDownload.addEventListener('click', () => {
        const previewState = updateExportPreview();
        if (!previewState) {
          return;
        }
        exportUpdatedGpx({
          includeWaypoints: previewState.includeWaypoints,
          downloadName: previewState.finalName
        });
        closeExportModal();
      });
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && exportModal && !exportModal.classList.contains('hidden')) {
        event.preventDefault();
        closeExportModal();
      }
    });

    if (typeof attachWaypointPersistence === 'function') attachWaypointPersistence();
    setTimeout(() => {
      if (typeof loadTraceFromLocalStorage === 'function') {
        loadTraceFromLocalStorage();
      }
    }, 300);

    if (menuToggle) {
      menuToggle.addEventListener('click', () => togglePanel(true));
    }

    if (closePanel) {
      closePanel.addEventListener('click', () => togglePanel(false));
    }

    if (elevationHeader && elevationProfile) {
      elevationHeader.addEventListener('click', (event) => {
        if (event.target === elevationCollapseButton) {
          return;
        }
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    if (elevationCollapseButton && elevationProfile) {
      elevationCollapseButton.addEventListener('click', (event) => {
        event.stopPropagation();
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    // Gestion du changement de fichier via le s√©lecteur
    fileInput.addEventListener('change', (event) => {
      const selectedFile = event.target.files && event.target.files[0];
      handleFile(selectedFile);
      fileInput.value = '';
    });

    if (clearWaypointsButton) {
      clearWaypointsButton.addEventListener('click', () => {
        waypointLayerGroup.clearLayers();
        updateWaypointsList();
        try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
      if (typeof saveTraceDebounced === 'function') saveTraceDebounced(60);
      if (typeof saveTraceToLocalStorage === 'function') { try { saveTraceToLocalStorage(); } catch(e) {} }
  // FINAL SAFETY: persist the current state after any list refresh
  if (window.currentGpxDocument && typeof saveTraceDebounced === 'function') saveTraceDebounced(80);

});
    }

    function handleDragEnter(zone, event) {
      if (!zone) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      zone.classList.add('dragover');
    }

    function handleDragLeave(zone, event) {
      if (!zone) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
    }

    function handleDrop(zone, event) {
      if (!zone) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
      const files = event.dataTransfer && event.dataTransfer.files;
      if (files && files.length > 0) {
        if (zone === gpxLoadedState && getWaypointCount() > 0) {
          const confirmReplace = confirm(
            'Remplacer la trace effacera les waypoints actuels. Continuer ?'
          );
          if (!confirmReplace) {
            return;
          }
        }
        handleFile(files[0]);
      }
    }

    [gpxImportZone, gpxLoadedState].forEach((zone) => {
      if (!zone) {
        return;
      }
      ['dragenter', 'dragover'].forEach((eventName) => {
        zone.addEventListener(eventName, (event) => handleDragEnter(zone, event));
      });
      ['dragleave', 'drop'].forEach((eventName) => {
        zone.addEventListener(eventName, (event) => {
          if (eventName === 'drop') {
            handleDrop(zone, event);
          } else {
            handleDragLeave(zone, event);
          }
        });
      });
    });

    // Gestion du drag & drop sur la carte
    const mapContainer = document.querySelector('#map');
    if (mapContainer) {
      ['dragenter', 'dragover'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
        });
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (eventName === 'drop') {
            const droppedFiles = event.dataTransfer && event.dataTransfer.files;
            if (droppedFiles && droppedFiles.length > 0) {
              handleFile(droppedFiles[0]);
            }
          }
        });
      });
    }

    // Emp√™che le navigateur d'ouvrir le fichier en dehors de la zone pr√©vue
    document.addEventListener('dragover', (event) => {
      event.preventDefault();
    });
    document.addEventListener('drop', (event) => {
      event.preventDefault();
    });

    // S'assure que la carte s'ajuste lors des changements de taille de fen√™tre
    window.addEventListener('resize', () => {
      map.invalidateSize();
      requestAnimationFrame(() => {
        renderElevationProfile();
        updateMiniElevationProfile();
      });
    });

    // Fermer le panneau avec la touche √âchap sur mobile
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        togglePanel(false);
      }
    });
  </script>
<script>
// === G√©olocalisation : manager & fonctions ===
const geolocationManager = {
  enabled: false,
  watchId: null,
  currentPosition: null,
  marker: null,
  accuracyCircle: null,
  lastUpdate: null,
  refreshInterval: 30000,
  refreshTimer: null,
  // DOM
  toggleCheckbox: null,
  statusElement: null,
  infoContainer: null,
  errorContainer: null,
  centerButton: null,
  // Options
  options: { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 },
};

function initGeolocation() {
  geolocationManager.toggleCheckbox = document.getElementById('geolocation-toggle');
  geolocationManager.statusElement = document.getElementById('geolocation-status');
  geolocationManager.infoContainer = document.getElementById('geolocation-info');
  geolocationManager.errorContainer = document.getElementById('geolocation-error');
  geolocationManager.centerButton = document.getElementById('center-on-position');

  if (!navigator.geolocation) {
    showGeolocationError('Votre navigateur ne supporte pas la g√©olocalisation.');
    if (geolocationManager.toggleCheckbox) geolocationManager.toggleCheckbox.disabled = true;
    return;
  }

  const savedPreference = loadGeolocationPreference();
  if (savedPreference && geolocationManager.toggleCheckbox) {
    geolocationManager.toggleCheckbox.checked = true;
    enableGeolocation();
  }

  attachGeolocationHandlers();
}

function enableGeolocation() {
  if (!navigator.geolocation) return;
  geolocationManager.enabled = true;
  if (geolocationManager.infoContainer) geolocationManager.infoContainer.style.display = 'block';
  if (geolocationManager.errorContainer) geolocationManager.errorContainer.style.display = 'none';
  updateGeolocationStatus('Recherche de position...', 'searching');
  getCurrentPosition();
  startGeolocationRefresh();
  saveGeolocationPreference(true);
}

function disableGeolocation() {
  geolocationManager.enabled = false;
  stopGeolocationRefresh();
  removeGeolocationMarker();
  if (geolocationManager.infoContainer) geolocationManager.infoContainer.style.display = 'none';
  if (geolocationManager.errorContainer) geolocationManager.errorContainer.style.display = 'none';
  saveGeolocationPreference(false);
}

function getCurrentPosition() {
  if (!navigator.geolocation || !geolocationManager.enabled) return;
  navigator.geolocation.getCurrentPosition(
    handleGeolocationSuccess,
    handleGeolocationError,
    geolocationManager.options
  );
}

function handleGeolocationSuccess(position) {
  if (!geolocationManager.enabled) return;
  const { latitude, longitude, accuracy } = position.coords;
  geolocationManager.currentPosition = { lat: latitude, lng: longitude, accuracy, timestamp: position.timestamp };
  geolocationManager.lastUpdate = Date.now();
  updateGeolocationMarker(latitude, longitude, accuracy);
  const accuracyText = accuracy < 50 ? 'pr√©cise' : accuracy < 100 ? 'moyenne' : 'approximative';
  updateGeolocationStatus(`Position obtenue (pr√©cision ${accuracyText}: ¬±${Math.round(accuracy)}m)`, 'active');
  if (geolocationManager.centerButton) geolocationManager.centerButton.disabled = false;
  hideGeolocationError();

  // Centrage automatique √† chaque mise √† jour
  centerOnUserPosition();
}

function handleGeolocationError(error) {
  if (!geolocationManager.enabled) return;
  let message = '';
  switch (error.code) {
    case error.PERMISSION_DENIED: message = 'Permission de localisation refus√©e. Veuillez autoriser l\'acc√®s dans les param√®tres de votre navigateur.'; break;
    case error.POSITION_UNAVAILABLE: message = 'Position indisponible. V√©rifiez votre connexion et vos param√®tres de localisation.'; break;
    case error.TIMEOUT: message = 'D√©lai d\'attente d√©pass√©. R√©essayez dans quelques instants.'; break;
    default: message = 'Erreur de g√©olocalisation inconnue.';
  }
  updateGeolocationStatus('Erreur de localisation', 'error');
  showGeolocationError(message);
  if (geolocationManager.centerButton) geolocationManager.centerButton.disabled = true;
}

function updateGeolocationMarker(lat, lng, accuracy) {
  // R√©utilisation si existant
  if (geolocationManager.accuracyCircle) {
    geolocationManager.accuracyCircle.setLatLng([lat,lng]).setRadius(Math.min(accuracy || 0, 1000));
  } else if (accuracy && accuracy < 1000) {
    geolocationManager.accuracyCircle = L.circle([lat, lng], {
      radius: accuracy, className: 'user-location-accuracy', interactive: false
    }).addTo(map);
  }

  const icon = L.divIcon({
    className: 'user-location-marker',
    html: '<div class="user-location-marker-inner"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });

  if (geolocationManager.marker) {
    geolocationManager.marker.setLatLng([lat,lng]).setIcon(icon);
  } else {
    geolocationManager.marker = L.marker([lat, lng], { icon, zIndexOffset: 1000, title: 'Ma position' }).addTo(map);
  }

  const popupContent = '<div style="text-align:center;"><strong>üìç Ma position</strong><br><small>Pr√©cision: ¬±' + Math.round(accuracy) + 'm</small><br><small>' + new Date().toLocaleTimeString('fr-FR') + '</small></div>';
  geolocationManager.marker.bindPopup(popupContent);
}

function removeGeolocationMarker() {
  if (geolocationManager.marker) { try { map.removeLayer(geolocationManager.marker); } catch(e){} geolocationManager.marker = null; }
  if (geolocationManager.accuracyCircle) { try { map.removeLayer(geolocationManager.accuracyCircle); } catch(e){} geolocationManager.accuracyCircle = null; }
}

function startGeolocationRefresh() {
  stopGeolocationRefresh();
  geolocationManager.refreshTimer = setInterval(() => {
    if (geolocationManager.enabled) getCurrentPosition();
  }, geolocationManager.refreshInterval);
}

function stopGeolocationRefresh() {
  if (geolocationManager.refreshTimer) { clearInterval(geolocationManager.refreshTimer); geolocationManager.refreshTimer = null; }
}

function centerOnUserPosition() {
  if (!geolocationManager.currentPosition) return;
  const { lat, lng, accuracy } = geolocationManager.currentPosition;
  let zoom = 16;
  if (accuracy > 500) zoom = 13; else if (accuracy > 100) zoom = 15;
  map.setView([lat, lng], zoom);
  if (geolocationManager.marker) geolocationManager.marker.openPopup();
}

function updateGeolocationStatus(text, state) {
  if (!geolocationManager.statusElement) return;
  const statusText = geolocationManager.statusElement.querySelector('.status-text');
  if (statusText) statusText.textContent = text;
  geolocationManager.statusElement.className = 'geolocation-status ' + state;
}

function showGeolocationError(message) {
  if (!geolocationManager.errorContainer) return;
  geolocationManager.errorContainer.textContent = '‚ö†Ô∏è ' + message;
  geolocationManager.errorContainer.style.display = 'block';
}

function hideGeolocationError() {
  if (!geolocationManager.errorContainer) return;
  geolocationManager.errorContainer.style.display = 'none';
  geolocationManager.errorContainer.textContent = '';
}

function attachGeolocationHandlers() {
  if (geolocationManager.toggleCheckbox) {
    geolocationManager.toggleCheckbox.addEventListener('change', (e) => {
      if (e.target.checked) enableGeolocation();
      else disableGeolocation();
    });
  }
  if (geolocationManager.centerButton) geolocationManager.centerButton.addEventListener('click', centerOnUserPosition);
}

function saveGeolocationPreference(enabled) {
  try { localStorage.setItem('gpx_geolocation_enabled', JSON.stringify(enabled)); } catch(e){}
}
function loadGeolocationPreference() {
  try { const saved = localStorage.getItem('gpx_geolocation_enabled'); return saved ? JSON.parse(saved) : false; } catch(e){ return false; }
}

// ---- Bootstrapping (apr√®s que la carte soit pr√™te) ----
(function bootGeolocWhenReady(){
  function ready() {
    // S'assure que map & L existent
    if (typeof L === 'undefined' || typeof map === 'undefined' || !map) {
      // r√©essaie au prochain tick
      return void requestAnimationFrame(ready);
    }
    initGeolocation();
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ready);
  } else {
    ready();
  }
})();

// Nettoyage
window.addEventListener('beforeunload', () => { stopGeolocationRefresh(); });

// √âconomie de batterie
document.addEventListener('visibilitychange', () => {
  if (document.hidden) stopGeolocationRefresh();
  else if (geolocationManager.enabled) { getCurrentPosition(); startGeolocationRefresh(); }
});


// === SAUVEGARDE LOCALE DE LA TRACE GPX ===

const GPX_STORAGE_KEY = 'gpx_saved_trace';
const GPX_WAYPOINTS_KEY = 'gpx_saved_waypoints';
/**
 * Sauvegarde la trace GPX et les waypoints dans localStorage
 */

function saveTraceToLocalStorage() {
  console.log('saveTraceToLocalStorage appel√©e');
  console.log('currentGpxDocument:', window.currentGpxDocument);
  console.log('currentGpxFileName:', window.currentGpxFileName);
  
  if (!window.currentGpxDocument || !window.currentGpxFileName) {
    console.warn('Pas de trace √† sauvegarder');
    return;
  }

  try {
    // S√©rialiser le document XML
    const serializer = new XMLSerializer();
    let gpxString = serializer.serializeToString(window.currentGpxDocument);
    if (!gpxString.startsWith('<?xml')) {
      gpxString = `<?xml version="1.0" encoding="UTF-8"?>
${gpxString}`;
    }

        // Collecter les waypoints affich√©s sur la carte (tous, GPX + personnalis√©s)
    const waypoints = [];
    const seen = new Set(); // anti-doublons lat/lng+nom
    const markers = (typeof getWaypointMarkers === 'function') ? getWaypointMarkers() : [];
    (markers || []).forEach((marker) => {
      const latlng = marker.getLatLng && marker.getLatLng();
      if (!latlng) return;
      const key = latlng.lat.toFixed(6) + ',' + latlng.lng.toFixed(6);
      const nameKey = (marker.waypointName || '').trim();
      const dedupKey = key + '|' + nameKey;
      if (seen.has(dedupKey)) return;
      seen.add(dedupKey);
      waypoints.push({ lat: latlng.lat, lng: latlng.lng, name: marker.waypointName || '' });
    });

    // Pr√©parer les donn√©es √† sauvegarder
    const traceData = {
      fileName: window.currentGpxFileName,
      traceName: window.currentTraceName || '',
      traceNameSource: window.traceNameSource || 'default',
      gpxContent: gpxString,
      waypoints: waypoints,
      timestamp: Date.now()
    };

    // Sauvegarder dans localStorage
    localStorage.setItem(GPX_STORAGE_KEY, JSON.stringify(traceData));
    console.log('üìù localStorage updated (waypoints:', waypoints.length, ')');
    
    console.log('‚úÖ Trace sauvegard√©e avec succ√®s:', window.currentGpxFileName);
    console.log('Waypoints sauvegard√©s:', waypoints.length);
    
    // Afficher le bouton "Effacer"
  } catch (error) {
    console.error('‚ùå Erreur sauvegarde:', error);
    
    // Si erreur de quota, informer l'utilisateur
    if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
      if (typeof showMessage === 'function') {
        showMessage('Trace trop volumineuse pour √™tre sauvegard√©e localement.', true);
      }
    }
  }
}


/**
 * Charge la trace sauvegard√©e depuis localStorage
 */

function loadTraceFromLocalStorage() {
  try {
    const savedData = localStorage.getItem(GPX_STORAGE_KEY);
    if (!savedData) return false;

    const traceData = JSON.parse(savedData);
    if (!traceData || !traceData.gpxContent || !traceData.fileName) return false;

    if (typeof showMessage === 'function') {
      showMessage('Chargement de la trace sauvegard√©e...', false);
    }

    // Parse GPX
    const parser = new DOMParser();
    const xml = parser.parseFromString(traceData.gpxContent, 'application/xml');
    const parseError = xml.querySelector('parsererror');
    if (parseError) throw new Error('Fichier GPX sauvegard√© invalide.');

    // Restore basic state
    window.currentGpxDocument = currentGpxDocument = xml;
    window.currentGpxFileName = currentGpxFileName = traceData.fileName;
    window.currentTraceName = currentTraceName = traceData.traceName || '';
    window.traceNameSource = traceNameSource = traceData.traceNameSource || 'default';

    if (typeof traceFileNameLabel !== 'undefined' && traceFileNameLabel) {
      traceFileNameLabel.textContent = traceData.fileName;
    }
    if (typeof gpxTraceFilename !== 'undefined' && gpxTraceFilename) {
      gpxTraceFilename.textContent = traceData.fileName;
    }
    if (typeof displayTraceName === 'function') {
      displayTraceName(window.currentTraceName, window.traceNameSource);
    }

    // Convert GPX to GeoJSON
    const geojson = (typeof convertGpxToGeoJSON === 'function') ? convertGpxToGeoJSON(xml) : null;
    const hasStoredWaypoints = Array.isArray(traceData.waypoints); // accept [] as authoritative
    if (hasStoredWaypoints && geojson && Array.isArray(geojson.features)) {
      geojson.features = geojson.features.filter(f => {
        const t = f && f.geometry && f.geometry.type;
        return t !== 'Point' && t !== 'MultiPoint';
      });
    }
    if (!geojson || !geojson.features || geojson.features.length === 0) {
      throw new Error('La trace sauvegard√©e est vide.');
    }

    if (typeof setExportAvailability === 'function') setExportAvailability(true);
    if (typeof displayGeoJSON === 'function') displayGeoJSON(geojson);
    if (typeof attachWaypointPersistence === 'function') attachWaypointPersistence();

    // Restore saved waypoints (dedup against any existing markers)
    if (hasStoredWaypoints) {
      if (typeof waypointCounter !== 'undefined') window.waypointCounter = 1;
      const existing = (typeof getWaypointMarkers === 'function') ? (getWaypointMarkers() || []) : [];
      traceData.waypoints.forEach((wp) => {
        if (!wp || !wp.lat || !wp.lng || typeof createWaypointMarker !== 'function') return;
        const lat = parseFloat(wp.lat), lng = parseFloat(wp.lng);
        const nameKey = (wp.name || '').trim();
        let duplicate = false;
        existing.forEach(m => {
          const ll = m && m.getLatLng && m.getLatLng();
          if (!ll) return;
          const mkName = (m.waypointName || '').trim();
          if (Math.abs(ll.lat - lat) < 1e-5 && Math.abs(ll.lng - lng) < 1e-5) {
            if (mkName === nameKey || !nameKey || !mkName) duplicate = true;
          }
        });
        if (!duplicate) createWaypointMarker(L.latLng(lat, lng), wp.name);
      });
    }

    // Elevation data
    if (typeof extractElevationData === 'function') {
      window.currentElevationData = currentElevationData = extractElevationData(geojson, xml);
      if (window.currentElevationData) {
        if (typeof updateElevationStats === 'function') updateElevationStats(window.currentElevationData.stats);
        if (typeof elevationProfile !== 'undefined' && elevationProfile) {
          elevationProfile.classList.add('visible');
          elevationProfile.setAttribute('aria-hidden', 'false');
          elevationProfile.classList.remove('collapsed');
          sizeCanvasToParent();
          if (typeof renderElevationProfile === 'function') renderElevationProfile();
        }
        if (typeof setElevationCollapsed === 'function') setElevationCollapsed(false);
        if (typeof renderElevationProfile === 'function') {
          requestAnimationFrame(() => {
            renderElevationProfile();
            setTimeout(() => { renderElevationProfile(); }, 200);
          });
          if (typeof ensureElevationRendered === 'function') ensureElevationRendered(12);
        }
      } else {
        if (typeof updateElevationStats === 'function') updateElevationStats(null);
        if (typeof calculateDistanceOnly === 'function') {
          const distanceOnly = calculateDistanceOnly(geojson);
          if (distanceOnly && typeof traceDistanceLabel !== 'undefined' && traceDistanceLabel) {
            traceDistanceLabel.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
          }
        }
      }
    }

    if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
      window.roadbookManager.update();
    }

    // UX message
    const elapsed = Date.now() - (traceData.timestamp || Date.now());
    const minutes = Math.max(0, Math.floor(elapsed / 60000));
    const timeAgo = minutes < 1 ? "√† l'instant" : minutes < 60 ? `il y a ${minutes} min` : `il y a ${Math.floor(minutes / 60)}h`;
    if (typeof showMessage === 'function' && typeof escapeHtml === 'function') {
      showMessage(`Trace "<strong>${escapeHtml(window.currentTraceName || traceData.fileName)}</strong>" recharg√©e (sauvegard√©e ${timeAgo}).`, false, true);
    } else {
      console.log(`Trace "${window.currentTraceName || traceData.fileName}" recharg√©e (sauvegard√©e ${timeAgo}).`);
    }

    return true;
  } catch (error) {
    console.error('Erreur lors du chargement de la trace sauvegard√©e :', error);
    try { localStorage.removeItem(GPX_STORAGE_KEY); } catch(_) {}
    return false;
  }
}

function clearSavedTrace() {
  try {
    currentGpxDocument = null;
    currentGpxFileName = '';
    currentTraceName = '';
    traceNameSource = 'default';
    currentGeojson = null;
  } catch (_){}

  try {
    if (typeof setExportAvailability === 'function') setExportAvailability(false);
    if (typeof updateWaypointsList === 'function') updateWaypointsList();
    if (typeof updateTraceInfo === 'function') updateTraceInfo(null);
    if (typeof displayTraceName === 'function') displayTraceName('‚Äî', 'default');
    if (typeof traceFileNameLabel !== 'undefined' && traceFileNameLabel) traceFileNameLabel.textContent = '‚Äî';
    if (typeof gpxTraceFilename !== 'undefined' && gpxTraceFilename) gpxTraceFilename.textContent = 'Aucune trace charg√©e';
    if (typeof gpxTraceDistance !== 'undefined' && gpxTraceDistance) gpxTraceDistance.textContent = '‚Äî';
    if (typeof gpxTraceElevation !== 'undefined' && gpxTraceElevation) gpxTraceElevation.textContent = '‚Äî';
    if (typeof resetElevationDisplay === 'function') resetElevationDisplay();
  } catch (_){}

  if (typeof showMessage === 'function') showMessage('Trace sauvegard√©e effac√©e et carte nettoy√©e.', false);

  try {
    localStorage.removeItem(GPX_STORAGE_KEY);
    localStorage.removeItem(GPX_WAYPOINTS_KEY);
  } catch (error) {
    console.error('Erreur lors de la suppression du stockage local :', error);
  }

  try {
    if (typeof clearPreviousLayers === 'function') clearPreviousLayers();
    if (typeof waypointLayerGroup !== 'undefined' && waypointLayerGroup && typeof waypointLayerGroup.clearLayers === 'function') waypointLayerGroup.clearLayers();
    if (typeof gpxLayerGroup !== 'undefined' && gpxLayerGroup && typeof gpxLayerGroup.clearLayers === 'function') gpxLayerGroup.clearLayers();
    if (typeof arrowLayerGroup !== 'undefined' && arrowLayerGroup && typeof arrowLayerGroup.clearLayers === 'function') arrowLayerGroup.clearLayers();
  } catch (error) {
    console.warn('Nettoyage des calques :', error);
  }

  try {
    window.currentGpxDocument = null;
    window.currentGpxFileName = '';
    window.currentTraceName = '';
    window.traceNameSource = 'default';
    if (typeof currentGpxDocument !== 'undefined') currentGpxDocument = null;
    if (typeof currentGpxFileName !== 'undefined') currentGpxFileName = '';
    if (typeof currentTraceName !== 'undefined') currentTraceName = '';
    if (typeof traceNameSource !== 'undefined') traceNameSource = 'default';
    if (typeof currentGeojson !== 'undefined') currentGeojson = null;
  } catch (error) {
    console.warn('R√©init variables :', error);
  }
}


// √âv√©nement du bouton "Effacer la trace" - Attachement diff√©r√©
function attachClearTraceButton() {
  const btn = document.getElementById('clear-trace-button');
  if (btn && !btn.__listenerAttached) {
    btn.__listenerAttached = true;
    const labelEl = btn.querySelector('.label');
    const originalLabel = labelEl ? labelEl.textContent : btn.textContent;
    btn.dataset.originalLabel = originalLabel;

    const resetState = () => {
      btn.dataset.confirming = 'false';
      btn.classList.remove('is-confirm');
      if (labelEl) {
        labelEl.textContent = btn.dataset.originalLabel || originalLabel;
      }
      if (btn.__confirmTimeout) {
        clearTimeout(btn.__confirmTimeout);
        btn.__confirmTimeout = null;
      }
    };
    btn.__resetConfirmState = resetState;

    btn.addEventListener('click', () => {
      if (btn.dataset.confirming === 'true') {
        resetState();
        clearSavedTrace();
        return;
      }

      btn.dataset.confirming = 'true';
      btn.classList.add('is-confirm');
      if (labelEl) {
        labelEl.textContent = 'Confirmer';
      }
      if (btn.__confirmTimeout) {
        clearTimeout(btn.__confirmTimeout);
      }
      btn.__confirmTimeout = setTimeout(() => {
        resetState();
      }, 4000);
    });

    btn.addEventListener('blur', resetState);
  }
}

// Charger automatiquement au d√©marrage
window.addEventListener('DOMContentLoaded', () => {
  // Attacher le bouton d'effacement
  attachClearTraceButton();
  
  // Attendre que la carte soit initialis√©e
  setTimeout(() => {
    loadTraceFromLocalStorage();
  }, 500);
});
// === Robust elevation render helper (enhanced) ===
function ensureElevationRendered(retries = 8) {
  try {
    const hasData = typeof currentElevationData !== 'undefined' && currentElevationData;
    const hasPoints = hasData && Array.isArray(currentElevationData.points) && currentElevationData.points.length > 1;
    const hasStats = hasData && currentElevationData.stats;
    const hasCanvas = typeof elevationCanvas !== 'undefined' && elevationCanvas;
    const hasProfile = typeof elevationProfile !== 'undefined' && elevationProfile;

    if (!(hasPoints && hasStats && hasCanvas && hasProfile)) {
      // Attempt self-heal: recompute elevation if geojson exists
      if ((!hasData || !hasPoints || !hasStats) && typeof extractElevationData === 'function' && typeof currentGeojson !== 'undefined' && currentGeojson) {
        try {
          const xml = window.currentGpxDocument || null;
          const recomputed = extractElevationData(currentGeojson, xml);
          if (recomputed) {
            window.currentElevationData = recomputed;
            if (typeof updateElevationStats === 'function') updateElevationStats(recomputed.stats);
            if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
              window.roadbookManager.update();
            }
          }
        } catch (e) {
          console.warn('Recompute elevation failed:', e);
        }
      }

      if (retries > 0) {
        setTimeout(() => ensureElevationRendered(retries - 1), 200);
      } else {
        console.warn('Elevation not ready after retries.', {
          hasData: !!hasData, hasPoints: !!hasPoints, hasStats: !!hasStats,
          hasCanvas: !!hasCanvas, hasProfile: !!hasProfile,
          pointsLen: hasData && currentElevationData.points ? currentElevationData.points.length : 0,
          canvasW: hasCanvas ? elevationCanvas.offsetWidth : null,
          canvasH: hasCanvas ? elevationCanvas.offsetHeight : null
        });
      }
      return;
    }

    // Ensure panel visible and not collapsed
    elevationProfile.classList.add('visible');
    elevationProfile.classList.remove('collapsed');
    elevationProfile.setAttribute('aria-hidden', 'false');

    // Ensure canvas has a non-zero size
    if (elevationCanvas && (elevationCanvas.offsetHeight === 0 || elevationCanvas.offsetWidth === 0)) {
      elevationCanvas.style.height = '240px';
      elevationCanvas.style.width = '100%';
    }

    // Render now
    if (typeof renderElevationProfile === 'function') {
      if (typeof fitElevationToViewport === 'function') fitElevationToViewport();
      renderElevationProfile();
      setTimeout(() => { if (typeof fitElevationToViewport === 'function') fitElevationToViewport(); renderElevationProfile(); }, 200);
    }
  } catch (e) {
    console.warn('ensureElevationRendered error:', e);
  }
}

// Re-render on resize as a safety net
window.addEventListener('resize', () => {
  if (typeof renderElevationProfile === 'function') {
    renderElevationProfile();
  }
});


// --- Responsive elevation canvas sizing ---
function resizeElevationCanvas() {
  if (!elevationCanvas || !elevationProfile) return;
  // Reserve a fraction of the viewport height while accounting for the panel header
  const viewportH = window.innerHeight || 800;
  const header = elevationProfile.querySelector('.elevation-header');
  const headerH = header ? header.offsetHeight : 48;
  // Target 28% of viewport, min 160px, max 420px
  const target = Math.max(160, Math.min(420, Math.floor(viewportH * 0.28)));
  // Apply height only if different to avoid layout thrash
  const targetPx = target + 'px';
  if (elevationCanvas.style.height !== targetPx) {
    elevationCanvas.style.height = targetPx;
  }
  elevationCanvas.style.width = '100%';
}

window.addEventListener('resize', () => {
  resizeElevationCanvas();
  if (typeof renderElevationProfile === 'function') {
    renderElevationProfile();
  }
});



// --- Viewport-aware elevation fit (strong) ---
function fitElevationToViewport() {
  try {
    if (typeof elevationProfile === 'undefined' || typeof elevationCanvas === 'undefined') return;
    if (!elevationProfile || !elevationCanvas) return;

    const rect = elevationProfile.getBoundingClientRect();
    const viewportH = window.innerHeight || document.documentElement.clientHeight || 800;

    // Account for bottom UI (dock, browser UI). Tune this if needed.
    const safeBottom = 40;
    let available = Math.floor(viewportH - rect.top - safeBottom);
    const minH = 180, maxH = 360; // tighter to avoid overflow

    if (!Number.isFinite(available) || available <= 0) available = 240;
    const target = Math.max(minH, Math.min(maxH, available));

    // Apply CSS size
    const targetPx = target + 'px';
    if (elevationCanvas.style.height !== targetPx) {
      elevationCanvas.style.height = targetPx;
    }
    elevationCanvas.style.width = '100%';

    // Sync intrinsic canvas size with DPR to avoid blurriness/clipping mismatch
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const cssW = elevationCanvas.clientWidth || elevationCanvas.offsetWidth || 800;
    const cssH = target;
    const wantW = Math.floor(cssW * dpr);
    const wantH = Math.floor(cssH * dpr);
    if (elevationCanvas.width !== wantW) elevationCanvas.width = wantW;
    if (elevationCanvas.height !== wantH) elevationCanvas.height = wantH;
  } catch (e) {
    console.warn('fitElevationToViewport error:', e);
  }
}

// (removed dynamic observers to prevent loops)
// === Elevation render scheduler (prevents tight loops) ===
let __elevRenderScheduled = false;
function scheduleElevationRender(reason) {
  try {
    if (__elevRenderScheduled) return;
    __elevRenderScheduled = true;
    requestAnimationFrame(() => {
      __elevRenderScheduled = false;
      if (typeof fitElevationToViewport === 'function') fitElevationToViewport();
      if (typeof renderElevationProfile === 'function') renderElevationProfile();
    });
  } catch (e) {
    console.warn('scheduleElevationRender error:', e);
    // Fallback direct render
    if (typeof renderElevationProfile === 'function') renderElevationProfile();
  }
}


// --- Minimal elevation canvas sizing (fixed height) ---
const ELEV_CANVAS_FIXED_H = 260; // px; change if you want bigger/smaller
function setElevationCanvasSize() {
  if (!window.elevationCanvas || !window.elevationProfile) return;
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const cssW = elevationProfile.clientWidth || elevationCanvas.parentElement?.clientWidth || elevationCanvas.clientWidth || 800;
  const cssH = ELEV_CANVAS_FIXED_H;
  elevationCanvas.style.width = '100%';
  elevationCanvas.style.height = cssH + 'px';
  const wantW = Math.max(1, Math.floor(cssW * dpr));
  const wantH = Math.max(1, Math.floor(cssH * dpr));
  if (elevationCanvas.width !== wantW) elevationCanvas.width = wantW;
  if (elevationCanvas.height !== wantH) elevationCanvas.height = wantH;
}


// --- Keep elevation container sized to canvas ---
function syncElevationContainer() {
  try {
    if (typeof elevationCanvas === 'undefined' || typeof elevationProfile === 'undefined') return;
    const content = document.getElementById('elevation-content');
    if (!content || !elevationCanvas) return;
    // Read actual canvas CSS height (not intrinsic pixels)
    const h = elevationCanvas.getBoundingClientRect().height;
    if (h && Math.abs((content.getBoundingClientRect().height || 0) - h) > 1) {
      content.style.height = h + 'px';
    }
  } catch (e) {
    console.warn('syncElevationContainer error:', e);
  }
}


// --- Canvas == parent size (with DPR) ---
function sizeCanvasToParent() {
  const parent = document.getElementById('elevation-content');
  const canvas = typeof elevationCanvas !== 'undefined' ? elevationCanvas : document.getElementById('elevation-canvas');
  if (!parent || !canvas) return;
  const rect = parent.getBoundingClientRect();
  // If parent is hidden/collapsed, skip (will be re-called later)
  if (!rect.width || !rect.height) return;

  // CSS size already set via width/height:100%; sync intrinsic pixels for crisp rendering
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const wantW = Math.max(1, Math.floor(rect.width * dpr));
  const wantH = Math.max(1, Math.floor(rect.height * dpr));
  if (canvas.width !== wantW) canvas.width = wantW;
  if (canvas.height !== wantH) canvas.height = wantH;
}

// Observe parent size changes
(function observeParentForCanvas(){
  try {
    const parent = document.getElementById('elevation-content');
    if (!parent) return;
    const ro = new ResizeObserver(() => sizeCanvasToParent());
    ro.observe(parent);
    // First sizing attempt
    sizeCanvasToParent();
  } catch (e) {
    console.warn('ResizeObserver not available or failed:', e);
    // Fallback: size once on load
    setTimeout(sizeCanvasToParent, 100);
  }
})();


// === PERSISTENCE WAYPOINTS ‚Äî debounce & group hooks ===
if (typeof window.__saveWpTimer === 'undefined') window.__saveWpTimer = null;
function saveTraceDebounced(delay = 120) {
  if (typeof saveTraceToLocalStorage !== 'function') return;
  clearTimeout(window.__saveWpTimer);
  window.__saveWpTimer = setTimeout(() => {
    try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); }
  }, delay);
}

function attachWaypointPersistence() {
  try {
    if (typeof waypointLayerGroup === 'undefined' || !waypointLayerGroup || typeof waypointLayerGroup.on !== 'function') return;
    waypointLayerGroup.off('layeradd', saveTraceDebounced);
    waypointLayerGroup.off('layerremove', saveTraceDebounced);
    waypointLayerGroup.on('layeradd', () => saveTraceDebounced());
    waypointLayerGroup.on('layerremove', () => saveTraceDebounced());
    // initial sync
    saveTraceDebounced(10);
  } catch (e) { console.warn('attachWaypointPersistence:', e); }
}

</script>
<script>
// --- Hotfix: √©viter la r√©cursion de __lsSetItem en fixant la m√©thode native ---
(function(){
  try {
    var __nativeSetItem = (Storage && Storage.prototype && Storage.prototype.setItem)
      ? Storage.prototype.setItem.bind(localStorage)
      : function(k,v){ localStorage.setItem(k, v); };
    // Version s√ªre : n'appelle jamais localStorage.setItem directement (qui pourrait √™tre surcharg√©)
    window.__lsSetItem = function(key, value){
      try { __nativeSetItem(key, value); return true; }
      catch(e){ console.warn('Erreur setItem localStorage (safe):', e); return false; }
    };
  } catch(e){
    console.warn('Hotfix __lsSetItem init failed:', e);
  }
})();
</script>
<script>
// === Start/End markers for GPX trace ===
window.__TRACE_MARKERS__ = true; // guard flag
let startMarker = null;
let endMarker = null;

/** Centre la carte sur un point */
function centerOnPoint(lat, lng) {
  if (typeof map !== 'undefined' && map && map.setView) {
    map.setView([lat, lng], Math.max(map.getZoom(), 15));
  }
}

/** HTML du popup pour start/end */
function createTraceMarkerPopup(latlng, type, elevation) {
  const isStart = type === 'start';
  const icon = isStart ? 'üü¢' : 'üèÅ';
  const title = isStart ? 'D√©part' : 'Arriv√©e';
  const eleRow = (elevation !== null && Number.isFinite(elevation))
    ? `<div class="trace-marker-popup-row">
         <span class="trace-marker-popup-label">Altitude :</span>
         <span class="trace-marker-popup-value">${Math.round(elevation)} m</span>
       </div>` : '';
  return `
    <div class="trace-marker-popup">
      <div class="trace-marker-popup-header">
        <span style="font-size:1.5rem;">${icon}</span>
        <strong class="trace-marker-popup-title">${title}</strong>
      </div>
      <div class="trace-marker-popup-details">
        <div class="trace-marker-popup-row">
          <span class="trace-marker-popup-label">Latitude :</span>
          <span class="trace-marker-popup-value">${latlng.lat.toFixed(6)}¬∞</span>
        </div>
        <div class="trace-marker-popup-row">
          <span class="trace-marker-popup-label">Longitude :</span>
          <span class="trace-marker-popup-value">${latlng.lng.toFixed(6)}¬∞</span>
        </div>
        ${eleRow}
      </div>
      <button class="btn btn-primary btn-small trace-marker-popup-button"
              onclick="centerOnPoint(${latlng.lat}, ${latlng.lng})">
        <span aria-hidden="true">üéØ</span> Centrer sur ce point
      </button>
    </div>`;
}

/** Cr√©e un divIcon + marker (start/end) */
function createTraceMarker(latlng, type, elevation = null) {
  const isStart = type === 'start';
  const className = isStart ? 'trace-start-marker' : 'trace-end-marker';
  const label = isStart ? 'üü¢ D√©part de la trace' : 'üèÅ Arriv√©e de la trace';
  const inner = `<div class="${className}-inner"><span class="${className}-icon">${isStart ? 'üü¢' : 'üèÅ'}</span></div>`;
  const icon = L.divIcon({
    className, html: inner, iconSize: [32,32], iconAnchor: [16,16], popupAnchor: [0,-16]
  });
  const marker = L.marker(latlng, {
    icon, zIndexOffset: 2000, title: label, riseOnHover: true
  });
  marker.bindTooltip(label, { direction: 'top', offset: [0, -16] });
  marker.bindPopup(createTraceMarkerPopup(latlng, type, elevation), { maxWidth: 250, className: 'trace-marker-popup-container' });
  return marker;
}

/** Marqueur combin√© pour boucle (d√©part = arriv√©e) */
function createCombinedMarker(latlng, elevation = null) {
  const icon = L.divIcon({
    className: 'trace-combined-marker',
    html: `<div class="trace-combined-marker-inner"><span class="trace-combined-marker-icon">üîÑ</span></div>`,
    iconSize: [32,32], iconAnchor: [16,16], popupAnchor: [0,-16]
  });
  const marker = L.marker(latlng, { icon, zIndexOffset: 2000, title: 'D√©part/Arriv√©e (trace circulaire)', riseOnHover: true });
  marker.bindTooltip('üîÑ D√©part/Arriv√©e', { direction: 'top', offset: [0, -16] });
  const html = `
    <div class="trace-marker-popup">
      <div class="trace-marker-popup-header">
        <span style="font-size:1.5rem;">üîÑ</span>
        <strong class="trace-marker-popup-title">D√©part/Arriv√©e</strong>
      </div>
      <div class="trace-marker-popup-details">
        <div class="trace-marker-popup-row"><span class="trace-marker-popup-label">Type :</span><span class="trace-marker-popup-value">Trace circulaire</span></div>
        <div class="trace-marker-popup-row"><span class="trace-marker-popup-label">Latitude :</span><span class="trace-marker-popup-value">${latlng.lat.toFixed(6)}¬∞</span></div>
        <div class="trace-marker-popup-row"><span class="trace-marker-popup-label">Longitude :</span><span class="trace-marker-popup-value">${latlng.lng.toFixed(6)}¬∞</span></div>
        ${Number.isFinite(elevation) ? `<div class="trace-marker-popup-row"><span class="trace-marker-popup-label">Altitude :</span><span class="trace-marker-popup-value">${Math.round(elevation)} m</span></div>` : ''}
      </div>
      <button class="btn btn-primary btn-small trace-marker-popup-button" onclick="centerOnPoint(${latlng.lat}, ${latlng.lng})">
        <span aria-hidden="true">üéØ</span> Centrer sur ce point
      </button>
    </div>`;
  marker.bindPopup(html, { maxWidth: 250, className: 'trace-marker-popup-container' });
  return marker;
}

/** Extrait start/end (LineString ou MultiLineString) + alt */
function extractTraceEndpoints(geojson) {
  if (!geojson || !Array.isArray(geojson.features)) return null;
  const lineFeatures = geojson.features.filter(f => {
    const t = f?.geometry?.type;
    return t === 'LineString' || t === 'MultiLineString';
  });
  if (lineFeatures.length === 0) return null;

  let firstCoord = null, lastCoord = null;
  lineFeatures.forEach((feature) => {
    const g = feature.geometry, coords = g.coordinates;
    if (g.type === 'LineString') {
      if (!firstCoord && coords.length) firstCoord = coords[0];
      if (coords.length) lastCoord = coords[coords.length - 1];
    } else if (g.type === 'MultiLineString') {
      (coords || []).forEach(seg => {
        if (!firstCoord && seg.length) firstCoord = seg[0];
        if (seg.length) lastCoord = seg[seg.length - 1];
      });
    }
  });

  if (!firstCoord || !lastCoord) return null;
  const start = L.latLng(firstCoord[1], firstCoord[0]);
  const end   = L.latLng(lastCoord[1],  lastCoord[0]);
  const startEle = firstCoord.length > 2 ? firstCoord[2] : null;
  const endEle   = lastCoord.length  > 2 ? lastCoord[2]  : null;
  return { start, end, startEle, endEle };
}

/** Ajoute les marqueurs de d√©part/arriv√©e (ou combin√©) */
function addTraceEndpointMarkers(geojson) {
  try {
    removeTraceEndpointMarkers();
    const endpoints = extractTraceEndpoints(geojson);
    if (!endpoints) return;
    const { start, end, startEle, endEle } = endpoints;
    if (typeof map === 'undefined' || !map) return;
    const isSamePoint = map.distance(start, end) < 10; // < 10 m => boucle
    if (isSamePoint) {
      startMarker = createCombinedMarker(start, startEle ?? endEle ?? null);
      startMarker.addTo(map);
    } else {
      startMarker = createTraceMarker(start, 'start', startEle);
      endMarker   = createTraceMarker(end,   'end',   endEle);
      startMarker.addTo(map);
      endMarker.addTo(map);
    }
  } catch(e) {
    console.warn('addTraceEndpointMarkers error:', e);
  }
}

/** Supprime les marqueurs s'ils existent */
function removeTraceEndpointMarkers() {
  try {
    if (typeof map !== 'undefined' && map) {
      if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
      if (endMarker)   { map.removeLayer(endMarker);   endMarker   = null; }
    } else {
      startMarker = null; endMarker = null;
    }
  } catch(e) {
    console.warn('removeTraceEndpointMarkers error:', e);
  }
}
</script>
<script>
// === Syst√®me g√©n√©rique de sections collapsibles ===
window.collapsibleSections = window.collapsibleSections || {};
const collapsibleSections = Object.assign(window.collapsibleSections, {
  mapStyle: {
    id: 'map-style-section',
    storageKey: 'gpx_map_style_section_expanded',
    defaultExpanded: false,
    section: null,
    toggle: null,
    content: null,
    isExpanded: false,
    boundToggleHandler: null,
    initialized: false
  },
  layers: {
    id: 'layers-section',
    storageKey: 'gpx_layers_section_expanded',
    defaultExpanded: true,
    section: null,
    toggle: null,
    content: null,
    isExpanded: true,
    boundToggleHandler: null,
    initialized: false
  },
  waypoints: {
    id: 'waypoints-section',
    storageKey: null,
    defaultExpanded: false,
    section: null,
    toggle: null,
    content: null,
    isExpanded: false,
    boundToggleHandler: null,
    initialized: false
  },
  roadbook: {
    id: 'roadbook-section',
    storageKey: null,
    defaultExpanded: false,
    section: null,
    toggle: null,
    content: null,
    isExpanded: false,
    boundToggleHandler: null,
    initialized: false
  }
});

function ensureSectionElements(config) {
  if (config.section && config.toggle && config.content) {
    return true;
  }
  config.section = document.getElementById(config.id);
  if (!config.section) {
    return false;
  }
  config.toggle = config.section.querySelector('.section-header-toggle');
  config.content = config.section.querySelector('.section-collapsible-content');
  return Boolean(config.toggle && config.content);
}

function saveSectionState(sectionKey, expanded) {
  const config = collapsibleSections[sectionKey];
  if (!config || !config.storageKey) {
    return;
  }
  try {
    localStorage.setItem(config.storageKey, JSON.stringify(expanded));
  } catch (error) {
    console.warn(`Impossible de sauvegarder l'√©tat de "${sectionKey}":`, error);
  }
}

function loadSectionState(sectionKey) {
  const config = collapsibleSections[sectionKey];
  if (!config) {
    return false;
  }
  if (!config.storageKey) {
    return config.defaultExpanded;
  }
  try {
    const saved = localStorage.getItem(config.storageKey);
    if (saved === null) {
      return config.defaultExpanded;
    }
    return JSON.parse(saved);
  } catch (error) {
    console.warn(`Erreur lors du chargement de l'√©tat de "${sectionKey}":`, error);
    return config.defaultExpanded;
  }
}

function handleSectionOpened(sectionKey) {
  if (sectionKey === 'mapStyle') {
    const refreshPreviews = window.__mapStylePreviews?.refresh;
    if (typeof refreshPreviews === 'function') {
      refreshPreviews();
    }
  }
}

function setSectionExpanded(sectionKey, expanded, animate = true) {
  const config = collapsibleSections[sectionKey];
  if (!config) {
    return;
  }
  if (!ensureSectionElements(config)) {
    return;
  }

  config.isExpanded = expanded;

  const applyState = () => {
    config.section.classList.toggle('expanded', expanded);
    config.toggle.setAttribute('aria-expanded', String(expanded));
  };

  if (!animate) {
    const previousTransition = config.content.style.transition;
    config.content.style.transition = 'none';
    applyState();
    requestAnimationFrame(() => {
      config.content.style.transition = previousTransition || '';
      if (expanded) {
        handleSectionOpened(sectionKey);
      }
    });
    return;
  }

  applyState();

  if (expanded) {
    setTimeout(() => handleSectionOpened(sectionKey), 350);
  }
}

function toggleSection(sectionKey) {
  const config = collapsibleSections[sectionKey];
  if (!config) {
    return;
  }
  const newState = !config.isExpanded;
  setSectionExpanded(sectionKey, newState, true);
  saveSectionState(sectionKey, newState);
}

function initCollapsibleSection(sectionKey) {
  const config = collapsibleSections[sectionKey];
  if (!config) {
    return;
  }

  if (!ensureSectionElements(config)) {
    config.initialized = false;
    return;
  }

  if (config.boundToggleHandler) {
    config.toggle.removeEventListener('click', config.boundToggleHandler);
  }

  config.isExpanded = loadSectionState(sectionKey);
  setSectionExpanded(sectionKey, config.isExpanded, false);

  config.boundToggleHandler = () => toggleSection(sectionKey);
  config.toggle.addEventListener('click', config.boundToggleHandler);
  config.initialized = true;
}

function initCollapsibleSections() {
  Object.keys(collapsibleSections).forEach((sectionKey) => {
    initCollapsibleSection(sectionKey);
  });
}

window.collapsibleSectionsAPI = {
  expand: (sectionKey) => {
    setSectionExpanded(sectionKey, true, true);
    saveSectionState(sectionKey, true);
  },
  collapse: (sectionKey) => {
    setSectionExpanded(sectionKey, false, true);
    saveSectionState(sectionKey, false);
  },
  toggle: (sectionKey) => toggleSection(sectionKey),
  isExpanded: (sectionKey) => {
    const config = collapsibleSections[sectionKey];
    return config ? Boolean(config.isExpanded) : false;
  },
  init: (sectionKey) => initCollapsibleSection(sectionKey)
};

document.addEventListener('DOMContentLoaded', initCollapsibleSections);
</script>
<script>
(function(){
  function initSidebarMapStyleSection(){
    var container = document.getElementById('map-style-section');
    if (!container) return;
    var buttons = Array.prototype.slice.call(container.querySelectorAll('.map-style-option'));
    if (!buttons.length) return;

    function setActive(id){
      buttons.forEach(function(b){
        if (b.getAttribute('data-style') === id) b.classList.add('active');
        else b.classList.remove('active');
      });
    }

    // Determine saved or default style
    var saved = null;
    try { saved = localStorage.getItem('gpx_map_style'); } catch(e) {}
    var styleId = (saved && saved.trim()) ? saved : 'voyager';

    // Apply on map immediately
    if (typeof changeMapStyle === 'function') {
      changeMapStyle(styleId);
    }
    // Reflect active button
    setActive(styleId);

    // Wire clicks
    buttons.forEach(function(btn){
      btn.addEventListener('click', function(){
        var id = btn.getAttribute('data-style');
        if (!id) return;
        if (typeof changeMapStyle === 'function'){ changeMapStyle(id); }
        setActive(id);
        try { localStorage.setItem('gpx_map_style', id); } catch(_) {}
      });
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initSidebarMapStyleSection);
  } else {
    initSidebarMapStyleSection();
  }
})();
</script>
<script>
// === Previews for map styles in sidebar (full-width + synced to main map) ===
(function(){
  var __previewMaps = {}; // styleId -> Leaflet map
  var __previewLayers = {}; // styleId -> array of tile layers

  function buildLayersFor(styleId){
    if (!window.mapStyles || !mapStyles[styleId]) return [];
    var style = mapStyles[styleId];
    if (style.layers) {
      return style.layers.map(function(ld){
        return L.tileLayer(ld.url, { maxZoom: ld.maxZoom, attribution: style.attribution || '' });
      });
    } else {
      return [ L.tileLayer(style.url, { maxZoom: style.maxZoom, attribution: style.attribution || '' }) ];
    }
  }

  function ensurePreview(styleId){
    var el = document.getElementById('map-thumb-' + styleId);
    if (!el || !window.L) return null;
    if (__previewMaps[styleId]) return __previewMaps[styleId];

    var mapPrev = L.map(el, {
      attributionControl: false,
      zoomControl: false,
      dragging: false,
      scrollWheelZoom: false,
      doubleClickZoom: false,
      boxZoom: false,
      keyboard: false,
      tap: false,
      touchZoom: false,
      inertia: false
    });

    var layers = buildLayersFor(styleId);
    __previewLayers[styleId] = layers;
    layers.forEach(function(ly){ ly.addTo(mapPrev); });

    // Default view will be adjusted by sync
    __previewMaps[styleId] = mapPrev;
    // Store a flag to avoid re-init
    el.dataset.inited = '1';
    return mapPrev;
  }

  function initPreviews(){
    var container = document.getElementById('map-style-section');
    if (!container) return;
    var thumbs = Array.prototype.slice.call(container.querySelectorAll('.map-style-thumb-inner'));
    thumbs.forEach(function(div){
      var id = div.id.replace('map-thumb-', '');
      if (!id) return;
      ensurePreview(id);
    });

    // Initial sync once main map exists
    if (window.map) {
      syncPreviewsToMain();
      // Listen to move/zoom to update previews
      map.on('moveend zoomend', syncPreviewsToMain);
    }

    // Invalidate size on resize to avoid clipped tiles
    window.addEventListener('resize', function(){
      Object.keys(__previewMaps).forEach(function(k){
        __previewMaps[k].invalidateSize();
      });
    });
  }

  function syncPreviewsToMain(){
    if (!window.map) return;
    var center = map.getCenter();
    var zoom = map.getZoom();
    Object.keys(__previewMaps).forEach(function(k){
      var m = __previewMaps[k];
      // Keep it snappy; avoid animation to not feel laggy
      m.setView(center, zoom, { animate: false });
      m.invalidateSize();
    });
  }

  // If the user switches panel visibility or styles, refresh sizes
  function refreshPreviewsLayout(){
    Object.keys(__previewMaps).forEach(function(k){
      __previewMaps[k].invalidateSize();
    });
    syncPreviewsToMain();
  }

  // Rebuild layers for a preview if needed (e.g., style definitions changed)
  function refreshPreviewLayers(styleId){
    var m = __previewMaps[styleId];
    if (!m) return;
    // remove old layers
    if (__previewLayers[styleId]) {
      __previewLayers[styleId].forEach(function(ly){ m.removeLayer(ly); });
    }
    var layers = buildLayersFor(styleId);
    __previewLayers[styleId] = layers;
    layers.forEach(function(ly){ ly.addTo(m); });
    m.invalidateSize();
  }

  // Hook into sidebar‚Äôs button clicks to refresh highlight and previews layout
  document.addEventListener('click', function(e){
    var btn = e.target.closest && e.target.closest('#map-style-section .map-style-option');
    if (!btn) return;
    setTimeout(refreshPreviewsLayout, 0);
  });

  // Observe DOM changes inside map-style-section (accordion toggles etc.)
  var obs;
  function observeSection(){
    var sec = document.getElementById('map-style-section');
    if (!sec) return;
    if (obs) { try { obs.disconnect(); } catch(_){} }
    obs = new MutationObserver(function(){ setTimeout(refreshPreviewsLayout, 0); });
    obs.observe(sec, { childList: true, subtree: true, attributes: true });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      initPreviews();
      observeSection();
    });
  } else {
    initPreviews();
    observeSection();
  }

  // Expose minimal API if needed
  window.__mapStylePreviews = {
    refresh: refreshPreviewsLayout,
    refreshLayers: refreshPreviewLayers
  };
})();
</script>

<!-- ==================== FOOTER SEO (masqu√© visuellement) ==================== -->
<footer id="seo-footer" style="position:absolute;left:-9999px;width:1px;height:1px;overflow:hidden;" aria-hidden="true">
  <h2>√Ä propos de Cycling Companion</h2>
  <p>
    <strong>Cycling Companion</strong> est un outil gratuit et <strong>open source</strong> de planification 
    d'itin√©raires pour le <strong>bikepacking</strong> et le <strong>cyclotourisme</strong>. 
    D√©velopp√© par <a href="https://lamouche.fr" rel="author">Benoit Lamouche</a> 
    (<a href="https://twitter.com/blamouche" rel="author">@blamouche</a>), cet outil 
    vous permet d'importer vos <strong>traces GPX</strong>, de visualiser le 
    <strong>profil d'√©l√©vation</strong> avec statistiques d√©taill√©es (d√©nivel√© positif D+, 
    d√©nivel√© n√©gatif D-, distance totale), d'ajouter des <strong>waypoints personnalis√©s</strong> 
    et de trouver facilement les <strong>points d'int√©r√™t essentiels</strong> pour vos aventures √† v√©lo.
  </p>
  
  <h3>Fonctionnalit√©s principales pour le bikepacking</h3>
  <ul>
    <li><strong>Import et export GPX</strong> : Compatibilit√© totale avec Komoot, Strava, Garmin, Wahoo, Suunto</li>
    <li><strong>Profil d'√©l√©vation interactif</strong> : Visualisez le d√©nivel√© en temps r√©el avec votre souris</li>
    <li><strong>Gestion de waypoints</strong> : Cr√©ez des points d'√©tape avec noms personnalisables</li>
    <li><strong>Roadbook automatique</strong> : G√©n√©rez un carnet de route d√©taill√© avec distances cumul√©es et D+ restant</li>
    <li><strong>Recherche de POI</strong> : Trouvez eau potable, nourriture, h√©bergement, r√©paration v√©lo</li>
    <li><strong>Multiples fonds de carte</strong> : CyclOSM (optimis√©e cyclisme), OpenStreetMap, OpenTopoMap (relief), vue satellite Esri</li>
    <li><strong>G√©olocalisation GPS</strong> : Suivez votre position en temps r√©el sur la trace</li>
    <li><strong>Sauvegarde automatique</strong> : Vos donn√©es restent priv√©es, stock√©es localement dans votre navigateur</li>
    <li><strong>100% gratuit</strong> : Aucune inscription, aucune publicit√©, code open source sur GitHub</li>
    <li><strong>Application web progressive (PWA)</strong> : Installez l'app sur votre t√©l√©phone et utilisez-la hors ligne</li>
  </ul>

  <h3>Points d'int√©r√™t pour cyclotouristes et bikepackers</h3>
  <p>
    Localisez facilement tous les services essentiels le long de votre parcours cycliste :
  </p>
  <ul>
    <li><strong>Eau potable</strong> : Fontaines publiques, points d'eau, cimeti√®res (robinets d'eau gratuits)</li>
    <li><strong>Alimentation</strong> : Supermarch√©s, √©piceries, boulangeries, restaurants, caf√©s, fast-food</li>
    <li><strong>H√©bergement outdoor</strong> : Campings, bivouacs autoris√©s, zones de camping sauvage, refuges montagne, refuges alpins</li>
    <li><strong>H√©bergement confort</strong> : H√¥tels, auberges de jeunesse, chambres d'h√¥tes, g√Ætes</li>
    <li><strong>Services v√©lo</strong> : Stations de r√©paration self-service, magasins de cycles, v√©locistes</li>
    <li><strong>Hygi√®ne et sanitaires</strong> : Toilettes publiques, douches, blocs sanitaires</li>
    <li><strong>Sant√©</strong> : Pharmacies, h√¥pitaux, centres m√©dicaux</li>
    <li><strong>Patrimoine</strong> : Cimeti√®res (point d'eau), monuments historiques</li>
  </ul>

  <h3>Pour qui ?</h3>
  <p>
    Cycling Companion s'adresse √† tous les passionn√©s de <strong>voyage √† v√©lo</strong> :
  </p>
  <ul>
    <li><strong>Bikepackers</strong> solos ou en groupe pr√©parant des aventures multi-jours</li>
    <li><strong>Cyclotouristes</strong> longue distance planifiant des itin√©raires √† travers la France et l'Europe</li>
    <li><strong>Gravel riders</strong> cherchant des parcours mixtes route/chemin</li>
    <li><strong>V√©t√©tistes en itin√©rance</strong> explorant les sentiers et single tracks</li>
    <li><strong>Cyclistes ultra-distance</strong> (audax, brevets, ultra-cycling)</li>
    <li><strong>Voyageurs √† v√©lo</strong> pr√©parant des week-ends bikepacking ou des vacances cyclistes</li>
    <li><strong>Organisateurs de randonn√©es</strong> cyclosportives ou √©v√©nements v√©lo</li>
  </ul>

  <h3>Cas d'usage typiques</h3>
  <ul>
    <li>Pr√©parer un voyage bikepacking de plusieurs jours avec √©tapes quotidiennes</li>
    <li>Planifier un itin√©raire cyclotourisme √† travers les v√©loroutes europ√©ennes (EuroVelo)</li>
    <li>Rep√©rer les points d'eau et de ravitaillement sur un parcours gravel</li>
    <li>Calculer le d√©nivel√© total et anticiper les difficult√©s d'un parcours montagne</li>
    <li>Trouver des campings et bivouacs le long d'un itin√©raire</li>
    <li>Exporter une trace GPX enrichie avec waypoints pour son GPS Garmin, Wahoo ou Sigma</li>
    <li>Partager un itin√©raire d√©taill√© avec roadbook √† ses compagnons de voyage</li>
  </ul>

  <h3>Technologies et donn√©es ouvertes</h3>
  <p>
    Application web responsive et moderne bas√©e sur <strong>Leaflet.js</strong> pour la cartographie interactive 
    et les donn√©es libres <strong>OpenStreetMap</strong>. Points d'int√©r√™t fournis en temps r√©el par 
    <strong>Overpass API</strong>. Multiples fonds de carte disponibles : 
  </p>
  <ul>
    <li><strong>CyclOSM</strong> : Carte optimis√©e pour le cyclisme avec pistes cyclables, v√©loroutes et voies vertes</li>
    <li><strong>OpenStreetMap</strong> : Carte standard collaborative mondiale</li>
    <li><strong>OpenTopoMap</strong> : Carte topographique avec courbes de niveau et relief</li>
    <li><strong>Esri Satellite</strong> : Imagerie satellite haute r√©solution</li>
    <li><strong>Esri Hybrid</strong> : Satellite avec labels et noms de lieux</li>
  </ul>
  <p>
    Compatible avec tous les navigateurs modernes (Chrome, Firefox, Safari, Edge) sur mobile, tablette et desktop. 
    Interface optimis√©e pour √©crans tactiles. Application web progressive installable sur iOS et Android.
  </p>

  <h3>Open Source et contributions</h3>
  <p>
    Code source disponible sur 
    <a href="https://github.com/blamouche/bikepacking-gpx-manager" target="_blank" rel="noopener">
      GitHub
    </a>. 
    Contributions, suggestions et rapports de bugs sont les bienvenus ! Licence MIT.
  </p>
  
  <h3>Compatibilit√© GPS et applications</h3>
  <p>
    Les fichiers GPX export√©s sont compatibles avec :
  </p>
  <ul>
    <li><strong>GPS de v√©lo</strong> : Garmin Edge, Wahoo ELEMNT, Sigma ROX, Bryton, Hammerhead Karoo</li>
    <li><strong>Montres GPS</strong> : Garmin Fenix, Suunto, Polar, Coros</li>
    <li><strong>Smartphones</strong> : Komoot, Strava, Ride with GPS, ViewRanger, OruxMaps</li>
    <li><strong>Applications web</strong> : Strava Routes, Komoot, Ride with GPS, Bikemap</li>
  </ul>

  <h3>Donn√©es et confidentialit√©</h3>
  <p>
    Cycling Companion respecte votre vie priv√©e. Aucune donn√©e personnelle n'est collect√©e ou envoy√©e 
    √† un serveur externe. Vos traces GPX et waypoints sont sauvegard√©s uniquement dans le stockage local 
    de votre navigateur (localStorage). Aucun compte utilisateur requis. Aucun cookie de tracking. 
    Application conforme RGPD.
  </p>

  <h3>Mots-cl√©s et recherche</h3>
  <p>
    bikepacking, cyclotourisme, trace GPX, profil altim√©trique, d√©nivel√© positif, d√©nivel√© n√©gatif, 
    waypoints, roadbook v√©lo, planification itin√©raire v√©lo, carte cyclable, points d'int√©r√™t v√©lo, 
    eau potable v√©lo, bivouac v√©lo, camping v√©lo, gravel bike, voyage √† v√©lo, ultra-cycling, 
    randonneur cycliste, cyclosportif, v√©loroute, voie verte, EuroVelo, grande travers√©e VTT, 
    OpenStreetMap, CyclOSM, Leaflet, application web progressive, PWA v√©lo, GPS v√©lo, 
    Garmin GPX, Komoot alternative, Strava route planner, Ride with GPS alternative
  </p>

  <p>
    <small>
      Donn√©es cartographiques ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a> | 
      CyclOSM ¬© <a href="https://www.cyclosm.org/">CyclOSM</a> | 
      Esri Imagery ¬© <a href="https://www.esri.com/">Esri</a> |
      D√©velopp√© par <a href="https://lamouche.fr">Benoit Lamouche</a> | 
      Twitter: <a href="https://twitter.com/blamouche">@blamouche</a> | 
      Code source: <a href="https://github.com/blamouche/bikepacking-gpx-manager">GitHub</a>
    </small>
  </p>
</footer>

<!-- ==================== SERVICE WORKER REGISTRATION (PWA) ==================== -->
<script>
  // Enregistrement du Service Worker pour fonctionnalit√© PWA
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register('/bikepacking-gpx-manager/sw.js')
        .then((registration) => {
          console.log('‚úÖ Service Worker enregistr√©:', registration.scope);
          
          // V√©rifier les mises √† jour p√©riodiquement
          setInterval(() => {
            registration.update();
          }, 60 * 60 * 1000); // Toutes les heures
        })
        .catch((error) => {
          console.log('‚ùå √âchec enregistrement Service Worker:', error);
        });
      
      // G√©rer les mises √† jour du Service Worker
      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (!refreshing) {
          refreshing = true;
          window.location.reload();
        }
      });
    });
  }
</script>
</body>
</html>
