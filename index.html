<!DOCTYPE html>

<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Cycling Companion - Localisez les points d'intérêt dont vous avez besoin</title>
<!-- ==================== SEO META TAGS ==================== -->

<!-- Description principale -->
<meta name="description" content="Planifiez vos sorties bikepacking avec Cycling Companion : importez vos traces GPX, visualisez le profil d'élévation, ajoutez des waypoints et trouvez les points d'intérêt (eau, nourriture, hébergement) le long de votre parcours.">

<!-- Mots-clés -->
<meta name="keywords" content="bikepacking, cyclotourisme, planification itinéraire vélo, trace GPX, profil altimétrique, waypoints, points d'intérêt cyclisme, carte vélo interactive, hébergement cycliste, bivouac vélo, gravel bike, voyage à vélo">

<!-- Auteur -->
<meta name="author" content="Benoit Lamouche">

<!-- Robots -->
<meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">

<!-- Langue -->
<meta name="language" content="fr">
<link rel="alternate" hreflang="fr" href="https://blamouche.github.io/bikepacking-gpx-manager/">
<link rel="alternate" hreflang="x-default" href="https://blamouche.github.io/bikepacking-gpx-manager/">

<!-- URL Canonique -->
<link rel="canonical" href="https://blamouche.github.io/bikepacking-gpx-manager/">

<!-- Géolocalisation -->
<meta name="geo.region" content="FR">
<meta name="geo.placename" content="France">

<!-- ==================== OPEN GRAPH (Facebook, LinkedIn) ==================== -->

<meta property="og:type" content="website">
<meta property="og:site_name" content="Cycling Companion">
<meta property="og:title" content="Cycling Companion - Planificateur d'itinéraires bikepacking et cyclotourisme">
<meta property="og:description" content="Outil gratuit de planification pour vos aventures à vélo : importez vos traces GPX, visualisez le dénivelé, ajoutez des waypoints et trouvez facilement les points d'eau, restaurants et hébergements le long de votre parcours.">
<meta property="og:url" content="https://blamouche.github.io/bikepacking-gpx-manager/">
<meta property="og:image" content="https://blamouche.github.io/bikepacking-gpx-manager/img/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:image:alt" content="Interface de Cycling Companion montrant une carte interactive avec trace GPX et points d'intérêt">
<meta property="og:image:type" content="image/png">
<meta property="og:locale" content="fr_FR">

<!-- ==================== TWITTER CARDS ==================== -->

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@blamouche">
<meta name="twitter:creator" content="@blamouche">
<meta name="twitter:title" content="Cycling Companion - Planificateur bikepacking gratuit">
<meta name="twitter:description" content="Planifiez vos sorties vélo : traces GPX, profil d'élévation, waypoints et POI (eau, nourriture, hébergement) sur carte interactive.">
<meta name="twitter:image" content="https://blamouche.github.io/bikepacking-gpx-manager/img/twitter-card.png">
<meta name="twitter:image:alt" content="Carte cyclable avec trace GPX et points d'intérêt">

<!-- ==================== FAVICONS & ICÔNES ==================== -->

<!-- Favicons standards -->
<link rel="icon" type="image/png" sizes="16x16" href="/bikepacking-gpx-manager/img/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/bikepacking-gpx-manager/img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="/bikepacking-gpx-manager/img/icon-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/bikepacking-gpx-manager/img/icon-512x512.png">

<!-- Apple Touch Icon -->
<link rel="apple-touch-icon" sizes="180x180" href="/bikepacking-gpx-manager/img/apple-touch-icon.png">

<!-- Web App Manifest (PWA) -->
<link rel="manifest" href="/bikepacking-gpx-manager/site.webmanifest">

<!-- Microsoft Tiles -->
<meta name="msapplication-TileColor" content="#0066FF">
<meta name="msapplication-TileImage" content="/bikepacking-gpx-manager/img/icon-512x512.png">
<meta name="msapplication-config" content="/bikepacking-gpx-manager/browserconfig.xml">

<!-- Theme Color -->
<meta name="theme-color" content="#0066FF">

<!-- Apple Web App -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Cycling Companion">

<!-- Mobile Web App -->
<meta name="mobile-web-app-capable" content="yes">

<!-- ==================== PERFORMANCE & PRECONNECT ==================== -->

<!-- Preconnect pour les ressources externes -->
<link rel="preconnect" href="https://unpkg.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com">
<link rel="dns-prefetch" href="https://tile.openstreetmap.org">
<link rel="dns-prefetch" href="https://tile-cyclosm.openstreetmap.fr">
<link rel="dns-prefetch" href="https://overpass-api.de">

<!-- Preload des ressources critiques Leaflet -->
<link rel="preload" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" as="style">
<link rel="preload" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" as="script">

<!-- ==================== SCHEMA.ORG JSON-LD ==================== -->

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebApplication",
      "name": "Cycling Companion",
      "alternateName": "Bikepacking Helper",
      "url": "https://blamouche.github.io/bikepacking-gpx-manager/",
      "description": "Application web gratuite de planification d'itinéraires de bikepacking et cyclotourisme avec visualisation de traces GPX, profil d'élévation interactif, gestion de waypoints et recherche de points d'intérêt (eau potable, alimentation, hébergement, réparation vélo).",
      "applicationCategory": "LifestyleApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "EUR"
      },
      "featureList": [
        "Import et visualisation de traces GPX",
        "Profil d'élévation interactif avec statistiques (D+, D-, distance)",
        "Création et gestion de waypoints personnalisés",
        "Export GPX avec waypoints",
        "Recherche de points d'intérêt : eau potable, alimentation, hébergement, services vélo",
        "Fond de carte multiple : CyclOSM, OpenStreetMap, OpenTopoMap, satellite",
        "Génération de roadbook détaillé",
        "Géolocalisation en temps réel",
        "Sauvegarde automatique locale",
        "100% gratuit et sans publicité"
      ],
      "screenshot": "https://blamouche.github.io/bikepacking-gpx-manager/img/screenshot.png",
      "image": "https://blamouche.github.io/bikepacking-gpx-manager/img/logo.png",
      "author": {
        "@type": "Person",
        "name": "Benoit Lamouche",
        "url": "https://lamouche.fr",
        "sameAs": [
          "https://twitter.com/blamouche",
          "https://github.com/blamouche"
        ]
      },
      "inLanguage": "fr-FR",
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "softwareVersion": "1.0",
      "datePublished": "2025-01-15",
      "dateModified": "2025-01-15",
      "license": "https://opensource.org/licenses/MIT"
    },
    {
      "@type": "BreadcrumbList",
      "itemListElement": [
        {
          "@type": "ListItem",
          "position": 1,
          "name": "Accueil",
          "item": "https://blamouche.github.io/bikepacking-gpx-manager/"
        }
      ]
    },
    {
      "@type": "Organization",
      "name": "Cycling Companion",
      "url": "https://blamouche.github.io/bikepacking-gpx-manager/",
      "logo": "https://blamouche.github.io/bikepacking-gpx-manager/img/logo.png",
      "sameAs": [
        "https://twitter.com/blamouche",
        "https://github.com/blamouche",
        "https://lamouche.fr"
      ]
    },
    {
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "Cycling Companion est-il gratuit ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Oui, Cycling Companion est 100% gratuit et open source. Toutes les fonctionnalités sont accessibles sans inscription ni abonnement."
          }
        },
        {
          "@type": "Question",
          "name": "Quels formats de fichiers sont supportés ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "L'application supporte les fichiers GPX standard, contenant des traces (tracks), des routes ou des waypoints. Vous pouvez importer des fichiers créés avec n'importe quelle application de navigation GPS (Komoot, Strava, Garmin, Wahoo, etc.)."
          }
        },
        {
          "@type": "Question",
          "name": "Mes données sont-elles sauvegardées ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Oui, vos traces et waypoints sont automatiquement sauvegardés localement dans votre navigateur. Aucune donnée n'est envoyée à un serveur externe, garantissant votre confidentialité totale."
          }
        },
        {
          "@type": "Question",
          "name": "Quels types de points d'intérêt puis-je trouver ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "L'application vous permet de localiser : points d'eau potable, cimetières (source d'eau), supermarchés, épiceries, restaurants, cafés, stations de réparation vélo, magasins de vélo, campings, bivouacs, refuges, hôtels, auberges, toilettes publiques, douches, pharmacies et hôpitaux."
          }
        },
        {
          "@type": "Question",
          "name": "L'application fonctionne-t-elle hors ligne ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Une fois chargée, l'application peut fonctionner partiellement hors ligne avec vos traces déjà importées. Cependant, le chargement des cartes et la recherche de POI nécessitent une connexion internet."
          }
        },
        {
          "@type": "Question",
          "name": "Comment exporter mes traces avec les waypoints ?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Cliquez sur le bouton Exporter, choisissez d'inclure ou non vos waypoints, et téléchargez le fichier GPX. Votre trace enrichie sera compatible avec tous les GPS et applications de navigation."
          }
        }
      ]
    }
  ]
}
</script>
<!-- Leaflet CSS -->
<link crossorigin="" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" rel="stylesheet"/>
<style>
    :root {
      --color-primary: #1976d2;
      --color-primary-hover: #1565c0;
      --color-primary-light: rgba(25, 118, 210, 0.12);
      --color-secondary: #f5f5f5;
      --color-secondary-hover: #eeeeee;
      --color-danger: #f44336;
      --color-background: #ffffff;
      --color-background-alt: #f8f9fa;
      --color-text-primary: #212121;
      --color-text-secondary: #424242;
      --color-text-muted: #757575;
      --color-border: #e0e0e0;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--color-background-alt);
      color: var(--color-text-primary);
    }

    body {
      overflow: hidden;
    }

    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .hidden {
      display: none !important;
    }

    .tools-panel {
      width: 420px;
      min-width: 420px;
      height: 100vh;
      background: var(--color-background);
      border-right: 1px solid var(--color-border);
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .panel-header {
      padding: 1.5rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .panel-title {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem 1.5rem;
    }

    .panel-section {
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid var(--color-border);
    }

    .panel-section:last-child {
      border-bottom: none;
      padding-bottom: 0;
      margin-bottom: 0;
    }

    /* Calques POI */
    .layer-section {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .layer-global-actions {
      display: flex;
      gap: 0.5rem;
    }

    .layer-global-actions .btn {
      flex: 1;
    }

    .layer-presets {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      /* Espacement vertical : marge au-dessus et au-dessous du bloc */
      margin: 0.75rem 0;
    }

    .layer-presets label {
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .preset-select {
      flex: 1;
      padding: 0.45rem 0.6rem;
      border-radius: 6px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
      background: #fff;
    }

    .layer-group {
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: #fff;
      overflow: hidden;
      margin-bottom: 0.5rem;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
    }

    .layer-group-header {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem;
      background: var(--color-background-alt);
      border: none;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }

    .layer-group-header:hover {
      background: rgba(0, 0, 0, 0.03);
    }

    .layer-group-icon {
      font-size: 1.1rem;
    }

    .layer-group-label {
      flex: 1;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--color-text-primary);
      text-align: left;
    }

    .layer-group-count {
      font-size: 0.85rem;
      color: var(--color-text-muted);
    }

    .layer-group-chevron {
      font-size: 0.8rem;
      color: var(--color-text-muted);
      transition: transform 0.3s ease;
    }

    .layer-group.expanded .layer-group-chevron {
      transform: rotate(180deg);
    }

    .layer-group-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
      padding: 0 0.75rem;
    }

    .layer-group.expanded .layer-group-content {
      max-height: 1000px;
      padding: 0.75rem;
    }

    .layer-toggle {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
      user-select: none;
      padding: 0.4rem 0.25rem;
    }

    .layer-toggle + .layer-toggle {
      border-top: 1px dashed rgba(0, 0, 0, 0.05);
    }

    .toggle-input {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      background: #ccc;
      border-radius: 12px;
      transition: background 0.3s ease;
      flex-shrink: 0;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      top: 3px;
      left: 3px;
      transition: transform 0.3s ease;
    }

    .toggle-input:checked + .toggle-switch {
      background: var(--color-primary);
    }

    .toggle-input:checked + .toggle-switch::after {
      transform: translateX(20px);
    }

    .toggle-input:focus + .toggle-switch {
      outline: 2px solid var(--color-primary);
      outline-offset: 2px;
    }

    .toggle-text {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--color-text-primary);
      flex: 1;
    }

    .toggle-icon {
      font-size: 1.1rem;
    }

    .toggle-count {
      font-size: 0.85rem;
      color: var(--color-text-muted);
      font-weight: 600;
    }

    .layer-indicators {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .layer-loading,
    .layer-error,
    .layer-info {
      padding: 0.6rem 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      display: none;
    }

    .layer-loading {
      background: #e3f2fd;
      color: #1976d2;
      align-items: center;
      gap: 0.5rem;
    }

    .layer-error {
      background: #ffebee;
      color: #c62828;
      border: 1px solid rgba(198, 40, 40, 0.2);
    }

    .layer-info {
      background: #fff8e1;
      color: #f57f17;
      border: 1px solid rgba(245, 127, 23, 0.2);
    }

    .layer-loading .loading-spinner {
      display: inline-block;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .section-title {
      margin: 0 0 1rem 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 1.75rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: var(--color-primary);
      color: #fff;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      width: 100%;
      border: none;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      transition: box-shadow 0.2s ease, transform 0.1s ease;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    .btn-primary {
      background: var(--color-primary);
      color: #ffffff;
    }

    .btn-primary:not(:disabled):hover,
    .btn-primary:not(:disabled):focus {
      background: var(--color-primary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-secondary {
      background: var(--color-secondary);
      color: var(--color-text-secondary);
    }

    .btn-secondary:hover,
    .btn-secondary:focus {
      background: var(--color-secondary-hover);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-small {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
    }

    .btn-icon-small {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 1rem;
      padding: 0.25rem;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .btn-icon-small:hover,
    .btn-icon-small:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .section-title .section-icon {
      margin-right: 0.4rem;
      font-size: 1.1rem;
    }

    .gpx-section {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .gpx-empty-state,
    .gpx-loaded-state {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .gpx-loaded-state.dragover,
    .gpx-import-zone.dragover {
      box-shadow: 0 0 0 2px var(--color-primary-light, rgba(25, 118, 210, 0.2));
    }

    .gpx-import-zone {
      padding: 1.5rem;
      border: 2px dashed var(--color-border);
      border-radius: 12px;
      background: var(--color-background-alt);
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      color: var(--color-text-secondary);
    }

    .gpx-import-zone .gpx-import-icon {
      font-size: 1.75rem;
    }

    .gpx-import-zone .gpx-import-title {
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .gpx-import-zone .gpx-import-hint {
      font-size: 0.9rem;
      color: var(--color-text-muted);
    }

    .gpx-import-zone:hover,
    .gpx-import-zone:focus {
      border-color: var(--color-primary);
      background: rgba(25, 118, 210, 0.08);
      color: var(--color-text-primary);
    }

    .gpx-import-zone.dragover {
      border-color: var(--color-primary);
      background: var(--color-primary-light, rgba(25, 118, 210, 0.12));
      transform: scale(1.02);
      color: var(--color-text-primary);
    }

    .trace-summary {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      background: var(--color-background-alt);
      border: 1px solid var(--color-border);
      border-radius: 10px;
      padding: 0.75rem 1rem;
    }

    .trace-summary .trace-filename {
      font-weight: 600;
      color: var(--color-text-primary);
      word-break: break-word;
    }

    .trace-summary .trace-stats {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--color-text-muted);
      font-size: 0.875rem;
    }

    .trace-summary .trace-stats .icon {
      font-size: 1rem;
    }

    .gpx-actions {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.375rem;
    }

    .gpx-action-btn {
      padding: 0.5rem 0.375rem;
      font-size: 0.8125rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.125rem;
      border: 1px solid var(--color-border);
      border-radius: 10px;
      background: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .gpx-action-btn:hover,
    .gpx-action-btn:focus {
      border-color: var(--color-primary);
      color: var(--color-primary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }

    .gpx-action-btn .icon {
      font-size: 1.125rem;
      line-height: 1;
    }

    .gpx-action-btn .label {
      font-size: 0.75rem;
      line-height: 1;
    }

    .gpx-action-btn--danger {
      border-color: rgba(244, 67, 54, 0.35);
      color: var(--color-danger);
    }

    .gpx-action-btn--danger:hover,
    .gpx-action-btn--danger:focus {
      border-color: var(--color-danger);
      color: var(--color-danger);
      box-shadow: 0 2px 4px rgba(244, 67, 54, 0.15);
    }

    .gpx-action-btn.is-confirm {
      border-color: var(--color-danger);
      background: rgba(244, 67, 54, 0.08);
      color: var(--color-danger);
      box-shadow: 0 2px 6px rgba(244, 67, 54, 0.2);
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(33, 33, 33, 0.4);
      backdrop-filter: blur(2px);
      z-index: 1000;
    }

    .export-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--color-background);
      border-radius: 14px;
      box-shadow: var(--shadow-md);
      width: min(420px, 90vw);
      z-index: 1001;
      display: flex;
      flex-direction: column;
      max-height: 90vh;
    }

    .export-modal.hidden,
    .modal-backdrop.hidden {
      display: none;
    }

    .export-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--color-border);
    }

    .export-modal-header h4 {
      margin: 0;
      font-size: 1.05rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .export-modal-content {
      padding: 1rem 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow-y: auto;
    }

    .export-modal-content label {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .export-modal-content input[type="text"] {
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .checkbox-label input {
      width: 1.1rem;
      height: 1.1rem;
    }

    .export-preview {
      padding: 0.75rem;
      border-radius: 8px;
      background: var(--color-background-alt);
      border: 1px dashed var(--color-border);
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .export-modal-actions {
      padding: 0.9rem 1.25rem;
      border-top: 1px solid var(--color-border);
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    @media (max-width: 600px) {
      .gpx-actions {
        grid-template-columns: repeat(2, 1fr);
      }

      .gpx-action-btn--export {
        grid-column: 1 / -1;
      }
    }

    @media (max-width: 480px) {
      .export-modal {
        inset: auto 0 0 0;
        transform: none;
        margin: 0.75rem;
        width: auto;
      }
    }

    .waypoints-list {
      max-height: 240px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .waypoint-item {
      display: grid;
      grid-template-columns: auto 1fr auto auto;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.6rem;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: #fff;
      box-shadow: var(--shadow-sm);
    }

    .waypoint-popup {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 200px;
    }

    .waypoint-popup label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--color-text-secondary);
    }

    .waypoint-popup input {
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: 1px solid var(--color-border);
      font-size: 0.95rem;
    }

    .waypoint-popup-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .waypoint-popup-buttons button {
      flex: 1;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: var(--color-secondary);
    }

    .waypoint-popup-buttons button[data-action="save"] {
      background: var(--color-primary);
      color: #fff;
    }

    .waypoint-popup-buttons button[data-action="delete"] {
      background: var(--color-danger);
      color: #fff;
    }

    .waypoint-name {
      font-size: 0.95rem;
      color: var(--color-text-primary);
    }

    .waypoint-icon {
      font-size: 1.1rem;
    }

    .info-list {
      margin: 0;
      display: grid;
      grid-template-columns: auto 1fr;
      row-gap: 0.75rem;
      column-gap: 1rem;
      font-size: 0.95rem;
    }

    .info-list dt {
      font-weight: 600;
      color: var(--color-text-secondary);
    }

    .info-list dd {
      margin: 0;
      color: var(--color-text-primary);
    }

    .mini-elevation-profile {
      margin-top: 1rem;
      padding: 0.75rem;
      background: var(--color-background-alt);
      border: 1px solid var(--color-border-light);
      border-radius: var(--radius-md);
    }

    .mini-profile-title {
      margin: 0 0 0.5rem 0;
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--color-text-secondary);
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    .mini-profile-canvas-wrapper {
      position: relative;
      width: 100%;
      height: 120px;
      background: var(--color-background);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    #mini-elevation-canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: default;
    }

    @media (max-width: 767px) {
      .mini-profile-canvas-wrapper {
        height: 100px;
      }
    }

    .text-muted {
      color: var(--color-text-muted);
    }

    .trace-name {
      font-weight: 600;
      font-size: 1rem;
      word-break: break-word;
    }

    .trace-name--gpx-track,
    .trace-name--gpx-route,
    .trace-name--gpx-metadata {
      color: var(--color-primary);
    }

    .trace-name--filename {
      color: var(--color-text-muted);
      font-style: italic;
    }

    .trace-name--default {
      color: #9e9e9e;
      font-style: italic;
    }

    .file-name {
      font-family: "Courier New", Courier, monospace;
      font-size: 0.9rem;
      color: var(--color-text-muted);
      word-break: break-all;
    }

    .trace-name-help {
      font-size: 1rem;
      cursor: help;
      color: var(--color-text-muted);
      display: inline-block;
      margin-left: 0.35rem;
    }

    .stat-highlight {
      font-weight: 600;
      color: var(--color-primary);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .elevation-profile {
      position: relative;
      width: 100%;
      background: var(--color-background);
      border-top: 2px solid var(--color-primary);
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
      display: none;
      flex-direction: column;
      z-index: 500;
      transition: height 0.3s ease;
      height: 200px;
    }

    .elevation-profile.visible {
      display: flex;
    }

    .elevation-profile.collapsed {
      height: 40px;
    }

    .elevation-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.75rem 1rem;
      background: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
      cursor: pointer;
      user-select: none;
      min-height: 40px;
    }

    .elevation-header:hover {
      background: rgba(0, 0, 0, 0.02);
    }

    .elevation-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .elevation-title h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .elevation-icon {
      font-size: 1.25rem;
    }

    .elevation-stats-quick {
      display: flex;
      gap: 1.5rem;
      flex: 1;
      justify-content: center;
    }

    .stat-item {
      display: flex;
      gap: 0.25rem;
      font-size: 0.9rem;
    }

    .stat-label {
      color: var(--color-text-muted);
    }

    .stat-value {
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .btn-collapse {
      border: none;
      background: transparent;
      font-size: 1rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .btn-collapse:hover,
    .btn-collapse:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .elevation-profile.collapsed .btn-collapse span {
      transform: rotate(180deg);
      display: inline-block;
    }

    .elevation-content {
      flex: 1;
      position: relative;
      overflow: hidden;
      padding: 1rem;
      display: none;
    }

    .elevation-profile:not(.collapsed) .elevation-content {
      display: block;
    }

    #elevation-canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .elevation-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .tooltip-row {
      display: flex;
      gap: 0.5rem;
      white-space: nowrap;
    }

    /* Marqueurs POI OSM */
    .poi-marker {
      border: none !important;
      background: transparent !important;
    }

    .poi-marker-inner {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      border: 2px solid #fff;
      transition: transform 0.2s ease;
    }

    .poi-marker:hover .poi-marker-inner {
      transform: scale(1.15);
    }

    .poi-marker-icon {
      font-size: 14px;
      line-height: 1;
      filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
    }

    .poi-popup-container .leaflet-popup-content-wrapper {
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .poi-popup {
      font-family: inherit;
      min-width: 220px;
    }

    .poi-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--color-border);
      margin-bottom: 0.75rem;
    }

    .poi-header .poi-icon {
      font-size: 1.5rem;
    }

    .poi-name {
      font-size: 1rem;
      color: var(--color-text-primary);
    }

    .poi-details {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .poi-row {
      display: flex;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .poi-label {
      color: var(--color-text-muted);
      min-width: 70px;
    }

    .poi-value {
      color: var(--color-text-primary);
      font-weight: 500;
    }

    .poi-footer {
      padding-top: 0.5rem;
      border-top: 1px solid var(--color-border);
    }

    .poi-footer a {
      color: var(--color-primary);
      text-decoration: none;
      font-size: 0.85rem;
    }

    .poi-footer a:hover {
      text-decoration: underline;
    }

    .tooltip-label {
      color: rgba(255, 255, 255, 0.7);
    }

    .tooltip-value {
      font-weight: 600;
    }

    @media (max-width: 767px) {
      .layer-global-actions {
        flex-direction: column;
      }

      .layer-presets {
        flex-direction: column;
        align-items: stretch;
        gap: 0.35rem;
      }

      .layer-presets label {
        font-size: 0.85rem;
      }

      .elevation-profile {
        height: 150px;
      }

      .elevation-stats-quick {
        display: none;
      }

      .elevation-header {
        padding: 0.5rem 0.75rem;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .elevation-stats-quick {
        gap: 1rem;
        font-size: 0.85rem;
      }
    }

    .panel-messages {
      padding: 0;
    }

    .message {
      min-height: 3rem;
      padding: 0.75rem 1rem;
      border-radius: 6px;
      border: 1px solid transparent;
      background: #f1f8ff;
      color: #0d47a1;
    }

    .message.hidden {
      display: none;
    }

    .message.error {
      background: #ffebee;
      border-color: rgba(244, 67, 54, 0.3);
      color: #c62828;
    }

    .map-container {
      flex: 1;
      position: relative;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .map-main {
      position: relative;
      flex: 1;
      min-height: 0;
    }

    .poi-refresh-button {
      position: fixed;
      z-index: 900;
      display: none;
      align-items: center;
      gap: 0.4rem;
      padding: 0.6rem 0.85rem;
      background: rgba(25, 118, 210, 0.95);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      box-shadow: var(--shadow-md);
      cursor: pointer;
      transition: background 0.2s ease, transform 0.1s ease;
      top: 90% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: min(90vw, 1000px);}


    .poi-refresh-button:hover,
    .poi-refresh-button:focus {
      background: rgba(21, 101, 192, 0.95);
      transform: translateX(-50%) translateY(-1px);
      outline: none;
    }

    .poi-refresh-button span {
      /*display: inline-flex;*/
      display:block;
      align-items: center;
      justify-content: center;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .btn-menu {
      display: none;
      position: absolute;
      top: 1rem;
      left: 1rem;
      z-index: 1000;
      background: #fff;
      border: 2px solid var(--color-border);
      border-radius: 6px;
      padding: 0.6rem 0.8rem;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: var(--shadow-md);
    }

    .btn-close-panel {
      border: none;
      background: transparent;
      font-size: 1.25rem;
      cursor: pointer;
      border-radius: 4px;
      padding: 0.2rem 0.4rem;
    }

    .btn-close-panel:hover,
    .btn-close-panel:focus {
      background: rgba(0, 0, 0, 0.05);
    }

    .panel-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      z-index: 1500;
      opacity: 0;
      animation: fadeIn 0.2s forwards;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    @media (max-width: 767px) {
      .tools-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 90vw;
        max-width: 420px;
        z-index: 2000;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }

      .tools-panel.open {
        transform: translateX(0);
      }

      .btn-menu {
        display: block;
      }
    }

    @media (min-width: 768px) {
      .btn-close-panel {
        display: none;
      }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .tools-panel {
        width: 280px;
        min-width: 280px;
      }
    }
  
/* === Layer indicators overrides merged === */

/* === Waypoint Markers === */
.waypoint-marker {
  border: none !important;
  background: transparent !important;
}

.waypoint-marker-inner {
  width: 28px;
  height: 36px;
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
  filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
}

.waypoint-marker-pin {
  width: 28px;
  height: 28px;
  background: #FF5722;
  border-radius: 50% 50% 50% 0;
  transform: rotate(-45deg);
  border: 3px solid #FFFFFF;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.waypoint-marker-icon {
  transform: rotate(45deg);
  font-size: 14px;
  line-height: 1;
}

.waypoint-marker:hover .waypoint-marker-inner {
  transform: scale(1.15) translateY(-3px);
  filter: drop-shadow(0 6px 12px rgba(255, 87, 34, 0.5));
}

@keyframes waypointAppear {
  from { opacity: 0; transform: scale(0.3) translateY(10px); }
  to   { opacity: 1; transform: scale(1) translateY(0); }
}

.waypoint-marker-inner {
  animation: waypointAppear 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}



/* === Mini-cartes d'aperçu pour styles === */
.map-style-section .map-style-options {
  display: grid;
  grid-template-columns: 1fr;
  gap: 0.5rem;
}
.map-style-section .map-style-option {
  display: grid;
  grid-template-columns: 120px 1fr;
  align-items: center;
  column-gap: 0.75rem;
  padding: 0.5rem;
}
.map-style-thumb {
  width: 120px;
  height: 80px;
  border-radius: var(--radius-md, 8px);
  overflow: hidden;
  border: 1px solid var(--color-border-light, #E5E5EA);
  box-shadow: var(--shadow-sm, 0 1px 2px rgba(0,0,0,0.04));
}
.map-style-thumb-inner {
  width: 100%;
  height: 100%;
  pointer-events: none; /* clics passent au bouton */
}
.map-style-label-text {
  font-size: 0.9rem;
  font-weight: 500;
}
.map-style-option.active .map-style-thumb {
  outline: 2px solid var(--color-primary, #0066FF);
  outline-offset: -2px;
}
@media (max-width: 480px) {
  .map-style-section .map-style-option {
    grid-template-columns: 100px 1fr;
  }
  .map-style-thumb { width: 100px; height: 66px; }
}


/* === Vignettes pleine largeur & responsives === */
.map-style-section .map-style-options {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.map-style-section .map-style-option {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 0.5rem;
  padding: 0.5rem;
}
.map-style-thumb {
  width: 100%;
  height: 160px;
  border-radius: var(--radius-md, 8px);
  overflow: hidden;
  border: 1px solid var(--color-border-light, #E5E5EA);
  box-shadow: var(--shadow-sm, 0 1px 2px rgba(0,0,0,0.04));
}
.map-style-thumb-inner {
  width: 100%;
  height: 100%;
  pointer-events: none;
}
@media (min-width: 1024px) {
  .map-style-thumb { height: 180px; }
}
@media (max-width: 480px) {
  .map-style-thumb { height: 140px; }
}


/* === Map Style Options: Look & Feel aligned with app === */
.map-style-section .map-style-option {
  position: relative;
  background: var(--color-background-elevated, #FFFFFF);
  border: 1px solid var(--color-border-light, #F2F2F7);
  border-radius: var(--radius-lg, 12px);
  padding: 0.625rem;
  box-shadow: var(--shadow-sm, 0 1px 2px rgba(0,0,0,0.04));
  transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease, background 0.2s ease;
}

.map-style-section .map-style-option:hover {
  transform: translateY(-1px);
  box-shadow: var(--shadow-md, 0 4px 12px rgba(0,0,0,0.08));
  border-color: var(--color-border, #E5E5EA);
  background: var(--color-background, #FFFFFF);
}

.map-style-section .map-style-option:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm, 0 1px 2px rgba(0,0,0,0.04));
}

.map-style-section .map-style-option:focus-visible {
  outline: 2px solid var(--color-primary, #0066FF);
  outline-offset: 2px;
}

/* label zone */
.map-style-section .map-style-label-text {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 0.93rem;
  font-weight: 600;
  color: var(--color-text-primary, #1A1A1A);
}

/* Tag "par défaut" sur Voyager */
#map-style-section .map-style-option[data-style="voyager"] .map-style-label-text::after {
  content: "Par défaut";
  font-size: 0.75rem;
  font-weight: 700;
  color: var(--color-primary, #0066FF);
  background: var(--color-primary-light, #E6F0FF);
  padding: 0.125rem 0.5rem;
  border-radius: 999px;
  border: 1px solid rgba(0,102,255,0.25);
}

/* Active card state: subtle elevation + border accent + thumb outline already present */
.map-style-section .map-style-option.active {
  border-color: rgba(0, 102, 255, 0.35);
  box-shadow: 0 6px 16px rgba(0, 102, 255, 0.12);
  background: linear-gradient(0deg, rgba(0,102,255,0.022), rgba(0,102,255,0.022)), var(--color-background-elevated, #FFFFFF);
}

.map-style-section .map-style-option.active .map-style-label-text {
  color: var(--color-primary, #0066FF);
}

/* Thumb polish */
.map-style-thumb {
  border-radius: var(--radius-md, 8px);
  overflow: hidden;
  border: 1px solid var(--color-border-light, #E5E5EA);
  background: var(--color-background, #FFFFFF);
}

.map-style-option.active .map-style-thumb {
  border-color: rgba(0, 102, 255, 0.35);
  box-shadow: 0 2px 10px rgba(0,102,255,0.15);
}

/* Small "chevron" affordance */
.map-style-section .map-style-option::after {
  content: "›";
  position: absolute;
  right: 0.75rem;
  bottom: 0.5rem;
  font-size: 1rem;
  color: var(--color-text-muted, #8E8E93);
  opacity: 0.6;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

.map-style-section .map-style-option:hover::after {
  transform: translateX(2px);
  opacity: 0.9;
}

/* Compact spacing on narrow screens */
@media (max-width: 480px) {
  .map-style-section .map-style-option {
    padding: 0.5rem;
    border-radius: var(--radius-md, 8px);
  }
  .map-style-section .map-style-label-text {
    font-size: 0.9rem;
  }
}

/* Dark mode refinement */
/*
@media (prefers-color-scheme: dark) {
  .map-style-section .map-style-option {
    background: rgba(44,44,46,0.9);
    border-color: rgba(255,255,255,0.08);
    box-shadow: none;
  }
  .map-style-section .map-style-option:hover {
    background: rgba(44,44,46,1);
    border-color: rgba(255,255,255,0.14);
    box-shadow: 0 6px 16px rgba(0,0,0,0.45);
  }
  .map-style-section .map-style-option.active {
    border-color: rgba(10,132,255,0.45);
    background: linear-gradient(0deg, rgba(10,132,255,0.08), rgba(10,132,255,0.08)), rgba(44,44,46,1);
    box-shadow: 0 8px 20px rgba(10,132,255,0.25);
  }
  .map-style-section .map-style-option::after {
    color: rgba(235,235,245,0.6);
  }
  #map-style-section .map-style-option[data-style="voyager"] .map-style-label-text::after {
    color: #0A84FF;
    background: rgba(10,132,255,0.15);
    border-color: rgba(10,132,255,0.35);
  }
}
*/

</style>
<style>
/* ==================== DESIGN MODERNE - VARIABLES AMÉLIORÉES ==================== */
:root {
  --color-geo: #2196F3;
  --color-trace: #FF6B35;
  --color-map: #4CAF50;
  --color-poi: #9C27B0;
  --color-waypoint: #E91E63;
  --color-roadbook: #1565C0;
  --color-primary: #0066FF;
  --color-primary-hover: #0052CC;
  --color-primary-light: #E3F2FD;
  --color-background: #FFFFFF;
  --color-background-alt: #F5F7FA;
  --color-background-elevated: #FFFFFF;
  --color-surface: #FAFBFC;
  --color-text-primary: #1A202C;
  --color-text-secondary: #4A5568;
  --color-text-muted: #718096;
  --color-border: #E2E8F0;
  --color-border-light: #EDF2F7;
  --shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-sm: 0 2px 4px 0 rgba(0, 0, 0, 0.06);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.08);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 0.75rem;
  --spacing-lg: 1rem;
  --spacing-xl: 1.5rem;
  --spacing-2xl: 2rem;
  --radius-sm: 6px;
  --radius-md: 10px;
  --radius-lg: 14px;
  --radius-xl: 18px;
}

.tools-panel {
  background: linear-gradient(to bottom, #FFFFFF 0%, #FAFBFC 100%);
  border-right: 1px solid var(--color-border-light);
  box-shadow: 2px 0 12px rgba(0, 0, 0, 0.04);
}

.panel-header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 1.5rem;
  border-bottom: none;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
}

.panel-title {
  color: white;
  font-size: 1.5rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.panel-title::before {
  content: "🧰";
  font-size: 1.75rem;
  line-height: 1;
}

.btn-close-panel {
  color: rgba(255, 255, 255, 0.9);
  font-size: 1.5rem;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.btn-close-panel:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: rotate(90deg);
}

.panel-content {
  padding: 1rem;
  background: transparent;
}

.panel-section {
  background: var(--color-background);
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-lg);
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-sm);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
  animation: fadeIn 0.3s ease-out;
}

.panel-section::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  transition: width 0.3s ease;
}

.panel-section:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.panel-section:hover::before {
  width: 6px;
}

#geolocation-section::before {
  background: linear-gradient(to bottom, var(--color-geo), #1976D2);
}

.gpx-section::before {
  background: linear-gradient(to bottom, var(--color-trace), #E64A19);
}

#map-style-section::before {
  background: linear-gradient(to bottom, var(--color-map), #388E3C);
}

#layers-section::before {
  background: linear-gradient(to bottom, var(--color-poi), #7B1FA2);
}

#waypoints-section::before {
  background: linear-gradient(to bottom, var(--color-waypoint), #C2185B);
}

#roadbook-section::before {
  background: linear-gradient(to bottom, var(--color-roadbook), #0D47A1);
}

#trace-info-section::before {
  background: linear-gradient(to bottom, #FF9800, #F57C00);
}

.section-title {
  font-size: 0.875rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--color-text-primary);
  margin: 0 0 1rem 0;
  display: flex;
  align-items: center;
  gap: 0.625rem;
  padding-bottom: 0.75rem;
  border-bottom: 2px solid var(--color-border-light);
}

.section-title .section-icon {
  font-size: 1.25rem;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
}

#geolocation-section .section-title { color: var(--color-geo); }
.gpx-section .section-title { color: var(--color-trace); }
#map-style-section .section-title { color: var(--color-map); }
#layers-section .section-title { color: var(--color-poi); }
#waypoints-section .section-title { color: var(--color-waypoint); }
#roadbook-section .section-title { color: var(--color-roadbook); }
#trace-info-section .section-title { color: #FF9800; }

.btn {
  border-radius: var(--radius-md);
  font-weight: 600;
  font-size: 0.9rem;
  padding: 0.75rem 1.25rem;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  border: none;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  position: relative;
  overflow: hidden;
}

.btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
  transform: translateX(-100%);
  transition: transform 0.6s;
}

.btn:hover::before {
  transform: translateX(100%);
}

.btn-primary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.btn-primary:hover {
  box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
  transform: translateY(-2px);
}

.btn-secondary {
  background: var(--color-background-alt);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
}

.btn-secondary:hover {
  background: var(--color-background);
  border-color: var(--color-primary);
  color: var(--color-primary);
  box-shadow: var(--shadow-sm);
}

.badge {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 0.25rem 0.625rem;
  border-radius: 999px;
  font-size: 0.75rem;
  font-weight: 700;
  box-shadow: 0 2px 4px rgba(102, 126, 234, 0.2);
  min-width: 1.5rem;
  text-align: center;
}

.gpx-import-zone {
  background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
  border: 2px dashed var(--color-border);
  border-radius: var(--radius-xl);
  padding: 2rem 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.gpx-import-zone:hover {
  background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
  border-color: var(--color-primary);
  transform: scale(1.02);
  box-shadow: var(--shadow-lg);
}

.gpx-import-icon {
  font-size: 3rem;
  margin-bottom: 0.5rem;
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
}

.gpx-import-title {
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--color-text-primary);
  margin-bottom: 0.25rem;
}

.gpx-import-hint {
  font-size: 0.875rem;
  color: var(--color-text-muted);
}

.layer-group {
  background: var(--color-surface);
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-md);
  margin-bottom: 0.75rem;
  overflow: hidden;
  transition: all 0.2s ease;
}

.layer-group:hover {
  box-shadow: var(--shadow-sm);
}

.layer-group-header {
  background: linear-gradient(to right, rgba(102, 126, 234, 0.05), transparent);
  padding: 0.875rem 1rem;
  border-bottom: 1px solid transparent;
  transition: all 0.2s ease;
}

.layer-group-header:hover {
  background: linear-gradient(to right, rgba(102, 126, 234, 0.1), transparent);
}

.layer-group.expanded .layer-group-header {
  border-bottom-color: var(--color-border-light);
}

.layer-group-label {
  font-weight: 600;
  font-size: 0.95rem;
  color: var(--color-text-primary);
}

.toggle-switch {
  width: 46px;
  height: 26px;
  background: #CBD5E0;
  border-radius: 13px;
  position: relative;
  transition: background 0.3s ease;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.toggle-switch::after {
  content: '';
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: white;
  top: 3px;
  left: 3px;
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.toggle-input:checked + .toggle-switch {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.toggle-input:checked + .toggle-switch::after {
  transform: translateX(20px);
}

.info-list {
  background: var(--color-surface);
  border-radius: var(--radius-md);
  padding: 1rem;
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 0.75rem 1rem;
}

.info-list dt {
  font-weight: 600;
  color: var(--color-text-secondary);
  font-size: 0.875rem;
}

.info-list dd {
  color: var(--color-text-primary);
  font-weight: 500;
}

.waypoint-item {
  background: white;
  border: 1px solid var(--color-border-light);
  border-left: 3px solid var(--color-waypoint);
  border-radius: var(--radius-md);
  padding: 0.75rem;
  display: grid;
  grid-template-columns: auto 1fr auto auto;
  align-items: center;
  gap: 0.75rem;
  transition: all 0.2s ease;
}

.waypoint-icon {
  font-size: 1.5rem;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
}

.elevation-profile {
  background: white;
  border-top: 3px solid var(--color-primary);
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.08);
}

.elevation-header {
  background: linear-gradient(to right, rgba(102, 126, 234, 0.05), transparent);
  border-bottom: 1px solid var(--color-border-light);
  padding: 1rem 1.5rem;
}

.elevation-title h3 {
  font-weight: 600;
  color: var(--color-text-primary);
}

.roadbook-step {
  background: white;
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-lg);
  padding: 1rem;
  box-shadow: var(--shadow-xs);
  transition: all 0.2s ease;
}

.roadbook-step:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

.roadbook-step[data-type="start"] {
  border-left: 4px solid #4CAF50;
  background: linear-gradient(to right, rgba(76, 175, 80, 0.05), white);
}

.roadbook-step[data-type="waypoint"] {
  border-left: 4px solid var(--color-waypoint);
}

.roadbook-step[data-type="end"] {
  border-left: 4px solid #FF5722;
  background: linear-gradient(to right, rgba(255, 87, 34, 0.05), white);
}

.panel-footer {
  margin-top: auto;
  padding: 1rem 1.5rem;
  border-top: 1px solid var(--color-border-light);
  background: var(--color-background);
  color: var(--color-text-muted);
  font-size: 0.85rem;
  line-height: 1.5;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.panel-footer a {
  color: var(--color-primary);
  font-weight: 600;
  text-decoration: none;
}

.panel-footer-links {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.25rem;
}

.panel-footer-separator {
  color: var(--color-border);
  font-weight: 600;
}
.panel-footer a:hover {
  text-decoration: underline;
}

.panel-version {
  font-weight: 600;
  color: var(--color-text-secondary);
}

@media (max-width: 767px) {
  .panel-header {
    padding: 1.25rem;
  }

  .panel-title {
    font-size: 1.25rem;
  }

  .panel-section {
    padding: 1rem;
    border-radius: var(--radius-md);
  }

  .section-title {
    font-size: 0.8125rem;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.panel-content::-webkit-scrollbar {
  width: 8px;
}

.panel-content::-webkit-scrollbar-track {
  background: var(--color-background-alt);
  border-radius: 4px;
}

.panel-content::-webkit-scrollbar-thumb {
  background: linear-gradient(to bottom, #667eea, #764ba2);
  border-radius: 4px;
}

.panel-content::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(to bottom, #5568d3, #653b8b);
}
</style>
<!-- Modern Compact UI Overrides -->
<style>
:root {
  /* Couleurs primaires - Bleu moderne plus saturé */
  --color-primary: #0066FF;
  --color-primary-hover: #0052CC;
  --color-primary-light: #E6F0FF;
  
  /* Couleurs secondaires - Gris modernes */
  --color-secondary: #F7F8FA;
  --color-secondary-hover: #E8EAED;
  
  /* Couleurs de danger */
  --color-danger: #FF3B30;
  --color-danger-hover: #E62E24;
  
  /* Backgrounds */
  --color-background: #FFFFFF;
  --color-background-alt: #FAFBFC;
  --color-background-elevated: #FFFFFF;
  
  /* Textes */
  --color-text-primary: #1A1A1A;
  --color-text-secondary: #4A4A4A;
  --color-text-muted: #8E8E93;
  
  /* Bordures */
  --color-border: #E5E5EA;
  --color-border-light: #F2F2F7;
  
  /* Ombres modernisées */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
  
  /* Bordures arrondies plus subtiles */
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;
  
  /* Espacements compacts */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 0.75rem;
  --spacing-lg: 1rem;
  --spacing-xl: 1.5rem;
}

/* 2. Typographie modernisée */
html, body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  font-size: 14px;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.panel-title {
  font-size: 1.25rem;
  font-weight: 700;
  letter-spacing: -0.02em;
}

.section-title {
  font-size: 0.95rem;
  font-weight: 600;
  letter-spacing: -0.01em;
  text-transform: uppercase;
  color: var(--color-text-muted);
}

/* 3. Panneau latéral compact */
.panel-header {
  padding: 1rem 1.25rem;
  background: var(--color-background);
  border-bottom: 1px solid var(--color-border-light);
  backdrop-filter: blur(10px);
}

.panel-content {
  padding: 0.75rem 1rem;
}

.panel-section {
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--color-border-light);
}

.tools-panel {
  width: 280px;
  min-width: 280px;
}

@media (min-width: 768px) and (max-width: 1023px) {
  .tools-panel {
    width: 260px;
    min-width: 260px;
  }
}

/* 4. Boutons modernisés */
.btn {
  padding: 0.625rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  border-radius: var(--radius-md);
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  border: none;
  cursor: pointer;
}

.btn:not(:disabled):active {
  transform: scale(0.98);
}

.btn-primary {
  background: var(--color-primary);
  color: #FFFFFF;
  box-shadow: 0 1px 3px rgba(0, 102, 255, 0.2);
}

.btn-primary:not(:disabled):hover {
  background: var(--color-primary-hover);
  box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
  transform: translateY(-1px);
}

.btn-secondary {
  background: var(--color-secondary);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
}

.btn-small {
  padding: 0.375rem 0.75rem;
  font-size: 0.8125rem;
}

/* 5. Cartes et conteneurs modernisés */
.layer-group {
  border: 1px solid var(--color-border-light);
  border-radius: var(--radius-md);
  background: var(--color-background-elevated);
  overflow: hidden;
  margin-bottom: 0.5rem;
  box-shadow: var(--shadow-sm);
  transition: all 0.2s ease;
}

.layer-group:hover {
  box-shadow: var(--shadow-md);
}

.layer-group-header {
  padding: 0.625rem 0.75rem;
  background: var(--color-background-alt);
  border: none;
  transition: background 0.15s ease;
}

.layer-group-content {
  padding: 0 0.75rem;
}

.layer-group.expanded .layer-group-content {
  padding: 0.625rem 0.75rem;
}

/* File info modernisé */
.file-info {
  margin-top: 0.75rem;
  padding: 0.75rem;
  border-radius: var(--radius-md);
  background: var(--color-background-alt);
  border: 1px solid var(--color-border-light);
}

/* 6. Toggles et contrôles modernisés */
.toggle-switch {
  width: 40px;
  height: 22px;
  border-radius: 11px;
  background: #E5E5EA;
}

.toggle-switch::after {
  width: 16px;
  height: 16px;
  top: 3px;
  left: 3px;
}

.toggle-input:checked + .toggle-switch::after {
  transform: translateX(18px);
}

.layer-toggle {
  padding: 0.375rem 0.25rem;
  gap: 0.625rem;
}

.toggle-text {
  font-size: 0.875rem;
}

.toggle-icon {
  font-size: 1rem;
}

/* 7. Waypoints et listes compactes */
.waypoints-list {
  max-height: 200px;
  gap: 0.375rem;
}

.waypoint-item {
  padding: 0.5rem;
  gap: 0.5rem;
  border-radius: var(--radius-md);
  background: var(--color-background-elevated);
  border: 1px solid var(--color-border-light);
}

/* 8. Info-list modernisée */
.info-list {
  grid-template-columns: auto 1fr;
  row-gap: 0.625rem;
  column-gap: 0.75rem;
  font-size: 0.875rem;
}

.info-list dt {
  font-weight: 600;
  font-size: 0.8125rem;
  color: var(--color-text-muted);
}

/* 9. Badge modernisé */
.badge {
  min-width: 1.5rem;
  padding: 0.125rem 0.375rem;
  border-radius: 999px;
  background: var(--color-primary);
  color: #FFFFFF;
  font-size: 0.75rem;
  font-weight: 600;
  box-shadow: 0 1px 3px rgba(0, 102, 255, 0.2);
}

/* 10. Profil d'élévation compact */
.elevation-profile {
  height: 180px;
}

.elevation-header {
  padding: 0.625rem 1rem;
  min-height: 36px;
}

.elevation-title h3 {
  font-size: 0.9375rem;
  font-weight: 600;
}

.elevation-stats-quick {
  gap: 1.25rem;
}

.stat-item {
  font-size: 0.8125rem;
}

@media (max-width: 767px) {
  .elevation-profile {
    height: 140px;
  }
}

/* 11. Bouton POI refresh modernisé */
.poi-refresh-button {
  left: 50%;
  top:5rem;
  transform: translateX(-50%);
  padding: 0.5rem 0.875rem;
  background: rgba(0, 102, 255, 0.95);
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
  backdrop-filter: blur(10px);
}

.poi-refresh-button:hover {
  background: rgba(0, 82, 204, 0.95);
  transform: translateX(-50%) translateY(-2px);
  box-shadow: 0 6px 16px rgba(0, 102, 255, 0.4);
}

/* 12. Indicateurs et messages compacts */
.layer-loading,
.layer-error,
.layer-info {
  padding: 0.5rem 0.625rem;
  border-radius: var(--radius-md);
  font-size: 0.8125rem;
}

.layer-loading {
  background: var(--color-primary-light);
  color: var(--color-primary);
}

.message {
  min-height: 2.5rem;
  padding: 0.625rem 0.875rem;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
}

/* 13. Drop zone modernisée */
.drop-zone {
  margin-top: 0.75rem;
  padding: 1rem;
  border: 2px dashed var(--color-border);
  border-radius: var(--radius-lg);
  background: var(--color-background-alt);
  transition: all 0.2s ease;
}

.drop-zone.dragover {
  border-color: var(--color-primary);
  background: var(--color-primary-light);
  transform: scale(1.01);
}

/* 14. Popups POI modernisés */
.poi-popup-container .leaflet-popup-content-wrapper {
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  padding: 0;
}

.poi-popup {
  font-size: 0.875rem;
  min-width: 200px;
}

.poi-header {
  padding-bottom: 0.625rem;
  margin-bottom: 0.625rem;
}

.poi-details {
  gap: 0.375rem;
  margin-bottom: 0.625rem;
}

.poi-row {
  font-size: 0.8125rem;
}

/* 15. Animations fluides */
* {
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

.layer-group,
.waypoint-item,
.poi-marker {
  animation: fadeIn 0.2s ease-out;
}

/* 16. Scrollbars modernisées */
.panel-content::-webkit-scrollbar,
.waypoints-list::-webkit-scrollbar {
  width: 6px;
}

.panel-content::-webkit-scrollbar-track,
.waypoints-list::-webkit-scrollbar-track {
  background: transparent;
}

.panel-content::-webkit-scrollbar-thumb,
.waypoints-list::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: 3px;
}

.panel-content::-webkit-scrollbar-thumb:hover,
.waypoints-list::-webkit-scrollbar-thumb:hover {
  background: var(--color-text-muted);
}
</style>
<style>
/* === Collapsible Sections === */
.collapsible-section {
  position: relative;
}

.collapsible-section .section-header-with-action {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.collapsible-section .section-header-with-action .section-header-toggle {
  flex: 1;
}

.collapsible-section .section-header-toggle {
  width: 100%;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 0;
  background: transparent;
  border: none;
  cursor: pointer;
  user-select: none;
  transition: background 0.2s ease;
  text-align: left;
}

.collapsible-section .section-header-toggle:hover {
  background: rgba(0, 0, 0, 0.02);
  border-radius: var(--radius-md);
}

.collapsible-section .section-header-toggle:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
  border-radius: var(--radius-md);
}

.collapsible-section .section-header-icon {
  font-size: 1.1rem;
  line-height: 1;
  flex-shrink: 0;
}

.collapsible-section .section-title {
  margin: 0;
  flex: 1;
  font-size: 0.95rem;
  font-weight: 600;
  letter-spacing: -0.01em;
  text-transform: uppercase;
  color: var(--color-text-muted);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.collapsible-section .section-title .badge {
  font-size: 0.75rem;
  margin-left: 0.25rem;
}

.collapsible-section .section-header-chevron {
  font-size: 0.8rem;
  color: var(--color-text-muted);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  flex-shrink: 0;
}

.collapsible-section.expanded .section-header-chevron {
  transform: rotate(180deg);
}

.section-collapsible-content {
  max-height: 0;
  overflow: hidden;
  opacity: 0;
  transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
  will-change: max-height;
}

.collapsible-section.expanded .section-collapsible-content {
  max-height: 5000px;
  opacity: 1;
}

#layers-section .section-collapsible-content {
  padding-top: 0;
}

#layers-section.expanded .section-collapsible-content {
  max-height: 6000px;
  padding-top: 0.5rem;
}

#waypoints-section .section-collapsible-content {
  padding-top: 0;
}

#map-style-section .section-collapsible-content {
  padding-top: 0;
}

#map-style-section.expanded .section-collapsible-content {
  padding-top: 0.5rem;
}

#waypoints-section.expanded .section-collapsible-content {
  max-height: 2000px;
  padding-top: 0.5rem;
}

.collapsible-section.expanded .section-collapsible-content > * {
  animation: slideInContent 0.3s ease-out;
}

@keyframes slideInContent {
  from {
    opacity: 0;
    transform: translateY(-8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@media (prefers-color-scheme: dark) {
  .collapsible-section .section-header-toggle:hover {
    background: rgba(255, 255, 255, 0.05);
  }
}
</style>
<style>
/* === ROADBOOK SECTION === */

.roadbook-export-btn {
  margin-left: auto;
  margin-right: 0.5rem;
  opacity: 0.7;
  transition: opacity 0.2s ease, transform 0.15s ease;
  font-size: 1rem;
  line-height: 1;
}

.roadbook-export-btn:hover,
.roadbook-export-btn:focus-visible {
  opacity: 1;
  transform: scale(1.05);
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}

.roadbook-export-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
  transform: none;
}

.roadbook-export-btn.copied {
  animation: copySuccess 0.6s ease;
}

@keyframes copySuccess {
  0%,
  100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.15);
    background: var(--color-primary-light);
  }
}

.roadbook-empty {
  padding: 2rem 1rem;
  text-align: center;
}

.roadbook-empty-text {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.75rem;
  color: var(--color-text-muted);
  font-size: 0.9rem;
  margin: 0;
}

.roadbook-empty-icon {
  font-size: 2.5rem;
  opacity: 0.5;
}

.roadbook-list {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  padding: 0.5rem 0;
}

.roadbook-step {
  display: grid;
  grid-template-columns: 48px 1fr;
  gap: 0.75rem;
  padding: 0.75rem;
  background: var(--color-background-elevated, #fff);
  border: 1px solid var(--color-border-light, #E5E5EA);
  border-radius: var(--radius-md, 8px);
  box-shadow: var(--shadow-sm);
  transition: all 0.2s ease;
}

.roadbook-step:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.roadbook-step[data-type="start"] {
  border-left: 3px solid #4CAF50;
  background: linear-gradient(90deg, rgba(76, 175, 80, 0.05) 0%, var(--color-background-elevated, #fff) 10%);
}

.roadbook-step[data-type="waypoint"] {
  border-left: 3px solid #FF5722;
}

.roadbook-step[data-type="end"] {
  border-left: 3px solid #FF5722;
  background: linear-gradient(90deg, rgba(255, 87, 34, 0.05) 0%, var(--color-background-elevated, #fff) 10%);
}

.roadbook-step-marker {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
}

.roadbook-step-icon {
  font-size: 1.75rem;
  line-height: 1;
}

.roadbook-step-number {
  font-size: 0.75rem;
  font-weight: 700;
  color: var(--color-text-muted);
  background: var(--color-background-alt);
  padding: 0.125rem 0.375rem;
  border-radius: 999px;
  min-width: 24px;
  text-align: center;
}

.roadbook-step-content {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  min-width: 0;
}

.roadbook-step-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
}

.roadbook-step-name {
  margin: 0;
  font-size: 0.95rem;
  font-weight: 600;
  color: var(--color-text-primary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.roadbook-step-center-btn {
  flex-shrink: 0;
  border: none;
  background: transparent;
  font-size: 1rem;
  cursor: pointer;
  padding: 0.25rem;
  border-radius: 4px;
  transition: all 0.2s ease;
  opacity: 0;
}

.roadbook-step:hover .roadbook-step-center-btn {
  opacity: 1;
}

.roadbook-step-center-btn:hover {
  background: var(--color-primary-light);
  transform: scale(1.1);
}

.roadbook-step-distances {
  display: flex;
  flex-direction: column;
  gap: 0.375rem;
}

.roadbook-distance-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.85rem;
}

.roadbook-distance-label {
  color: var(--color-text-muted);
}

.roadbook-distance-value {
  font-weight: 600;
  color: var(--color-text-primary);
}

.roadbook-distance-cumul .roadbook-distance-value {
  color: var(--color-primary);
  font-size: 0.95rem;
}

.roadbook-distance-segment {
  padding-left: 0.5rem;
  border-left: 2px solid var(--color-border-light);
}

.roadbook-distance-segment .roadbook-distance-label {
  font-size: 0.8rem;
}

.roadbook-distance-segment .roadbook-distance-value {
  color: var(--color-text-secondary);
  font-size: 0.85rem;
}

.roadbook-step-elevation {
  display: flex;
  align-items: center;
  gap: 0.375rem;
  padding-top: 0.375rem;
  border-top: 1px dashed var(--color-border-light);
  font-size: 0.85rem;
}

.roadbook-elevation-label {
  color: var(--color-text-muted);
}

.roadbook-elevation-value {
  font-weight: 600;
  color: var(--color-text-secondary);
}

@media (max-width: 480px) {
  .roadbook-step {
    grid-template-columns: 40px 1fr;
    gap: 0.5rem;
    padding: 0.625rem;
  }

  .roadbook-step-icon {
    font-size: 1.5rem;
  }

  .roadbook-distance-item {
    font-size: 0.8rem;
  }

  .roadbook-distance-cumul .roadbook-distance-value {
    font-size: 0.9rem;
  }
}
</style>
<!-- Layer Indicators - unified styles (replaced multiple conflicting blocks) -->
<style id="layer-indicators-unified">
/* === LAYER INDICATORS - Position & Visibilité (UNIFIÉ) === */

/* Container des indicateurs - toujours au-dessus de tout */
.layer-indicators {
  position: fixed !important;
  z-index: 1100 !important; /* Au-dessus de tout (POI button = 900, panel = 1000) */
  
  /* Centré horizontalement */
  left: 50% !important;
  transform: translateX(-50%) !important;
  top: 50% !important;
  
  /* Dimensions */
  max-width: 500px;
  width: auto;
  
  /* Layout vertical */
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  gap: 0.5rem !important;
  
  /* Pas de pointer-events sur le container, seulement sur les enfants */
  pointer-events: none !important;
}

/* Tous les messages individuels sont interactifs */
.layer-indicators > * {
  pointer-events: auto !important;
  width: 100%;
  text-align: center;
}

/* === STYLES DES INDICATEURS INDIVIDUELS === */

/* Loading - TOUJOURS VISIBLE quand display:flex est appliqué par JS */
.layer-loading {
  display: none; /* Caché par défaut, JS met display:flex */
  /* Positionnée FIXED au centre de l'écran, au-dessus de tout */
  position: fixed !important;
  z-index: 1200 !important; /* Au-dessus du reste */
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 0.5rem;
  padding: 0.75rem 1rem;
  border-radius: var(--radius-md, 8px);
  font-size: 0.95rem;
  font-weight: 600;
  width: min(90vw, 1000px);
  /*width: auto;*/
  /* Glassmorphism - bien visible */
  background: rgba(0, 102, 255, 0.95) !important;
  color: #FFFFFF !important;
  backdrop-filter: blur(6px);
  border: 1px solid rgba(255, 255, 255, 0.2);
  /* Ombre forte pour contraste */
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45) !important;
  /* Permettre les interactions avec le chargement */
  pointer-events: auto !important;
  /* Animation d'apparition */
  animation: slideDown 0.3s ease-out;
}

/* S'assurer que le loading est visible même avec des conflits de style */
.layer-loading[style*="display: flex"],
.layer-loading[style*="display:flex"] {
  display: flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  position: fixed !important;
  z-index: 1200 !important;
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  pointer-events: auto !important;
}

/* Error */
.layer-error {
  display: none;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md, 8px);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 59, 48, 0.95) !important;
  color: #FFFFFF !important;
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
  animation: slideDown 0.3s ease-out;
  position: fixed !important;
  z-index: 1200 !important; /* Au-dessus du reste */
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  align-items: center !important;
  justify-content: center !important;
  width: min(90vw, 1000px);

}

/* Info */
.layer-info {
  display: none;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md, 8px);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 149, 0, 0.95) !important;
  color: #FFFFFF !important;
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(255, 149, 0, 0.3);
  animation: slideDown 0.3s ease-out;
  position: fixed !important;
  z-index: 1200 !important; /* Au-dessus du reste */
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  align-items: center !important;
  justify-content: center !important;
    width: min(90vw, 1000px);

}

/* Zoom info */
#layers-zoom-info,
.layer-zoom-info {
  display: none;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-md, 8px);
  font-size: 0.875rem;
  font-weight: 500;
  background: rgba(255, 204, 0, 0.95) !important;
  color: #1A1A1A !important;
  border: 1px solid rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 12px rgba(255, 204, 0, 0.3);
  animation: slideDown 0.3s ease-out;
  width: min(90vw, 1000px);

}

/* Spinner animation */
.layer-loading .loading-spinner {
  display: inline-block;
  animation: spin 1s linear infinite;
  font-size: 1rem;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes slideDown {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* === RESPONSIVE MOBILE === */
@media (max-width: 767px) {
  .layer-indicators {
    top: 4.5rem !important; /* Sous le bouton menu */
    left: 1rem !important;
    right: 1rem !important;
    transform: none !important;
    max-width: none !important;
    width: auto !important;
  }
  
  .layer-loading,
  .layer-error,
  .layer-info,
  #layers-zoom-info,
  .layer-zoom-info {
    padding: 0.5rem 0.75rem;
    font-size: 0.8125rem;
  }
}

/* === DARK MODE === */
@media (prefers-color-scheme: dark) {
  .layer-loading { 
    background: rgba(10, 132, 255, 0.95) !important; 
  }
  .layer-error { 
    background: rgba(255, 69, 58, 0.95) !important; 
  }
  .layer-info { 
    background: rgba(255, 159, 10, 0.95) !important; 
  }
  #layers-zoom-info,
  .layer-zoom-info { 
    background: rgba(255, 214, 10, 0.95) !important; 
    color: #1A1A1A !important; 
  }
}
</style>
<script>
// === Empilement dynamique : calcule la hauteur totale des indicateurs visibles
(function() {
  function isVisible(el) {
    if (!el) return false;
    const cs = getComputedStyle(el);
    return cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0';
  }

  function updateButtonPosition() {
    const stack = document.querySelector('.layer-indicators');
    const btn = document.querySelector('.poi-refresh-button');
    if (!stack || !btn) return;

    // Mesurer uniquement les éléments visibles dans la pile
    const items = Array.from(stack.children).filter(isVisible);
    const gap = parseFloat(getComputedStyle(stack).gap || '8'); // px
    const stackTop = stack.getBoundingClientRect().top + window.scrollY; // position initiale top

    // Hauteur totale = somme des hauteurs + gaps
    let total = 0;
    items.forEach((el, idx) => {
      total += el.offsetHeight;
      if (idx < items.length - 1) total += gap;
    });

    // Positionner le bouton sous la pile (si pile vide, coller au top de la pile)
    const topPx = Math.round((stackTop || 16) + total);
    btn.style.top = topPx + 'px';
  }

  // Observer les mutations de visibilité/changement de texte/contenu
  const observer = new MutationObserver(() => {
    requestAnimationFrame(updateButtonPosition);
  });

  function init() {
    const stack = document.querySelector('.layer-indicators');
    const btn = document.querySelector('.poi-refresh-button');
    if (!stack || !btn) return;

    observer.observe(stack, { attributes: true, childList: true, subtree: true, attributeFilter: ['style', 'class'] });

    // Ajuster à l'ouverture/fermeture du panneau (resize / orientation)
    window.addEventListener('resize', () => requestAnimationFrame(updateButtonPosition));
    window.addEventListener('orientationchange', () => requestAnimationFrame(updateButtonPosition));

    // Premier calcul
    updateButtonPosition();

    // Exposer une fonction globale légère si le code existant veut forcer un recalcul
    window.__updatePoiButtonPosition = updateButtonPosition;
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

// === Map Style Control ===

// Définitions des fonds de carte gratuits (100% sans clé API)
const mapStyles = {
  cyclosm: {
    name: 'CyclOSM',
    url: 'https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png',
    attribution: '&copy; OpenStreetMap | CyclOSM',
    maxZoom: 20
  },
  osm: {
    name: 'OpenStreetMap',
    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    attribution: '&copy; OpenStreetMap contributors',
    maxZoom: 19
  },
  topo: {
    name: 'OpenTopoMap',
    url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
    attribution: '&copy; OpenStreetMap | OpenTopoMap',
    maxZoom: 17
  },
  voyager: {
    name: 'CARTO Voyager',
    url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
    attribution: '&copy; OpenStreetMap | CARTO',
    maxZoom: 20
  },  satellite: {
    name: 'Esri Imagery',
    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    attribution: '&copy; Esri, Maxar, Earthstar Geographics',
    maxZoom: 19
  },
  hybrid: {
    name: 'Esri Hybrid',
    layers: [
      { url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', maxZoom: 19 },
      { url: 'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', maxZoom: 19 }
    ],
    attribution: '&copy; Esri, Maxar, Earthstar Geographics',
    maxZoom: 19
  }
};

// État du contrôle
const mapStyleControl = {
  currentStyle: 'voyager',
  tileLayers: [],
  isOpen: false,
  toggleButton: null,
  panel: null,
  options: []
};

function changeMapStyle(styleId) {
  if (!mapStyles[styleId]) return;

  // retirer anciennes couches
  mapStyleControl.tileLayers.forEach(layer => { if (map.hasLayer(layer)) map.removeLayer(layer); });
  mapStyleControl.tileLayers = [];

  const style = mapStyles[styleId];
  if (style.layers) {
    style.layers.forEach(ld => {
      const layer = L.tileLayer(ld.url, { maxZoom: ld.maxZoom, attribution: style.attribution || '' }).addTo(map);
      mapStyleControl.tileLayers.push(layer);
    });
  } else {
    const layer = L.tileLayer(style.url, { maxZoom: style.maxZoom, attribution: style.attribution }).addTo(map);
    mapStyleControl.tileLayers.push(layer);
  }

  mapStyleControl.currentStyle = styleId;
  updateMapStyleUI(styleId);
  try { localStorage.setItem('gpx_map_style', styleId); } catch(_) {}
}

function updateMapStyleUI(active) {
  mapStyleControl.options.forEach(btn => {
    const id = btn.getAttribute('data-style');
    if (id === active) btn.classList.add('active'); else btn.classList.remove('active');
  });
}

function toggleMapStylePanel(forceState) {
  const shouldOpen = forceState !== undefined ? forceState : !mapStyleControl.isOpen;
  mapStyleControl.panel.style.display = shouldOpen ? 'block' : 'none';
  mapStyleControl.toggleButton.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
  mapStyleControl.isOpen = shouldOpen;
}

function loadMapStylePreference() {
  try { const v = localStorage.getItem('gpx_map_style'); return (v && mapStyles[v]) ? v : 'voyager'; } catch(_) { return 'voyager'; }
}

function initMapStyleControl() {
  mapStyleControl.toggleButton = document.getElementById('map-style-toggle');
  mapStyleControl.panel = document.getElementById('map-style-panel');
  mapStyleControl.options = Array.from(document.querySelectorAll('.map-style-option'));

  if (!mapStyleControl.toggleButton || !mapStyleControl.panel) return;

  // appliquer préférence
  changeMapStyle(loadMapStylePreference() || 'voyager');

  // events
  mapStyleControl.toggleButton.addEventListener('click', (e) => { e.stopPropagation(); toggleMapStylePanel(); });
  mapStyleControl.options.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const id = btn.getAttribute('data-style');
      if (id) { changeMapStyle(id); toggleMapStylePanel(false); }
    });
  });
  document.addEventListener('click', (e) => {
    if (mapStyleControl.isOpen) {
      const inside = mapStyleControl.panel.contains(e.target) || mapStyleControl.toggleButton.contains(e.target);
      if (!inside) toggleMapStylePanel(false);
    }
  });
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && mapStyleControl.isOpen) toggleMapStylePanel(false); });
}

document.addEventListener('DOMContentLoaded', () => { try { attachWaypointPersistence(); } catch(e){} });
</script>
<style>
/* === Géolocalisation : styles === */
.geolocation-toggle { padding: 0.5rem 0; }
.geolocation-info {
  margin-top: 0.75rem; padding: 0.75rem; border-radius: var(--radius-md);
  background: var(--color-background-alt); border: 1px solid var(--color-border-light);
}
.geolocation-status {
  display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: var(--color-text-secondary);
}
.geolocation-status .status-icon { font-size: 1rem; }
.geolocation-status.active .status-icon { animation: pulse 2s ease-in-out infinite; }
.geolocation-status.error { color: var(--color-danger); }
.geolocation-error {
  margin-top: 0.75rem; padding: 0.625rem 0.875rem; border-radius: var(--radius-md);
  background: rgba(255, 59, 48, 0.1); color: var(--color-danger); font-size: 0.875rem;
  border: 1px solid rgba(255, 59, 48, 0.2);
}
@keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:.5;} }

/* Marqueur de position */
.user-location-marker { border: none !important; background: transparent !important; }
.user-location-marker-inner {
  width: 100%; height: 100%; border-radius: 50%; background: #4285F4; border: 3px solid #ffffff;
  box-shadow: 0 2px 8px rgba(66,133,244,0.4); animation: locationPulse 2s ease-in-out infinite;
}
@keyframes locationPulse { 0%,100%{transform:scale(1);opacity:1;} 50%{transform:scale(1.1);opacity:.8;} }
.user-location-accuracy { fill: rgba(66,133,244,0.15); stroke: rgba(66,133,244,0.3); stroke-width: 2; }
</style>
<style>
/* Sidebar widening & preset select layout overrides */
.tools-panel { width: 460px !important; min-width: 460px !important; }
@media (max-width: 1024px) {
  .tools-panel { width: 92vw !important; max-width: 460px !important; }
}
@media (max-width: 767px) {
  .tools-panel { width: 95vw !important; max-width: 460px !important; }
  .layer-presets { flex-direction: column !important; align-items: stretch !important; }
}
.layer-presets { display: flex; gap: 0.5rem; align-items: center; }
.layer-presets label { flex: 0 0 auto; margin-right: 0.25rem; }
.preset-select { flex: 1 1 auto; width: 100%; }
</style>
<style>
/* ===== Mobile Portrait Sidebar Compatibility (overrides) ===== */
@media (max-width: 600px) and (orientation: portrait) {
  .tools-panel {
    position: fixed;
    inset: 0 auto 0 0;            /* top:0; left:0; full height */
    width: 100vw !important;
    max-width: 100vw !important;
    min-width: 0 !important;
    height: 100dvh !important;    /* account for mobile browser UI */
    border-right: none !important;
    box-shadow: 0 0 24px rgba(0,0,0,0.15) !important;
    z-index: 2200 !important;
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    transform: translateX(-100%); /* respect existing open/close behavior */
  }
  .tools-panel.open {
    transform: translateX(0);
  }

  .panel-content {
    padding: 0.75rem 1rem !important;
  }

  /* Presets layout: vertical, full width */
  .layer-presets {
    display: flex !important;
    flex-direction: column !important;
    align-items: stretch !important;
    gap: 0.5rem !important;
  }
  .layer-presets label { margin-right: 0 !important; }
  .preset-select { width: 100% !important; min-height: 40px; }

  /* Buttons row wraps gracefully */
  .layer-global-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  /* Slightly smaller section titles to save space */
  .section-title {
    font-size: 1rem !important;
    line-height: 1.25rem !important;
  }
}
</style>
<script id="map-style-control-defs">
// === Map Style Control (defs preloaded) ===
(function(){
  if (window.__MAP_STYLE_CONTROL_DEFINED__) return;
  window.__MAP_STYLE_CONTROL_DEFINED__ = true;

  window.mapStyles = {
    cyclosm: { name:'CyclOSM', url:'https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', attribution:'&copy; OpenStreetMap | CyclOSM | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:20 },
    osm: { name:'OpenStreetMap', url:'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', attribution:'&copy; OpenStreetMap contributors | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:19 },
    topo: { name:'OpenTopoMap', url:'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attribution:'&copy; OpenStreetMap | OpenTopoMap | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:17 },
    voyager: { name:'CARTO Voyager', url:'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', attribution:'&copy; OpenStreetMap | CARTO | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:20 },
    satellite: { name:'Esri Imagery', url:'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', attribution:'&copy; Esri, Maxar, Earthstar Geographics | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:19 },
    hybrid: { name:'Esri Hybrid', layers:[
      { url:'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', maxZoom:19 },
      { url:'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', maxZoom:19 }
    ], attribution:'&copy; Esri, Maxar, Earthstar Geographics | <a href="https://lamouche.fr" target="_blank" rel="noopener noreferrer">Benoit Lamouche</a>', maxZoom:19 }
  };

  window.mapStyleControl = { currentStyle: 'voyager', tileLayers:[], isOpen:false, toggleButton:null, panel:null, options:[] };

  window.changeMapStyle = function(styleId){
    if (!window.map || !window.mapStyles[styleId]) return;
    // remove old
    window.mapStyleControl.tileLayers.forEach(l => { if (window.map.hasLayer(l)) window.map.removeLayer(l); });
    window.mapStyleControl.tileLayers = [];
    const style = window.mapStyles[styleId];
    if (style.layers) {
      style.layers.forEach(ld => {
        const layer = L.tileLayer(ld.url, { maxZoom: ld.maxZoom, attribution: style.attribution || '' }).addTo(window.map);
        window.mapStyleControl.tileLayers.push(layer);
      });
    } else {
      const layer = L.tileLayer(style.url, { maxZoom: style.maxZoom, attribution: style.attribution }).addTo(window.map);
      window.mapStyleControl.tileLayers.push(layer);
    }
    window.mapStyleControl.currentStyle = styleId;
    window.updateMapStyleUI(styleId);
    try { localStorage.setItem('gpx_map_style', styleId); } catch(_) {}
  };

  window.updateMapStyleUI = function(active){
    (window.mapStyleControl.options || []).forEach(btn => {
      const id = btn.getAttribute('data-style');
      if (id === active) btn.classList.add('active'); else btn.classList.remove('active');
    });
  };

  window.toggleMapStylePanel = function(forceState){
    const shouldOpen = forceState !== undefined ? forceState : !window.mapStyleControl.isOpen;
    if (!window.mapStyleControl.panel || !window.mapStyleControl.toggleButton) return;
    window.mapStyleControl.panel.style.display = shouldOpen ? 'block' : 'none';
    window.mapStyleControl.toggleButton.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    window.mapStyleControl.isOpen = shouldOpen;
  };

  window.loadMapStylePreference = function(){
    try { const v = localStorage.getItem('gpx_map_style'); return (v && window.mapStyles[v]) ? v : 'voyager'; } catch(_) { return 'voyager'; }
  };

  window.initMapStyleControl = function(){
    window.mapStyleControl.toggleButton = document.getElementById('map-style-toggle');
    window.mapStyleControl.panel = document.getElementById('map-style-panel');
    window.mapStyleControl.options = Array.from(document.querySelectorAll('.map-style-option'));
    if (!window.mapStyleControl.toggleButton || !window.mapStyleControl.panel) return;

    // appliquer préférence
    window.changeMapStyle(window.loadMapStylePreference());

    // events
    window.mapStyleControl.toggleButton.addEventListener('click', (e) => { e.stopPropagation(); window.toggleMapStylePanel(); });
    window.mapStyleControl.options.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const id = btn.getAttribute('data-style');
        if (id) { window.changeMapStyle(id); window.toggleMapStylePanel(false); }
      });
    });
    document.addEventListener('click', (e) => {
      if (window.mapStyleControl.isOpen) {
        const inside = window.mapStyleControl.panel.contains(e.target) || window.mapStyleControl.toggleButton.contains(e.target);
        if (!inside) window.toggleMapStylePanel(false);
      }
    });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && window.mapStyleControl.isOpen) window.toggleMapStylePanel(false); });
  };
})();
</script>
<style>
  /* Ensure elevation canvas has a minimum render size after reload */
  #elevation-canvas {
    min-height: 220px;
    width: 100%;
    display: block;
  }
</style>
<style>
  /* Elevation panel responsive sizing */
  #elevation-profile {
    overflow: hidden;
  }
  #elevation-canvas {
    width: 100%;
    display: block;
    /* height is set dynamically by JS; this is a safe fallback */
    max-height: 40vh;
  }
</style>
<style>
  /* Viewport-aware elevation sizing */
  #elevation-profile { overflow: hidden; }
  #elevation-canvas { width: 100%; display: block; }
</style>
<style>
  /* Elevation container should auto-size to its content */
  #elevation-profile { overflow: visible; }
  #elevation-content {
    height: auto !important;
    max-height: none !important;
    overflow: visible !important;
  }
</style>
<style>
  /* Canvas fills its parent container */
  #elevation-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  /* Parent controls height; provide a safe default you can override */
  #elevation-content {
    --elev-content-height: 260px;
    height: var(--elev-content-height);
  }
</style>
<style>
/* === Trace Start/End Markers === */
.trace-start-marker,
.trace-end-marker,
.trace-combined-marker { border: none !important; background: transparent !important; }

.trace-start-marker-inner,
.trace-end-marker-inner,
.trace-combined-marker-inner {
  width: 32px; height: 32px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  border: 3px solid #FFFFFF;
  box-shadow: 0 3px 8px rgba(0,0,0,.12);
  transition: transform .2s cubic-bezier(.34,1.56,.64,1);
  animation: markerAppear .4s cubic-bezier(.34,1.56,.64,1);
}

.trace-start-marker-inner { background: #4CAF50; box-shadow: 0 3px 8px rgba(76,175,80,0.4); }
.trace-end-marker-inner   { background: #FF5722; box-shadow: 0 3px 8px rgba(255,87,34,0.4); }
.trace-combined-marker-inner {
  background: linear-gradient(135deg, #4CAF50 0%, #FF5722 100%);
}

.trace-start-marker-icon,
.trace-end-marker-icon,
.trace-combined-marker-icon {
  font-size: 18px; line-height: 1;
  filter: drop-shadow(0 1px 2px rgba(0,0,0,.3));
}

/* Hover */
.trace-start-marker:hover .trace-start-marker-inner,
.trace-end-marker:hover .trace-end-marker-inner,
.trace-combined-marker:hover .trace-combined-marker-inner {
  transform: scale(1.15);
}

/* Apparition */
@keyframes markerAppear {
  from { opacity: 0; transform: scale(0.3); }
  to   { opacity: 1; transform: scale(1); }
}

/* Popup */
.trace-marker-popup { min-width: 200px; }
.trace-marker-popup-header {
  display:flex; align-items:center; gap:.5rem; padding-bottom:.5rem;
  border-bottom:1px solid var(--color-border); margin-bottom:.5rem;
}
.trace-marker-popup-title { font-size:1rem; font-weight:600; color:var(--color-text-primary); }
.trace-marker-popup-details { display:flex; flex-direction:column; gap:.375rem; margin-bottom:.5rem; }
.trace-marker-popup-row { display:flex; gap:.5rem; font-size:.875rem; }
.trace-marker-popup-label { color:var(--color-text-muted); min-width:70px; }
.trace-marker-popup-value { color:var(--color-text-primary); font-weight:500; }
.trace-marker-popup-button { width:100%; margin-top:.5rem; }
</style>


<style id="map-topbar-styles">
.map-wrapper {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
}
.map-topbar {
  height: 48px;
  background: #ffffff;
  border-bottom: 1px solid var(--color-border, #E5E5EA);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 16px;
  font-weight: 700;
  font-size: 1rem;
  color: #667eea;
  flex-shrink: 0;
  z-index: 10;
}
#map {
  flex: 1;
  height: auto;
  position: relative;
}
/* Controls slight offset */
#map .leaflet-top { top: 8px; }
@media (max-width: 767px) {
  .map-topbar { height: 56px; }
}
</style>

<style>
@media (max-width: 767px) {
  /* Positionne le bouton menu sous la barre horizontale */
  .btn-menu {
    top: 4.5rem !important; /* ajuste selon la hauteur de ta topbar */
    z-index: 1200 !important; /* s’assure qu’il reste cliquable */
  }
}
</style>
<style>
.panel-header {
  height: 48px;
  padding: 0 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
  color: #ffffff;
  border-bottom: none;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
}

.panel-title {
  color: #ffffff !important;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.panel-title::before {
  content: "🧰";
  font-size: 1.75rem;
  line-height: 1;
}

.btn-close-panel {
  display: none;
  color: rgba(255, 255, 255, 0.9);
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  width: 36px;
  height: 36px;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.btn-close-panel:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: rotate(90deg);
}

@media (max-width: 767px) {
  .panel-header {
    height: 56px;
    padding: 0 14px;
  }

  .btn-close-panel {
    display: flex;
    align-items: center;
    justify-content: center;
  }
}
</style>

</head>
<body>
<div class="app-container">
<aside aria-label="Panneau d'outils" class="tools-panel" id="tools-panel" role="complementary">
<header class="panel-header">
<h2 class="panel-title">Outils</h2>
<button aria-label="Fermer le panneau" class="btn-close-panel" id="close-panel">✕</button>
</header>
<div class="panel-content">
<section class="panel-section geolocation-section" id="geolocation-section">
<h3 class="section-title">Ma position</h3>
<label class="layer-toggle geolocation-toggle">
<input aria-label="Activer la géolocalisation en temps réel" class="toggle-input" id="geolocation-toggle" type="checkbox"/>
<span class="toggle-switch"></span>
<span class="toggle-text">
<span aria-hidden="true" class="toggle-icon">📍</span>
      Activer la localisation
    </span>
</label>
<div class="geolocation-info" id="geolocation-info" style="display: none;">
<div class="geolocation-status" id="geolocation-status">
<span class="status-icon">🔄</span>
<span class="status-text">Recherche de position...</span>
</div>
<button class="btn btn-secondary btn-small" disabled="" id="center-on-position" style="margin-top: 0.5rem;" type="button">
<span aria-hidden="true">🎯</span>
      Centrer sur ma position
    </button>
</div>
<div class="geolocation-error" id="geolocation-error" style="display: none;"></div>
</section>
<section class="panel-section gpx-section">
<h3 class="section-title">
<span class="section-icon" aria-hidden="true">📍</span>
        Trace GPX
      </h3>
<div class="gpx-empty-state" id="gpx-empty-state">
<div aria-label="Importer une trace GPX" class="gpx-import-zone" id="gpx-import-zone" role="button" tabindex="0">
<span aria-hidden="true" class="gpx-import-icon">📁</span>
<span class="gpx-import-title">Importer une trace GPX</span>
<span class="gpx-import-hint">Glissez un fichier .gpx ou cliquez pour parcourir</span>
</div>
</div>
<div class="gpx-loaded-state hidden" id="gpx-loaded-state">
<div class="trace-summary" id="gpx-trace-summary">
<div class="trace-filename" id="gpx-trace-filename">—</div>
<div class="trace-stats">
<span aria-hidden="true" class="icon">📊</span>
<span id="gpx-trace-distance">—</span>
<span aria-hidden="true">•</span>
<span id="gpx-trace-elevation">—</span>
</div>
</div>
<div class="gpx-actions">
<button class="gpx-action-btn gpx-action-btn--export" id="gpx-export-action" type="button">
<span aria-hidden="true" class="icon">💾</span>
<span class="label">Exporter</span>
</button>
<button class="gpx-action-btn" id="gpx-replace-action" type="button">
<span aria-hidden="true" class="icon">🔄</span>
<span class="label">Remplacer</span>
</button>
<button class="gpx-action-btn gpx-action-btn--danger" id="clear-trace-button" type="button">
<span aria-hidden="true" class="icon">🗑️</span>
<span class="label">Effacer</span>
</button>
</div>
</div>
</section>
<section class="panel-section map-style-section collapsible-section" id="map-style-section">
<button aria-controls="map-style-content" aria-expanded="false" class="section-header-toggle" type="button">
<span class="section-header-icon">🗺️</span>
<h3 class="section-title">Style de carte</h3>
<span class="section-header-chevron">▼</span>
</button>
<div class="section-collapsible-content" id="map-style-content">
<div class="map-style-options">
<button class="map-style-option" data-style="voyager" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-voyager"></div></div><span class="map-style-label-text">🗺️ Voyager</span></button>
<button class="map-style-option" data-style="cyclosm" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-cyclosm"></div></div><span class="map-style-label-text">🚴 CyclOSM</span></button>
<button class="map-style-option" data-style="osm" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-osm"></div></div><span class="map-style-label-text">🌍 OpenStreetMap</span></button>
<button class="map-style-option" data-style="topo" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-topo"></div></div><span class="map-style-label-text">⛰️ OpenTopoMap</span></button>
<button class="map-style-option" data-style="satellite" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-satellite"></div></div><span class="map-style-label-text">🛰️ Esri Imagery</span></button>
<button class="map-style-option" data-style="hybrid" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-hybrid"></div></div><span class="map-style-label-text">🛰️+🏙️ Esri Hybrid</span></button>
</div>
</div>
</section>
<section class="panel-section" id="layers-section-placeholder"></section>
<section class="panel-section collapsible-section" id="waypoints-section" style="display: none;">
<button aria-controls="waypoints-content" aria-expanded="false" class="section-header-toggle" type="button">
<span class="section-header-icon">📍</span>
<h3 class="section-title">Waypoints <span class="badge" id="waypoint-count">0</span></h3>
<span class="section-header-chevron">▼</span>
</button>
<div class="section-collapsible-content" id="waypoints-content">
<div class="waypoints-list" id="waypoints-list"></div>
<button class="btn btn-secondary btn-small" id="clear-waypoints">Effacer tous les waypoints</button>
</div>
</section>
<section class="panel-section collapsible-section" id="roadbook-section" style="display: none;">
<div class="section-header-with-action">
<button aria-controls="roadbook-content" aria-expanded="false" class="section-header-toggle" type="button">
<span class="section-header-icon">📋</span>
<h3 class="section-title">Roadbook <span class="badge" id="roadbook-step-count">0</span></h3>
<span class="section-header-chevron">▼</span>
</button>
<button class="btn-icon-small roadbook-export-btn" id="roadbook-export-text" type="button" title="Copier le roadbook en texte" aria-label="Copier le roadbook au format texte" disabled>📋</button>
</div>
<div class="section-collapsible-content" id="roadbook-content">
<div class="roadbook-empty" id="roadbook-empty">
<p class="roadbook-empty-text">
<span class="roadbook-empty-icon">🗺️</span>
        Aucun waypoint sur le parcours
      </p>
</div>
<div class="roadbook-list" id="roadbook-list">
</div>
</div>
</section>
<section class="panel-section" id="trace-info-section" style="display: none;">
<h3 class="section-title">Informations</h3>
<dl class="info-list">
<dt>Nom de la trace</dt>
<dd>
<span class="trace-name" id="trace-name">—</span>
<span aria-hidden="true" class="trace-name-help" title="Le nom provient d'abord du fichier GPX, puis du nom de fichier, ou d'un nom par défaut.">
                ℹ️
              </span>
</dd>
<dt>Nom du fichier</dt>
<dd class="file-name" id="file-name">—</dd>
<dt>Distance totale</dt>
<dd class="stat-highlight" id="trace-distance">—</dd>
<dt>Dénivelé positif (D+)</dt>
<dd class="stat-highlight" id="trace-elevation-gain">—</dd>
<dt>Dénivelé négatif (D-)</dt>
<dd class="stat-highlight" id="trace-elevation-loss">—</dd>
<dt>Altitude</dt>
<dd id="trace-altitude-range">—</dd>
<dt>Nombre de points</dt>
<dd id="point-count">—</dd>
<dt>Type</dt>
<dd id="trace-type">—</dd>
</dl>
<div class="mini-elevation-profile" id="mini-elevation-profile" style="display: none;">
<h4 class="mini-profile-title">Profil d'élévation</h4>
<div class="mini-profile-canvas-wrapper">
<canvas aria-label="Aperçu du profil d'élévation de la trace" id="mini-elevation-canvas" role="img"></canvas>
</div>
<div class="sr-only" id="mini-elevation-description">
          Graphique montrant l'évolution de l'altitude sur la distance totale de la trace.
          Altitude minimale : <span id="mini-aria-min">—</span>, maximale : <span id="mini-aria-max">—</span>.
        </div>
</div>
</section>
<section class="panel-section panel-messages">
<div aria-live="polite" class="message hidden" id="message" role="status"></div>
</section>
</div>
<footer class="panel-footer">
<div class="panel-footer-links" role="list">
<span role="listitem"><a href="https://lamouche.fr" rel="author noopener" target="_blank">Développé par Benoit Lamouche</a></span>
<span class="panel-footer-separator" aria-hidden="true">•</span>
<span role="listitem"><a href="https://www.strava.com/athletes/4347458" rel="noopener" target="_blank">Strava</a></span>
<span class="panel-footer-separator" aria-hidden="true">•</span>
<span role="listitem"><a href="https://paypal.me/blamouche" rel="noopener" target="_blank">Offre moi une bière 🍺</a></span>
</div>
<span class="panel-version">Version 1.0.0</span>
</footer>
</aside>
<main class="map-container">
<div class="map-main">
<div class="map-wrapper"><div class="map-topbar">
<span class="map-topbar-title"><h1 style="margin:0;">Cycling Companion</h1></span>
</div><div id="map"></div></div>
<div class="map-style-section">
<div class="map-style-section-title">Routes &amp; Cyclisme</div>
<button class="map-style-option" data-style="cyclosm" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-cyclosm"></div></div><span class="map-style-label-text"><span class="map-style-check">✓</span>
<span class="map-style-label">CyclOSM</span>
<span class="map-style-badge">⭐</span></span></button>
<button class="map-style-option" data-style="osm" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-osm"></div></div><span class="map-style-label-text"><span class="map-style-check">✓</span>
<span class="map-style-label">OpenStreetMap</span></span></button>
<button class="map-style-option" data-style="topo" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-topo"></div></div><span class="map-style-label-text"><span class="map-style-check">✓</span>
<span class="map-style-label">OpenTopoMap</span></span></button>
<button class="map-style-option" data-style="voyager" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-voyager"></div></div><span class="map-style-label-text"><span class="map-style-check">✓</span>
<span class="map-style-label">CARTO Voyager</span></span></button>
</div>
<div class="map-style-section">
<div class="map-style-section-title">🛰️ Satellite</div>
<button class="map-style-option" data-style="satellite" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-satellite"></div></div><span class="map-style-label-text"><span class="map-style-check">✓</span>
<span class="map-style-label">Esri Imagery</span></span></button>
<button class="map-style-option" data-style="hybrid" type="button"><div class="map-style-thumb"><div class="map-style-thumb-inner" id="map-thumb-hybrid"></div></div><span class="map-style-label-text"><span class="map-style-check">✓</span>
<span class="map-style-label">Esri Hybrid</span>
<span class="map-style-badge">⭐</span></span></button>
</div>
</div>
</main></div>
<button aria-label="Recharger les points d'intérêt" class="poi-refresh-button" id="poi-refresh-button" type="button">
<span aria-hidden="true">🔄</span>
          Recharger les POI
        </button>
<button aria-expanded="false" aria-label="Ouvrir le panneau" class="btn-menu" id="menu-toggle">☰</button>
<div aria-hidden="true" class="elevation-profile" id="elevation-profile">
<div class="elevation-header" id="elevation-header">
<div class="elevation-title" title="Profil altimétrique">
<span aria-hidden="true" class="elevation-icon">📊</span>
<h3>Profil altimétrique</h3>
</div>
<div class="elevation-stats-quick">
<span class="stat-item">
<span class="stat-label">Distance :</span>
<span class="stat-value" id="profile-distance">—</span>
</span>
<span class="stat-item">
<span class="stat-label">D+ :</span>
<span class="stat-value" id="profile-elevation-gain">—</span>
</span>
<span class="stat-item">
<span class="stat-label">D- :</span>
<span class="stat-value" id="profile-elevation-loss">—</span>
</span>
</div>
<button aria-expanded="true" aria-label="Réduire le profil" class="btn-collapse" id="elevation-collapse" type="button">
<span aria-hidden="true">▼</span>
</button>
</div>
<div class="elevation-content" id="elevation-content">
<canvas aria-describedby="elevation-description" aria-label="Graphique du profil altimétrique de la trace" id="elevation-canvas" role="img" tabindex="0"></canvas>
<div class="sr-only" id="elevation-description">
            Le graphique montre l'élévation en mètres en fonction de la distance parcourue en kilomètres.
            Distance totale : <span id="aria-distance">—</span>.
            Dénivelé positif : <span id="aria-d-plus">—</span>.
            Altitude minimum : <span id="aria-min">—</span>.
            Altitude maximum : <span id="aria-max">—</span>.
          </div>
<div class="elevation-tooltip" id="elevation-tooltip" style="display: none;">
<div class="tooltip-row">
<span class="tooltip-label">Distance :</span>
<span class="tooltip-value" id="tooltip-distance">—</span>
</div>
<div class="tooltip-row">
<span class="tooltip-label">Altitude :</span>
<span class="tooltip-value" id="tooltip-elevation">—</span>
</div>
</div>
</div>
</div>
<div class="modal-backdrop hidden" id="export-modal-backdrop"></div>
<div aria-labelledby="export-modal-title" aria-modal="true" class="export-modal hidden" id="export-modal" role="dialog">
<div class="export-modal-header">
<h4 id="export-modal-title"><span aria-hidden="true">💾</span>Exporter la trace</h4>
<button aria-label="Fermer la fenêtre d'export" class="btn-icon-small" id="export-modal-close" type="button">✕</button>
</div>
<div class="export-modal-content">
<label for="export-file-name">
        Nom du fichier
        <input autocomplete="off" id="export-file-name" type="text" value=""/>
      </label>
<label class="checkbox-label" for="export-include-waypoints">
<input checked="" id="export-include-waypoints" type="checkbox"/>
<span id="export-waypoints-label">Inclure les waypoints (0)</span>
</label>
<div class="export-preview">
<span aria-hidden="true">📄</span>
<span id="export-preview-name">trace_with_waypoints.gpx</span>
</div>
</div>
<div class="export-modal-actions">
<button class="btn btn-secondary" id="export-modal-cancel" type="button">Annuler</button>
<button class="btn btn-primary" id="export-modal-download" type="button">Télécharger</button>
</div>
</div>
<input accept=".gpx" hidden="" id="file-input" type="file"/>
<!-- Leaflet JS -->
<script crossorigin="" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
<script>
    /**
     * Convertit un élément XML GPX en GeoJSON Feature.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertPoint(element, featureType) {
      if (!element) {
        return null;
      }

      const lat = parseFloat(element.getAttribute('lat'));
      const lon = parseFloat(element.getAttribute('lon'));

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }

      const properties = { kind: featureType };

      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const ele = element.querySelector('ele');
      if (ele && ele.textContent.trim()) {
        const elevation = parseFloat(ele.textContent.trim());
        if (Number.isFinite(elevation)) {
          properties.ele = elevation;
        }
      }

      const time = element.querySelector('time');
      if (time && time.textContent.trim()) {
        properties.time = time.textContent.trim();
      }

      return {
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [lon, lat]
        },
        properties
      };
    }

    /**
     * Convertit une liste de points GPX en coordonnées GeoJSON.
     * @param {NodeListOf<Element>} points
     * @returns {number[][]}
     */
    function extractCoordinates(points) {
      const coordinates = [];
      points.forEach((point) => {
        const lat = parseFloat(point.getAttribute('lat'));
        const lon = parseFloat(point.getAttribute('lon'));
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          coordinates.push([lon, lat]);
        }
      });
      return coordinates;
    }

    /**
     * Convertit un élément GPX en GeoJSON pour les routes ou pistes.
     * @param {Element} element
     * @param {string} featureType
     * @returns {GeoJSON.Feature|null}
     */
    function convertLinearFeature(element, featureType) {
      if (!element) {
        return null;
      }

      const properties = { kind: featureType };
      const name = element.querySelector('name');
      if (name && name.textContent.trim()) {
        properties.name = name.textContent.trim();
      }

      const desc = element.querySelector('desc');
      if (desc && desc.textContent.trim()) {
        properties.description = desc.textContent.trim();
      }

      const segments = [];

      if (featureType === 'track') {
        const trksegs = element.querySelectorAll('trkseg');
        trksegs.forEach((segment) => {
          const coords = extractCoordinates(segment.querySelectorAll('trkpt'));
          if (coords.length > 1) {
            segments.push(coords);
          }
        });
      } else if (featureType === 'route') {
        const coords = extractCoordinates(element.querySelectorAll('rtept'));
        if (coords.length > 1) {
          segments.push(coords);
        }
      }

      if (segments.length === 0) {
        return null;
      }

      const geometry =
        segments.length === 1
          ? { type: 'LineString', coordinates: segments[0] }
          : { type: 'MultiLineString', coordinates: segments };

      return {
        type: 'Feature',
        geometry,
        properties
      };
    }

    /**
     * Réalise une conversion minimale GPX -> GeoJSON pour les traces, routes et waypoints.
     * @param {XMLDocument} xml
     * @returns {GeoJSON.FeatureCollection}
     */
    function convertGpxToGeoJSON(xml) {
      const features = [];

      xml.querySelectorAll('wpt').forEach((wpt) => {
        const feature = convertPoint(wpt, 'waypoint');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('rte').forEach((route) => {
        const feature = convertLinearFeature(route, 'route');
        if (feature) {
          features.push(feature);
        }
      });

      xml.querySelectorAll('trk').forEach((track) => {
        const feature = convertLinearFeature(track, 'track');
        if (feature) {
          features.push(feature);
        }
      });

      return {
        type: 'FeatureCollection',
        features
      };
    }

    const OVERPASS_ENDPOINTS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://overpass.openstreetmap.fr/api/interpreter'
    ];

    const POI_GROUPS = {
      bike_services: { id: 'bike_services', label: 'Services vélo', icon: '🚴', defaultExpanded: true, order: 1 },
      resources: { id: 'resources', label: 'Ressources', icon: '💧', defaultExpanded: true, order: 2 },
      accommodation_outdoor: { id: 'accommodation_outdoor', label: 'Hébergement outdoor', icon: '🏕️', defaultExpanded: true, order: 3 },
      accommodation: { id: 'accommodation', label: 'Hébergement', icon: '🏨', defaultExpanded: false, order: 4 },
      sanitary: { id: 'sanitary', label: 'Sanitaires', icon: '🚻', defaultExpanded: true, order: 5 },
      food_shop: { id: 'food_shop', label: 'Alimentation', icon: '🛒', defaultExpanded: true, order: 6 },
      food_service: { id: 'food_service', label: 'Restauration', icon: '🍴', defaultExpanded: false, order: 7 },
      health: { id: 'health', label: 'Santé', icon: '💊', defaultExpanded: true, order: 8 },
      heritage: { id: 'heritage', label: 'Patrimoine', icon: '🪦', defaultExpanded: false, order: 9 }
    };

    const POI_CATEGORIES = {bicycle_repair: {
        id: 'bicycle_repair',
        label: 'Stations réparation',
        icon: '🔧',
        color: '#FF6B00',
        group: 'bike_services',
        tags: { amenity: 'bicycle_repair_station' },
        priority: 'high',
        minZoom: 12
      },
      bicycle_shop: {
        id: 'bicycle_shop',
        label: 'Magasins vélo',
        icon: '🚲',
        color: '#FF8C00',
        group: 'bike_services',
        tags: { shop: 'bicycle' },
        priority: 'high',
        minZoom: 12
      },
      drinking_water: {
        id: 'drinking_water',
        label: 'Eau potable',
        icon: '💧',
        color: '#2196F3',
        group: 'resources',
        tags: { amenity: 'drinking_water' },
        priority: 'high',
        minZoom: 11
      },
      camp_site: {
        id: 'camp_site',
        label: 'Camping',
        icon: '🏕️',
        color: '#4CAF50',
        group: 'accommodation_outdoor',
        tags: { tourism: 'camp_site' },
        excludeTags: { backcountry: 'yes' },
        priority: 'high',
        minZoom: 11
      },
      camp_site_backcountry: {
        id: 'camp_site_backcountry',
        label: 'Bivouac autorisé',
        icon: '⛺',
        color: '#66BB6A',
        group: 'accommodation_outdoor',
        tags: { tourism: 'camp_site', backcountry: 'yes' },
        priority: 'high',
        minZoom: 11
      },
      wilderness_hut: {
        id: 'wilderness_hut',
        label: 'Refuge',
        icon: '🛖',
        color: '#8D6E63',
        group: 'accommodation_outdoor',
        tags: { tourism: 'wilderness_hut' },
        priority: 'high',
        minZoom: 11
      },
      alpine_hut: {
        id: 'alpine_hut',
        label: 'Refuge alpin',
        icon: '🏔️',
        color: '#795548',
        group: 'accommodation_outdoor',
        tags: { tourism: 'alpine_hut' },
        priority: 'high',
        minZoom: 11
      },
      hotel: {
        id: 'hotel',
        label: 'Hôtel',
        icon: '🏨',
        color: '#9C27B0',
        group: 'accommodation',
        tags: { tourism: 'hotel' },
        priority: 'medium',
        minZoom: 12
      },
      hostel: {
        id: 'hostel',
        label: 'Auberge de jeunesse',
        icon: '🏠',
        color: '#AB47BC',
        group: 'accommodation',
        tags: { tourism: 'hostel' },
        priority: 'medium',
        minZoom: 12
      },
      guest_house: {
        id: 'guest_house',
        label: "Chambre d'hôtes",
        icon: '🏡',
        color: '#BA68C8',
        group: 'accommodation',
        tags: { tourism: 'guest_house' },
        priority: 'medium',
        minZoom: 13
      },
      toilets: {
        id: 'toilets',
        label: 'Toilettes',
        icon: '🚻',
        color: '#607D8B',
        group: 'sanitary',
        tags: { amenity: 'toilets' },
        priority: 'high',
        minZoom: 12
      },
      shower: {
        id: 'shower',
        label: 'Douches',
        icon: '🚿',
        color: '#78909C',
        group: 'sanitary',
        tags: { amenity: 'shower' },
        priority: 'medium',
        minZoom: 13
      },
      supermarket: {
        id: 'supermarket',
        label: 'Supermarché',
        icon: '🛒',
        color: '#FF5252',
        group: 'food_shop',
        tags: { shop: 'supermarket' },
        priority: 'high',
        minZoom: 12
      },
      convenience: {
        id: 'convenience',
        label: 'Épicerie',
        icon: '🏪',
        color: '#FF7043',
        group: 'food_shop',
        tags: { shop: 'convenience' },
        priority: 'high',
        minZoom: 12
      },
      restaurant: {
        id: 'restaurant',
        label: 'Restaurant',
        icon: '🍴',
        color: '#FFC107',
        group: 'food_service',
        tags: { amenity: 'restaurant' },
        priority: 'medium',
        minZoom: 13
      },
      cafe: {
        id: 'cafe',
        label: 'Café',
        icon: '☕',
        color: '#FFD54F',
        group: 'food_service',
        tags: { amenity: 'cafe' },
        priority: 'medium',
        minZoom: 13
      },
      fast_food: {
        id: 'fast_food',
        label: 'Fast-food',
        icon: '🍔',
        color: '#FFEB3B',
        group: 'food_service',
        tags: { amenity: 'fast_food' },
        priority: 'low',
        minZoom: 13
      },
      pharmacy: {
        id: 'pharmacy',
        label: 'Pharmacie',
        icon: '💊',
        color: '#00C853',
        group: 'health',
        tags: { amenity: 'pharmacy' },
        priority: 'high',
        minZoom: 12
      },

      hospital: {
        id: 'hospital',
        label: 'Hôpital',
        icon: '🏥',
        color: '#E53935',
        group: 'health',
        tags: { amenity: 'hospital' },
        priority: 'high',
        minZoom: 11
      },

      cemetery: {
        id: 'cemetery',
        label: 'Cimetière',
        icon: '🪦',
        color: '#6A1B9A',
        group: 'heritage',
        tags: { landuse: 'cemetery' },
        priority: 'low',
        minZoom: 12
      },
      grave_yard: {
        id: 'grave_yard',
        label: 'Petit cimetière',
        icon: '⛪',
        color: '#757575',
        group: 'heritage',
        tags: { amenity: 'grave_yard' },
        priority: 'low',
        minZoom: 12
      }
    };


    const LAYER_PRESETS = {
  need_water: {
    label: "J'ai besoin d'eau",
    icon: '💧',
    categories: [
      'drinking_water',
      'cemetery',
      'grave_yard',
      'convenience'
    ]
  },
  need_food: {
    label: 'J\'ai besoin de manger',
    icon: '🍽️',
    categories: [
      'supermarket',
      'convenience',
      'restaurant',
      'fast_food'
    ]
  },
  need_repair: {
    label: 'J\'ai besoin de réparer',
    icon: '🔧',
    categories: [
      'bicycle_repair',
      'bicycle_shop'
    ]
  },
  need_accommodation: {
    label: 'J\'ai besoin d\'un hébergement',
    icon: '🏕️',
    categories: [
      'camp_site',
      'wilderness_hut',
      'alpine_hut',
      'hotel',
      'hostel',
      'guest_house'
    ]
  },
  need_health: {
    label: 'J\'ai besoin de me soigner',
    icon: '🏥',
    categories: [
      'pharmacy',
      'hospital'
    ]
  }
};

    const POI_SETTINGS = {
      debounceMs: 2000,
      minZoomDefault: 11,
      maxTotalItems: 500,
      maxItemsPerCategory: 120,
      cacheTtlMs: 10 * 60 * 1000,
      maxCacheEntries: 15,
      areaLimitDegSq: 0.12,
      maxRetries: 2,
      requestTimeoutMs: 12000
    };

    const poiCache = {
      data: new Map(),
      set(key, value) {
        this.data.set(key, { value, timestamp: Date.now() });
      },
      get(key) {
        const entry = this.data.get(key);
        if (!entry) {
          return null;
        }
        if (Date.now() - entry.timestamp > POI_SETTINGS.cacheTtlMs) {
          this.data.delete(key);
          return null;
        }
        return entry.value;
      },
      prune(maxEntries) {
        if (this.data.size <= maxEntries) {
          return;
        }
        const sorted = Array.from(this.data.entries()).sort(
          (a, b) => a[1].timestamp - b[1].timestamp
        );
        while (sorted.length > maxEntries) {
          const [keyToDelete] = sorted.shift();
          this.data.delete(keyToDelete);
        }
      },
      clear() {
        this.data.clear();
      }
    };

    const poiRequestLimiter = {
      lastRequest: 0,
      minInterval: 1500
    };

    const poiManager = {
      activeCategories: new Set(),
      expandedGroups: new Set(),
      layerGroups: new Map(),
      counts: new Map(),
      debounceTimer: null,
      abortController: null,
      currentRequestId: 0,
      loading: false,
      enabled: false,
      refreshPending: false,
      suppressRefreshPrompt: false,
      stats: {
        totalLoaded: 0,
        currentDisplayed: 0,
        requestCount: 0,
        errorCount: 0
      }
    };

    let layersSectionElement = null;
    let layersLoadingElement = null;
    let layersErrorElement = null;
    let layersInfoElement = null;
    let layersZoomInfoElement = null;
    let presetSelectElement = null;
    let isApplyingPreset = false;

    function getDefaultExpandedGroups() {
      return new Set(
        Object.values(POI_GROUPS)
          .filter((group) => group.defaultExpanded)
          .map((group) => group.id)
      );
    }

    function getDefaultActiveCategories() {
      return new Set(['cemetery', 'grave_yard']);
    }

    function loadLayerPreferences() {
      try {
        const raw = localStorage.getItem('gpx_layer_preferences');
        if (!raw) {
          return null;
        }
        const parsed = JSON.parse(raw);
        const active = new Set(
          Array.isArray(parsed.activeCategories)
            ? parsed.activeCategories.filter((id) => POI_CATEGORIES[id])
            : []
        );
        const expanded = new Set(
          Array.isArray(parsed.expandedGroups)
            ? parsed.expandedGroups.filter((id) => POI_GROUPS[id])
            : []
        );
        return { active, expanded };
      } catch (error) {
        console.warn('Impossible de charger les préférences:', error);
        return null;
      }
    }

    function saveLayerPreferences() {
      const data = {
        activeCategories: Array.from(poiManager.activeCategories),
        expandedGroups: Array.from(poiManager.expandedGroups)
      };
      try {
        localStorage.setItem('gpx_layer_preferences', JSON.stringify(data));
      } catch (error) {
        console.warn('Impossible de sauvegarder les préférences:', error);
      }
    }

    function relocateLayerIndicators() {
      try {
        const mapContainer = document.querySelector('.map-container');
        if (!mapContainer) {
          return;
        }
        const indicators = document.querySelector('.layer-indicators');
        if (indicators) {
          if (!mapContainer.contains(indicators)) {
            mapContainer.appendChild(indicators);
          }
        }
      } catch (error) {
        console.warn('relocateLayerIndicators:', error);
      }
    }
    document.addEventListener('DOMContentLoaded', relocateLayerIndicators);

    function generateLayersHTML() {
      const groups = Object.values(POI_GROUPS).sort((a, b) => a.order - b.order);
      let html = `
        <section class="panel-section layer-section collapsible-section expanded" id="layers-section">
          <button class="section-header-toggle" type="button" aria-expanded="true" aria-controls="layers-content">
            <span class="section-header-icon">🗂️</span>
            <h3 class="section-title">Calques et affichage</h3>
            <span class="section-header-chevron">▼</span>
          </button>
          <div class="section-collapsible-content" id="layers-content">
            <div class="layer-global-actions">
              <button type="button" class="btn btn-secondary btn-small" id="layers-enable-all">Activer tout</button>
              <button type="button" class="btn btn-secondary btn-small" id="layers-disable-all">Désactiver tout</button>
            </div>
            
            <div class="layer-presets">
              <label for="preset-select">Profil :</label>
              <select id="preset-select" class="preset-select">
                <option value="">Personnalisé</option>`;
      Object.entries(LAYER_PRESETS).forEach(([presetId, preset]) => {
        html += `
                <option value="${presetId}">${preset.icon} ${preset.label}</option>`;
      });
      html += `
              </select>

            </div>`;
      groups.forEach((group) => {
        const categories = Object.values(POI_CATEGORIES).filter((category) => category.group === group.id);
        if (categories.length === 0) {
          return;
        }
        const isExpanded = poiManager.expandedGroups.has(group.id);
        html += `
            <div class="layer-group ${isExpanded ? 'expanded' : ''}" data-group="${group.id}">
              <button class="layer-group-header" type="button" data-group="${group.id}" aria-expanded="${isExpanded ? 'true' : 'false'}">
                <span class="layer-group-icon">${group.icon}</span>
                <span class="layer-group-label">${group.label}</span>
                <span class="layer-group-count">(${categories.length})</span>
                <span class="layer-group-chevron">▼</span>
              </button>
              <div class="layer-group-content">`;
        categories.forEach((category) => {
          const isChecked = poiManager.activeCategories.has(category.id) ? 'checked' : '';
          html += `
                <label class="layer-toggle" data-category="${category.id}">
                  <input
                    type="checkbox"
                    id="layer-${category.id}"
                    class="toggle-input layer-checkbox"
                    data-category="${category.id}"
                    ${isChecked}
                  />
                  <span class="toggle-switch"></span>
                  <span class="toggle-text">
                    <span class="toggle-icon" aria-hidden="true">${category.icon}</span>
                    ${category.label}
                  </span>
                  <span class="toggle-count" id="count-${category.id}" style="display: none;">(0)</span>
                </label>`;
        });
        html += `
              </div>
            </div>`;
      });
      html += `
          </div>
          <div class="layer-indicators">
              <div class="layer-loading" id="layers-loading" style="display: none;">
                <span class="loading-spinner" aria-hidden="true">⏳</span>
                Chargement des POI...
              </div>
              <div class="layer-error" id="layers-error" style="display: none;" role="alert"></div>
              <div class="layer-info" id="layers-info" style="display: none;"></div>
              <div class="layer-info" id="layers-zoom-info" style="display: none;"></div>
            </div>
        </section>
`;
      return html;
    }

    function attachLayerEventHandlers() {
      const enableAllButton = document.getElementById('layers-enable-all');
      const disableAllButton = document.getElementById('layers-disable-all');
      if (enableAllButton) {
        enableAllButton.addEventListener('click', () => enableAllCategories());
      }
      if (disableAllButton) {
        disableAllButton.addEventListener('click', () => disableAllCategories());
      }
      if (presetSelectElement) {
        presetSelectElement.addEventListener('change', handlePresetChange);
      }
      document.querySelectorAll('.layer-group-header').forEach((header) => {
        header.addEventListener('click', () => {
          const groupId = header.getAttribute('data-group');
          toggleGroupExpanded(groupId);
        });
      });
      document.querySelectorAll('.layer-checkbox').forEach((checkbox) => {
        checkbox.addEventListener('change', handleCategoryCheckboxChange);
      });
    }

    function renderLayersSection() {
      const placeholder = document.getElementById('layers-section-placeholder');
      if (!placeholder) {
        return;
      }
      placeholder.outerHTML = generateLayersHTML();
      layersSectionElement = document.getElementById('layers-section');
      layersLoadingElement = document.getElementById('layers-loading');
      layersErrorElement = document.getElementById('layers-error');
      layersInfoElement = document.getElementById('layers-info');
      layersZoomInfoElement = document.getElementById('layers-zoom-info');
      presetSelectElement = document.getElementById('preset-select');
      attachLayerEventHandlers();
      hideLayersIndicators();
      updateAllPOICounts();
      updatePresetSelection();
      if (window.collapsibleSectionsAPI?.init) {
        window.collapsibleSectionsAPI.init('layers');
      }
      relocateLayerIndicators();
    }

    function ensureLayerGroup(categoryId) {
      if (!poiManager.layerGroups.has(categoryId)) {
        poiManager.layerGroups.set(categoryId, L.layerGroup());
      }
      return poiManager.layerGroups.get(categoryId);
    }

    function setCategoryCheckboxState(categoryId, isChecked) {
      const checkbox = document.getElementById(`layer-${categoryId}`);
      if (checkbox) {
        checkbox.checked = Boolean(isChecked);
      }
    }

    function updateCategoryCountUI(categoryId, count) {
      const element = document.getElementById(`count-${categoryId}`);
      if (!element) {
        return;
      }
      if (count > 0) {
        element.textContent = `(${count})`;
        element.style.display = 'inline';
      } else {
        element.style.display = 'none';
      }
    }

    function updateAllPOICounts() {
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        const count = poiManager.counts.get(categoryId) || 0;
        updateCategoryCountUI(categoryId, count);
      });
    }

    function hideLayersIndicators() {
      hideLayersLoading();
      hideLayersError();
      hideLayersInfo();
      hideLayersZoomInfo();
    }

    function showLayersLoading() {
      if (layersLoadingElement) {
        layersLoadingElement.style.display = 'flex';
      }
    }

    function hideLayersLoading() {
      if (layersLoadingElement) {
        layersLoadingElement.style.display = 'none';
      }
    }

    function showLayersError(message) {
      if (layersErrorElement) {
        layersErrorElement.textContent = `⚠️ ${message}`;
        layersErrorElement.style.display = 'block';
      }
    }

    function hideLayersError() {
      if (layersErrorElement) {
        layersErrorElement.style.display = 'none';
        layersErrorElement.textContent = '';
      }
    }

    function showLayersInfo(message) {
      if (layersInfoElement) {
        layersInfoElement.textContent = message;
        layersInfoElement.style.display = 'block';
      }
    }

    function hideLayersInfo() {
      if (layersInfoElement) {
        layersInfoElement.style.display = 'none';
        layersInfoElement.textContent = '';
      }
    }

    function showLayersZoomInfo(minZoom) {
      if (!layersZoomInfoElement) return;
      // Si le zoom actuel est >= 13, masquer l'info même si appelée
      try {
        if (typeof map !== 'undefined' && map && typeof map.getZoom === 'function') {
          const currentZoom = map.getZoom();
          if (currentZoom >= 13) {
            // s'assurer que l'élément est caché
            layersZoomInfoElement.style.display = 'none';
            layersZoomInfoElement.textContent = '';
            return;
          }
        }
      } catch (e) {
        // ignore errors reading map zoom
      }
      layersZoomInfoElement.textContent = `ℹ️ Zoomez davantage pour voir les POI (zoom ≥ ${minZoom})`;
      layersZoomInfoElement.style.display = 'block';
    }

    function hideLayersZoomInfo() {
      if (layersZoomInfoElement) {
        layersZoomInfoElement.style.display = 'none';
        layersZoomInfoElement.textContent = '';
      }
    }

    function showPoiRefreshButton() {
      if (!poiRefreshButton) {
        return;
      }
      poiRefreshButton.style.display = 'block';
      poiRefreshButton.setAttribute('aria-hidden', 'false');
    }

    function hidePoiRefreshButton() {
      if (!poiRefreshButton) {
        return;
      }
      poiRefreshButton.style.display = 'none';
      poiRefreshButton.setAttribute('aria-hidden', 'true');
    }

    function toggleGroupExpanded(groupId) {
      if (!groupId || !POI_GROUPS[groupId]) {
        return;
      }
      if (poiManager.expandedGroups.has(groupId)) {
        poiManager.expandedGroups.delete(groupId);
      } else {
        poiManager.expandedGroups.add(groupId);
      }
      saveLayerPreferences();
      const groupElement = document.querySelector(`.layer-group[data-group="${groupId}"]`);
      if (groupElement) {
        const header = groupElement.querySelector('.layer-group-header');
        const expanded = poiManager.expandedGroups.has(groupId);
        groupElement.classList.toggle('expanded', expanded);
        if (header) {
          header.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        }
      }
    }

    function handleCategoryCheckboxChange(event) {
      const checkbox = event.target;
      const categoryId = checkbox.getAttribute('data-category');
      setCategoryEnabled(categoryId, checkbox.checked);
    }

    function handlePresetChange(event) {
      const presetId = event.target.value;
      if (!presetId) {
        updatePresetSelection();
        return;
      }
      applyPreset(presetId);
    }

    function updatePresetSelection() {
      if (!presetSelectElement || isApplyingPreset) {
        return;
      }
      const active = Array.from(poiManager.activeCategories).sort();
      let matched = '';
      Object.entries(LAYER_PRESETS).some(([presetId, preset]) => {
        const presetCategories = preset.categories.filter((id) => POI_CATEGORIES[id]).sort();
        if (
          presetCategories.length === active.length &&
          presetCategories.every((value, index) => value === active[index])
        ) {
          matched = presetId;
          return true;
        }
        return false;
      });
      presetSelectElement.value = matched;
    }

    function applyPreset(presetId) {
      const preset = LAYER_PRESETS[presetId];
      if (!preset) {
        return;
      }
      isApplyingPreset = true;
      cancelPendingPOILoad();
      disableAllCategories({ triggerLoad: false, persist: false, skipPresetSync: true });
      preset.categories.forEach((categoryId) => {
        if (POI_CATEGORIES[categoryId]) {
          setCategoryEnabled(categoryId, true, { triggerLoad: false, persist: false, skipPresetSync: true });
        }
      });
      saveLayerPreferences();
      isApplyingPreset = false;
      updatePresetSelection();
      loadPOIForCurrentView(true);
    }

    function enableAllCategories() {
      cancelPendingPOILoad();
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        setCategoryEnabled(categoryId, true, { triggerLoad: false, persist: false, skipPresetSync: true });
      });
      saveLayerPreferences();
      updatePresetSelection();
      loadPOIForCurrentView(true);
    }

    function disableAllCategories(options = {}) {
      const { triggerLoad = true, persist = true, skipPresetSync = false } = options;
      Object.keys(POI_CATEGORIES).forEach((categoryId) => {
        setCategoryEnabled(categoryId, false, { triggerLoad: false, persist: false, skipPresetSync: true });
      });
      if (persist) {
        saveLayerPreferences();
      }
      if (!skipPresetSync) {
        updatePresetSelection();
      }
      if (triggerLoad) {
        clearAllPOILayers();
        hideLayersIndicators();
      }
    }

    function setCategoryEnabled(categoryId, enabled, options = {}) {
      const { triggerLoad = true, persist = true, skipPresetSync = false } = options;
      const category = POI_CATEGORIES[categoryId];
      if (!category) {
        return;
      }
      const isActive = poiManager.activeCategories.has(categoryId);
      if (enabled === isActive) {
        setCategoryCheckboxState(categoryId, enabled);
        return;
      }
      if (enabled) {
        poiManager.activeCategories.add(categoryId);
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
        poiManager.counts.set(categoryId, poiManager.counts.get(categoryId) || 0);
        setCategoryCheckboxState(categoryId, true);
      } else {
        poiManager.activeCategories.delete(categoryId);
        const layerGroup = poiManager.layerGroups.get(categoryId);
        if (layerGroup) {
          layerGroup.clearLayers();
          if (map.hasLayer(layerGroup)) {
            map.removeLayer(layerGroup);
          }
        }
        poiManager.counts.set(categoryId, 0);
        setCategoryCheckboxState(categoryId, false);
      }
      if (persist) {
        saveLayerPreferences();
      }
      if (!skipPresetSync) {
        updatePresetSelection();
      }
      updateCategoryCountUI(categoryId, poiManager.counts.get(categoryId) || 0);
      if (triggerLoad) {
        cancelPendingPOILoad();
        loadPOIForCurrentView(true);
      }
    }

    function clearAllPOILayers() {
      poiManager.layerGroups.forEach((layerGroup, categoryId) => {
        layerGroup.clearLayers();
        if (!poiManager.activeCategories.has(categoryId) && map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
      });
      poiManager.counts.clear();
      updateAllPOICounts();
    }

    function cancelPendingPOILoad() {
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
        poiManager.debounceTimer = null;
      }
      if (poiManager.abortController) {
        poiManager.abortController.abort();
        poiManager.abortController = null;
      }
      poiManager.loading = false;
      hideLayersLoading();
    }

    function getMinZoomForActiveCategories() {
      let minZoom = POI_SETTINGS.minZoomDefault;
      poiManager.activeCategories.forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (category && category.minZoom) {
          minZoom = Math.max(minZoom, category.minZoom);
        }
      });
      return minZoom;
    }

    function isBoundsTooLarge(bounds) {
      const north = bounds.getNorth();
      const south = bounds.getSouth();
      const east = bounds.getEast();
      const west = bounds.getWest();
      const latDiff = Math.abs(north - south);
      const lngDiff = Math.abs(east - west);
      return latDiff * lngDiff > POI_SETTINGS.areaLimitDegSq;
    }

    function handlePOIViewportChange() {
      if (!poiManager.enabled) {
        return;
      }
      // If user zoomed sufficiently, hide the zoom-info alert immediately
      try {
        if (typeof map !== 'undefined' && map && typeof map.getZoom === 'function') {
          if (map.getZoom() >= 13) {
            hideLayersZoomInfo();
          }
        }
      } catch (e) {
        // ignore
      }
      if (poiManager.suppressRefreshPrompt) {
        poiManager.suppressRefreshPrompt = false;
        return;
      }
      if (poiManager.debounceTimer) {
        clearTimeout(poiManager.debounceTimer);
      }
      poiManager.debounceTimer = setTimeout(() => {
        if (poiManager.activeCategories.size === 0 || poiManager.loading) {
          poiManager.refreshPending = false;
          hidePoiRefreshButton();
          return;
        }
        poiManager.refreshPending = true;
        showPoiRefreshButton();
      }, POI_SETTINGS.debounceMs);
    }

    function buildCacheKey(bounds, activeCategories) {
      const precision = 3;
      const boundsKey = [
        bounds.getSouth().toFixed(precision),
        bounds.getWest().toFixed(precision),
        bounds.getNorth().toFixed(precision),
        bounds.getEast().toFixed(precision)
      ].join(',');
      const categoriesKey = Array.from(activeCategories).sort().join(',');
      return `${boundsKey}|${categoriesKey}`;
    }

    function buildMultiCategoryOverpassQuery(bounds, activeCategories) {
      if (!activeCategories || activeCategories.size === 0) {
        return null;
      }
      const south = bounds.getSouth();
      const west = bounds.getWest();
      const north = bounds.getNorth();
      const east = bounds.getEast();
      const bbox = `${south},${west},${north},${east}`;
      const queryParts = [];
      Array.from(activeCategories).forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          return;
        }
        const required = Object.entries(category.tags);
        const excludes = Object.entries(category.excludeTags || {});
        const filters = required
          .map(([key, value]) => `["${key}"="${value}"]`)
          .join('');
        const excludeFilters = excludes
          .map(([key, value]) => `["${key}"!="${value}"]`)
          .join('');
        ['node', 'way', 'relation'].forEach((type) => {
          queryParts.push(`${type}${filters}${excludeFilters};`);
        });
      });
      if (queryParts.length === 0) {
        return null;
      }
      return `
        [out:json][timeout:25][bbox:${bbox}];
        (
          ${queryParts.join('\n          ')}
        );
        out center;
      `.trim();
    }

    async function loadPOIForCurrentView(force = false) {
      if (!poiManager.enabled) {
        return;
      }
      if (poiManager.loading && !force) {
        return;
      }
      if (poiManager.activeCategories.size === 0) {
        clearAllPOILayers();
        hideLayersIndicators();
        return;
      }
      const bounds = map.getBounds();
      const minZoom = getMinZoomForActiveCategories();
      if (map.getZoom() < minZoom) {
        clearAllPOILayers();
        showLayersZoomInfo(minZoom);
        hideLayersLoading();
        return;
      }
      if (isBoundsTooLarge(bounds)) {
        clearAllPOILayers();
        showLayersError('Zone trop grande, veuillez zoomer davantage.');
        hideLayersLoading();
        return;
      }
      hideLayersZoomInfo();
      hideLayersError();
      hideLayersInfo();
      const cacheKey = buildCacheKey(bounds, poiManager.activeCategories);
      const cached = poiCache.get(cacheKey);
      if (cached) {
        displayMultiCategoryPOIs(cached);
        return;
      }
      const requestId = ++poiManager.currentRequestId;
      poiManager.loading = true;
      showLayersLoading();
      try {
        const pois = await fetchPOIsFromOverpass(bounds, poiManager.activeCategories);
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiCache.set(cacheKey, pois);
        poiCache.prune(POI_SETTINGS.maxCacheEntries);
        displayMultiCategoryPOIs(pois);
        poiManager.stats.totalLoaded += pois.length;
        poiManager.stats.requestCount += 1;
      } catch (error) {
        if (error && error.name === 'AbortError') {
          return;
        }
        if (poiManager.currentRequestId !== requestId) {
          return;
        }
        poiManager.stats.errorCount += 1;
        clearAllPOILayers();
        showLayersError(error?.message || 'Impossible de charger les POI.');
      } finally {
        if (poiManager.currentRequestId === requestId) {
          poiManager.loading = false;
          hideLayersLoading();
          poiManager.abortController = null;
        }
      }
    }

    async function enforceRequestThrottle() {
      const now = Date.now();
      const elapsed = now - poiRequestLimiter.lastRequest;
      if (elapsed < poiRequestLimiter.minInterval) {
        await new Promise((resolve) => setTimeout(resolve, poiRequestLimiter.minInterval - elapsed));
      }
      poiRequestLimiter.lastRequest = Date.now();
    }

    async function fetchPOIsFromOverpass(bounds, activeCategories) {
      const query = buildMultiCategoryOverpassQuery(bounds, activeCategories);
      if (!query) {
        return [];
      }
      let lastError = null;
      const activeSnapshot = new Set(activeCategories);
      for (let attempt = 0; attempt <= POI_SETTINGS.maxRetries; attempt++) {
        const endpoint = OVERPASS_ENDPOINTS[attempt % OVERPASS_ENDPOINTS.length];
        const controller = new AbortController();
        poiManager.abortController = controller;
        let timedOut = false;
        const timeoutId = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, POI_SETTINGS.requestTimeoutMs);
        try {
          await enforceRequestThrottle();
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `data=${encodeURIComponent(query)}`,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            if (response.status === 429) {
              lastError = new Error('Trop de requêtes. Veuillez patienter quelques instants.');
            } else if (response.status === 504) {
              lastError = new Error('Timeout du serveur. Essayez de zoomer davantage.');
            } else {
              lastError = new Error(`Erreur HTTP ${response.status}`);
            }
            continue;
          }
          const data = await response.json();
          const elements = Array.isArray(data?.elements) ? data.elements : [];
          const parsed = elements
            .map((element) => parseMultiCategoryPOI(element, activeSnapshot))
            .filter(Boolean);
          return parsed;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            if (timedOut) {
              lastError = new Error('Timeout de la requête');
              continue;
            }
            throw error;
          }
          lastError =
            error instanceof Error
              ? error
              : new Error('Erreur inconnue lors du chargement des POI.');
        } finally {
          if (poiManager.abortController === controller) {
            poiManager.abortController = null;
          }
        }
      }
      throw lastError || new Error('Impossible de récupérer les POI.');
    }

    function parseMultiCategoryPOI(element, activeCategoryIds) {
      if (!element || !element.tags) {
        return null;
      }
      const tags = element.tags;
      let lat;
      let lon;
      if (element.type === 'node') {
        lat = element.lat;
        lon = element.lon;
      } else if (element.center) {
        lat = element.center.lat;
        lon = element.center.lon;
      }
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }
      const orderedCategories = Array.from(activeCategoryIds).sort();
      for (const categoryId of orderedCategories) {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          continue;
        }
        const requiredEntries = Object.entries(category.tags);
        let matches = true;
        for (const [key, value] of requiredEntries) {
          if (tags[key] !== value) {
            matches = false;
            break;
          }
        }
        if (!matches) {
          continue;
        }
        const excludeEntries = Object.entries(category.excludeTags || {});
        let excluded = false;
        for (const [key, value] of excludeEntries) {
          if (tags[key] === value) {
            excluded = true;
            break;
          }
        }
        if (excluded) {
          continue;
        }
        const addressParts = [];
        if (tags['addr:housenumber'] && tags['addr:street']) {
          addressParts.push(`${tags['addr:housenumber']} ${tags['addr:street']}`);
        } else if (tags['addr:street']) {
          addressParts.push(tags['addr:street']);
        }
        if (tags['addr:city']) {
          addressParts.push(tags['addr:city']);
        }
        const metadata = {
          opening_hours: tags.opening_hours || null,
          phone: tags.phone || tags.contact_phone || null,
          website: tags.website || tags.contact_website || null,
          capacity: tags.capacity || null,
          fee: tags.fee || null,
          access: tags.access || null,
          drinking_water: tags.drinking_water || null,
          shower: tags.shower || null,
          toilets: tags.toilets || null,
          cuisine: tags.cuisine || null
        };
        return {
          id: element.id,
          osmType: element.type,
          lat,
          lon,
          categoryId,
          name: tags.name || 'Sans nom',
          address: addressParts.join(', ') || null,
          metadata
        };
      }
      return null;
    }

    function createMultiCategoryPOIMarker(poi, category) {
      if (!poi || !category) {
        return null;
      }
      const icon = L.divIcon({
        className: 'poi-marker',
        html: `
          <div class="poi-marker-inner" style="background-color: ${category.color};">
            <span class="poi-marker-icon">${category.icon}</span>
          </div>
        `,
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      });
      const marker = L.marker([poi.lat, poi.lon], {
        icon,
        opacity: 0.9,
        title: poi.name
      });
      marker.bindPopup(createMultiCategoryPOIPopup(poi, category), {
        maxWidth: 320,
        className: 'poi-popup-container'
      });
      if (poi.name) {
        marker.bindTooltip(poi.name, {
          direction: 'top',
          offset: [0, -14]
        });
      }
      return marker;
    }

    function createMultiCategoryPOIPopup(poi, category) {
      const meta = poi.metadata || {};
      let html = `
        <div class="poi-popup">
          <div class="poi-header">
            <span class="poi-icon" aria-hidden="true">${category.icon}</span>
            <strong class="poi-name">${escapeHtml(poi.name)}</strong>
          </div>
          <div class="poi-details">
            <div class="poi-row">
              <span class="poi-label">Type :</span>
              <span class="poi-value">${escapeHtml(category.label)}</span>
            </div>`;
      if (poi.address) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Adresse :</span>
              <span class="poi-value">${escapeHtml(poi.address)}</span>
            </div>`;
      }
      if (meta.opening_hours) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Horaires :</span>
              <span class="poi-value">${escapeHtml(meta.opening_hours)}</span>
            </div>`;
      }
      if (meta.phone) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Téléphone :</span>
              <span class="poi-value"><a href="tel:${escapeHtml(meta.phone)}">${escapeHtml(meta.phone)}</a></span>
            </div>`;
      }
      if (meta.website) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Site web :</span>
              <span class="poi-value"><a href="${escapeHtml(meta.website)}" target="_blank" rel="noopener">🔗</a></span>
            </div>`;
      }
      if (meta.capacity) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Capacité :</span>
              <span class="poi-value">${escapeHtml(meta.capacity)}</span>
            </div>`;
      }
      if (meta.fee) {
        const feeLabel = meta.fee === 'yes' ? 'Payant' : meta.fee === 'no' ? 'Gratuit' : escapeHtml(meta.fee);
        html += `
            <div class="poi-row">
              <span class="poi-label">Tarif :</span>
              <span class="poi-value">${feeLabel}</span>
            </div>`;
      }
      if (meta.access && meta.access !== 'yes') {
        html += `
            <div class="poi-row">
              <span class="poi-label">Accès :</span>
              <span class="poi-value">${escapeHtml(meta.access)}</span>
            </div>`;
      }
      if (meta.cuisine) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Cuisine :</span>
              <span class="poi-value">${escapeHtml(meta.cuisine)}</span>
            </div>`;
      }
      const services = [];
      if (meta.drinking_water === 'yes') services.push('💧 Eau potable');
      if (meta.shower === 'yes') services.push('🚿 Douches');
      if (meta.toilets === 'yes') services.push('🚻 Toilettes');
      if (services.length > 0) {
        html += `
            <div class="poi-row">
              <span class="poi-label">Services :</span>
              <span class="poi-value">${services.join(' • ')}</span>
            </div>`;
      }
      html += `
          </div>
          <div class="poi-footer">
            <small>
              <a href="https://www.openstreetmap.org/${poi.osmType}/${poi.id}" target="_blank" rel="noopener noreferrer">
                Voir sur OpenStreetMap ↗
              </a>
            </small>
          </div>
        </div>`;
      return html;
    }

    function displayMultiCategoryPOIs(pois) {
      poiManager.counts.clear();
      poiManager.layerGroups.forEach((layerGroup, categoryId) => {
        if (poiManager.activeCategories.has(categoryId)) {
          layerGroup.clearLayers();
        } else if (map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
      });
      if (!Array.isArray(pois) || pois.length === 0) {
        updateAllPOICounts();
        hideLayersInfo();
        return;
      }
      let workingPois = pois.slice();
      let totalLimited = false;
      if (workingPois.length > POI_SETTINGS.maxTotalItems) {
        workingPois = workingPois.slice(0, POI_SETTINGS.maxTotalItems);
        totalLimited = true;
      }
      const grouped = new Map();
      workingPois.forEach((poi) => {
        if (!poi || !poiManager.activeCategories.has(poi.categoryId)) {
          return;
        }
        if (!grouped.has(poi.categoryId)) {
          grouped.set(poi.categoryId, []);
        }
        grouped.get(poi.categoryId).push(poi);
      });
      let categoryLimited = false;
      let total = 0;
      poiManager.activeCategories.forEach((categoryId) => {
        const category = POI_CATEGORIES[categoryId];
        if (!category) {
          return;
        }
        const items = grouped.get(categoryId) || [];
        let limitedItems = items;
        if (items.length > POI_SETTINGS.maxItemsPerCategory) {
          limitedItems = items.slice(0, POI_SETTINGS.maxItemsPerCategory);
          categoryLimited = true;
        }
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
        layerGroup.clearLayers();
        limitedItems.forEach((poi) => {
          const marker = createMultiCategoryPOIMarker(poi, category);
          if (marker) {
            marker.poi = poi;
            layerGroup.addLayer(marker);
          }
        });
        poiManager.counts.set(categoryId, limitedItems.length);
        total += limitedItems.length;
      });
      updateAllPOICounts();
      if (total === 0) {
        hideLayersInfo();
      } else if (totalLimited) {
        showLayersInfo(
          `Trop de points d'intérêt (${pois.length}), limitation à ${POI_SETTINGS.maxTotalItems}. Zoomez pour plus de détails.`
        );
      } else if (categoryLimited) {
        showLayersInfo('Certaines catégories contiennent de nombreux POI. Zoomez pour plus de détails.');
      } else {
        hideLayersInfo();
      }
      poiManager.stats.currentDisplayed = total;
    }

    function initPOIManager() {
      const prefs = loadLayerPreferences();
      poiManager.expandedGroups = prefs ? new Set(prefs.expanded) : getDefaultExpandedGroups();
      poiManager.activeCategories = prefs ? new Set(prefs.active) : getDefaultActiveCategories();
      renderLayersSection();
      poiManager.activeCategories.forEach((categoryId) => {
        const layerGroup = ensureLayerGroup(categoryId);
        if (!map.hasLayer(layerGroup)) {
          layerGroup.addTo(map);
        }
      });
      updatePresetSelection();
      poiManager.enabled = true;
      map.on('moveend', handlePOIViewportChange);
      map.on('zoomend', handlePOIViewportChange);
      if (poiManager.activeCategories.size > 0) {
        loadPOIForCurrentView(true);
      } else {
        hideLayersIndicators();
      }
    }

    const map = L.map('map').setView([48.8566, 2.3522], 12);
  // Expose Leaflet map globally for style control
  window.map = map;


  // Initialiser le contrôle de style AVANT POI/GPX
  requestAnimationFrame(()=>{ if (window.initMapStyleControl) window.initMapStyleControl(); });

    map.zoomControl.setPosition('topright');

    // Couche de tuiles OpenStreetMap avec attribution obligatoire
    const fileInput = document.getElementById('file-input');
    const messageBox = document.getElementById('message');
    const gpxImportZone = document.getElementById('gpx-import-zone');
    const gpxEmptyState = document.getElementById('gpx-empty-state');
    const gpxLoadedState = document.getElementById('gpx-loaded-state');
    const gpxTraceFilename = document.getElementById('gpx-trace-filename');
    const gpxTraceDistance = document.getElementById('gpx-trace-distance');
    const gpxTraceElevation = document.getElementById('gpx-trace-elevation');
    const exportActionButton = document.getElementById('gpx-export-action');
    const replaceActionButton = document.getElementById('gpx-replace-action');
    const clearTraceButton = document.getElementById('clear-trace-button');
    const exportModal = document.getElementById('export-modal');
    const exportModalBackdrop = document.getElementById('export-modal-backdrop');
    const exportModalClose = document.getElementById('export-modal-close');
    const exportModalCancel = document.getElementById('export-modal-cancel');
    const exportModalDownload = document.getElementById('export-modal-download');
    const exportFileNameInput = document.getElementById('export-file-name');
    const exportIncludeWaypoints = document.getElementById('export-include-waypoints');
    const exportPreviewName = document.getElementById('export-preview-name');
    const exportWaypointsLabel = document.getElementById('export-waypoints-label');
    const toolsPanel = document.getElementById('tools-panel');
    const menuToggle = document.getElementById('menu-toggle');
    const closePanel = document.getElementById('close-panel');
    const traceFileNameLabel = document.getElementById('file-name');
    const waypointsSection = document.getElementById('waypoints-section');
    const waypointsList = document.getElementById('waypoints-list');
    const waypointCountLabel = document.getElementById('waypoint-count');
    const clearWaypointsButton = document.getElementById('clear-waypoints');
    const traceInfoSection = document.getElementById('trace-info-section');
    const traceNameLabel = document.getElementById('trace-name');
    const pointCountLabel = document.getElementById('point-count');
    const traceTypeLabel = document.getElementById('trace-type');
    const traceDistanceLabel = document.getElementById('trace-distance');
    const traceElevationGainLabel = document.getElementById('trace-elevation-gain');
    const traceElevationLossLabel = document.getElementById('trace-elevation-loss');
    const traceAltitudeRangeLabel = document.getElementById('trace-altitude-range');
    const ariaDistance = document.getElementById('aria-distance');
    const ariaDPlus = document.getElementById('aria-d-plus');
    const ariaMin = document.getElementById('aria-min');
    const ariaMax = document.getElementById('aria-max');
    const profileDistanceValue = document.getElementById('profile-distance');
    const profileElevationGainValue = document.getElementById('profile-elevation-gain');
    const profileElevationLossValue = document.getElementById('profile-elevation-loss');
    const elevationProfile = document.getElementById('elevation-profile');
    const elevationHeader = document.getElementById('elevation-header');
    const elevationCollapseButton = document.getElementById('elevation-collapse');
    const elevationContent = document.getElementById('elevation-content');
    const elevationCanvas = document.getElementById('elevation-canvas');
    const elevationTooltip = document.getElementById('elevation-tooltip');
    const poiRefreshButton = document.getElementById('poi-refresh-button');
    const miniElevationProfile = document.getElementById('mini-elevation-profile');
    const miniElevationCanvas = document.getElementById('mini-elevation-canvas');
    const miniAriaMin = document.getElementById('mini-aria-min');
    const miniAriaMax = document.getElementById('mini-aria-max');

    // Activer le bouton "Recharger les POI"
    if (poiRefreshButton) {
      poiRefreshButton.addEventListener('click', () => {
        // Réinitialise l'état et recharge les POI pour la vue courante
        poiManager.refreshPending = false;
        hidePoiRefreshButton();
        loadPOIForCurrentView(true);
      });
    }


    let backdropElement = null;

    const waypointLayerGroup = L.layerGroup().addTo(map);
// === PERSISTENCE WAYPOINTS — debounce & group hooks (defined early) ===
if (typeof window.__saveWpTimer === 'undefined') window.__saveWpTimer = null;
function saveTraceDebounced(delay = 120) {
  if (typeof saveTraceToLocalStorage !== 'function') return;
  clearTimeout(window.__saveWpTimer);
  window.__saveWpTimer = setTimeout(() => {
    try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); }
  }, delay);
}
function attachWaypointPersistence() {
  try {
    if (!waypointLayerGroup || typeof waypointLayerGroup.on !== 'function') return;
    waypointLayerGroup.off('layeradd', saveTraceDebounced);
    waypointLayerGroup.off('layerremove', saveTraceDebounced);
    waypointLayerGroup.on('layeradd', () => saveTraceDebounced());
    waypointLayerGroup.on('layerremove', () => saveTraceDebounced());
    saveTraceDebounced(10);
  } catch (e) { console.warn('attachWaypointPersistence:', e); }
}
// Attach once after map init
attachWaypointPersistence();
    let waypointCounter = 1;

let gpxLayerGroup = null;
let arrowLayerGroup = null;
let currentGpxDocument = null;
let currentGpxFileName = '';
let currentGeojson = null;
let currentTraceName = '';
let traceNameSource = '';

// Exposer les variables importantes sur window pour la sauvegarde
window.currentGpxDocument = null;
window.currentGpxFileName = '';
window.currentTraceName = '';
window.traceNameSource = '';
let currentElevationData = null;
let elevationHoverMarker = null;
let elevationMouseMoveHandler = null;
let elevationMouseLeaveHandler = null;


    setExportAvailability(false);
    updateWaypointsList();
    updateTraceInfo(null);

    // Debounced refresh of elevation profiles when waypoints change
    if (typeof window.__refreshProfileTimer === 'undefined') window.__refreshProfileTimer = null;
    function refreshElevationProfiles(delay = 120) {
      clearTimeout(window.__refreshProfileTimer);
      window.__refreshProfileTimer = setTimeout(() => {
        try {
          // redraw main profile and mini profile
          if (typeof renderElevationProfile === 'function') {
            renderElevationProfile();
          }
          if (typeof updateMiniElevationProfile === 'function') {
            updateMiniElevationProfile();
          }
        } catch (e) {
          console.warn('refreshElevationProfiles:', e);
        }
      }, delay);
    }

    /**
     * Affiche un message utilisateur discret.
     * @param {string} text
     * @param {boolean} isError
     */
    function showMessage(text, isError = false, isHtml = false) {
      if (!messageBox) {
        return;
      }
      const content = text == null ? '' : String(text);
      const trimmed = content.trim();
      if (!trimmed) {
        messageBox.classList.add('hidden');
        messageBox.textContent = '';
        messageBox.classList.remove('error');
        return;
      }
      if (isHtml) {
        messageBox.innerHTML = content;
      } else {
        messageBox.textContent = trimmed;
      }
      messageBox.classList.remove('hidden');
      messageBox.classList.toggle('error', Boolean(isError));
    }

    /**
     * Efface les couches GPX précédemment ajoutées.
     */
    function clearPreviousLayers() {  try { removeTraceEndpointMarkers(); } catch(e) { console.warn('removeTraceEndpointMarkers:', e); }

      if (gpxLayerGroup) {
        map.removeLayer(gpxLayerGroup);
        gpxLayerGroup = null;
      }
      if (arrowLayerGroup) {
        map.removeLayer(arrowLayerGroup);
        arrowLayerGroup = null;
      }
      waypointLayerGroup.clearLayers();
      waypointCounter = 1;
      currentGeojson = null;
      updateWaypointsList();
      updateTraceInfo(null);
      resetElevationDisplay();
    }

    function setExportAvailability(isEnabled) {
      const hasTrace = Boolean(isEnabled);
      if (exportActionButton) {
        exportActionButton.disabled = !hasTrace;
      }
      if (replaceActionButton) {
        replaceActionButton.disabled = !hasTrace;
      }
      if (clearTraceButton) {
        clearTraceButton.disabled = !hasTrace;
        if (typeof clearTraceButton.__resetConfirmState === 'function') {
          clearTraceButton.__resetConfirmState();
        }
      }
      if (gpxEmptyState) {
        gpxEmptyState.classList.toggle('hidden', hasTrace);
      }
      if (gpxLoadedState) {
        gpxLoadedState.classList.toggle('hidden', !hasTrace);
      }
      if (!hasTrace) {
        if (gpxTraceFilename) {
          gpxTraceFilename.textContent = 'Aucune trace chargée';
        }
        if (gpxTraceDistance) {
          gpxTraceDistance.textContent = '—';
        }
        if (gpxTraceElevation) {
          gpxTraceElevation.textContent = '—';
        }
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '—';
        }
        resetElevationDisplay();
      } else if (traceFileNameLabel && currentGpxFileName) {
        traceFileNameLabel.textContent = currentGpxFileName;
      }
    }

    function normalizeLatLngSegments(latlngs) {
      if (!Array.isArray(latlngs)) {
        return [];
      }
      if (latlngs.length === 0) {
        return [];
      }
      const first = latlngs[0];
      if (Array.isArray(first)) {
        return latlngs;
      }
      return [latlngs];
    }

    function computeBearingDegrees(startLatLng, endLatLng) {
      const toRadians = (value) => (value * Math.PI) / 180;
      const toDegrees = (value) => (value * 180) / Math.PI;
      const phi1 = toRadians(startLatLng.lat);
      const phi2 = toRadians(endLatLng.lat);
      const deltaLambda = toRadians(endLatLng.lng - startLatLng.lng);
      const y = Math.sin(deltaLambda) * Math.cos(phi2);
      const x =
        Math.cos(phi1) * Math.sin(phi2) -
        Math.sin(phi1) * Math.cos(phi2) * Math.cos(deltaLambda);
      const theta = Math.atan2(y, x);
      return (toDegrees(theta) + 360) % 360;
    }

    function escapeHtml(value) {
      if (value === null || value === undefined) {
        return '';
      }
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function sanitizeFileName(name) {
      if (!name) {
        return 'trace';
      }
      const sanitized =
        name
          .replace(/[<>:"/\\|?*]/g, '_')
          .replace(/\s+/g, '_')
          .replace(/_+/g, '_')
          .replace(/^_|_$/g, '')
          .substring(0, 100) || 'trace';
      return sanitized;
    }

    function extractTraceName(xmlDoc, fileName) {
      if (xmlDoc) {
        const trackNames = xmlDoc.querySelectorAll('trk > name');
        for (const trackName of trackNames) {
          const value = trackName.textContent && trackName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-track' };
          }
        }

        const routeNames = xmlDoc.querySelectorAll('rte > name');
        for (const routeName of routeNames) {
          const value = routeName.textContent && routeName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-route' };
          }
        }

        const metadataName = xmlDoc.querySelector('metadata > name');
        if (metadataName) {
          const value = metadataName.textContent && metadataName.textContent.trim();
          if (value) {
            return { name: value, source: 'gpx-metadata' };
          }
        }
      }

      if (fileName) {
        const withoutExtension = fileName.replace(/\.gpx$/i, '');
        if (withoutExtension.trim()) {
          return { name: withoutExtension.trim(), source: 'filename' };
        }
      }

      return { name: 'Trace sans nom', source: 'default' };
    }

    function displayTraceName(traceName, source) {
      if (!traceNameLabel) {
        return;
      }
      const safeName = traceName || '—';
      traceNameLabel.textContent = safeName;
      let tooltip = '';
      switch (source) {
        case 'gpx-track':
        case 'gpx-route':
        case 'gpx-metadata':
          tooltip = 'Nom extrait du fichier GPX';
          break;
        case 'filename':
          tooltip = 'Nom basé sur le nom de fichier';
          break;
        case 'default':
        default:
          tooltip = 'Nom par défaut (aucune information disponible)';
          break;
      }
      traceNameLabel.setAttribute('title', tooltip);
      traceNameLabel.className = `trace-name trace-name--${source || 'default'}`;
    }

    function haversineDistance(pointA, pointB) {
      if (!pointA || !pointB) {
        return 0;
      }
      const R = 6371000;
      const lat1 = (pointA.lat * Math.PI) / 180;
      const lat2 = (pointB.lat * Math.PI) / 180;
      const dLat = ((pointB.lat - pointA.lat) * Math.PI) / 180;
      const dLng = ((pointB.lng - pointA.lng) * Math.PI) / 180;

      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function calculateElevationStats(points) {
      if (!Array.isArray(points) || points.length === 0) {
        return null;
      }

      let elevationGain = 0;
      let elevationLoss = 0;
      let minElevation = Infinity;
      let maxElevation = -Infinity;
      let sumElevation = 0;

      points.forEach((point, index) => {
        const elevation = point.elevation;
        if (elevation < minElevation) {
          minElevation = elevation;
        }
        if (elevation > maxElevation) {
          maxElevation = elevation;
        }
        sumElevation += elevation;

        if (index > 0) {
          const diff = elevation - points[index - 1].elevation;
          if (diff > 0) {
            elevationGain += diff;
          } else if (diff < 0) {
            elevationLoss += Math.abs(diff);
          }
        }
      });

      return {
        totalDistance: Math.round(points[points.length - 1].distance),
        elevationGain: Math.round(elevationGain),
        elevationLoss: Math.round(elevationLoss),
        minElevation: Math.round(minElevation),
        maxElevation: Math.round(maxElevation),
        avgElevation: Math.round(sumElevation / points.length)
      };
    }

    function simplifyElevationData(points, maxPoints = 1500) {
      if (!Array.isArray(points) || points.length <= maxPoints) {
        return points || [];
      }
      const step = Math.max(1, Math.floor(points.length / maxPoints));
      const simplified = [];
      for (let i = 0; i < points.length; i += step) {
        simplified.push(points[i]);
      }
      if (simplified[simplified.length - 1] !== points[points.length - 1]) {
        simplified.push(points[points.length - 1]);
      }
      return simplified;
    }

    function extractElevationData(geojson, gpxDoc) {
      if (!geojson || !Array.isArray(geojson.features) || !gpxDoc) {
        return null;
      }

      const trackPoints = Array.from(gpxDoc.querySelectorAll('trkpt, rtept'));
      const elevationMap = new Map();
      trackPoints.forEach((trkpt) => {
        const lat = parseFloat(trkpt.getAttribute('lat'));
        const lng = parseFloat(trkpt.getAttribute('lon'));
        const eleNode = trkpt.querySelector('ele');
        if (!Number.isFinite(lat) || !Number.isFinite(lng) || !eleNode) {
          return;
        }
        const elevation = parseFloat(eleNode.textContent);
        if (!Number.isFinite(elevation)) {
          return;
        }
        const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
        elevationMap.set(key, elevation);
      });

      if (elevationMap.size === 0) {
        return null;
      }

      const points = [];
      let previousPoint = null;
      let cumulativeDistance = 0;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
          const elevation = elevationMap.get(key);
          if (!Number.isFinite(elevation)) {
            previousPoint = { lat, lng };
            return;
          }

          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }

          points.push({
            distance: cumulativeDistance,
            elevation,
            lat,
            lng,
            index: points.length
          });

          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (points.length < 2) {
        return null;
      }

      const stats = calculateElevationStats(points);
      if (!stats) {
        return null;
      }

      const simplifiedPoints = simplifyElevationData(points);
      return { points: simplifiedPoints, stats };
    }

    function calculateDistanceOnly(geojson) {
      if (!geojson || !Array.isArray(geojson.features)) {
        return null;
      }
      let cumulativeDistance = 0;
      let previousPoint = null;

      const processCoordinates = (coords) => {
        coords.forEach((coord) => {
          if (!Array.isArray(coord) || coord.length < 2) {
            return;
          }
          const [lng, lat] = coord;
          const currentPoint = { lat, lng };
          if (previousPoint) {
            cumulativeDistance += haversineDistance(previousPoint, currentPoint);
          }
          previousPoint = currentPoint;
        });
      };

      geojson.features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        previousPoint = null;
        if (geometry.type === 'LineString') {
          processCoordinates(geometry.coordinates || []);
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            previousPoint = null;
            processCoordinates(segment || []);
          });
        }
      });

      if (cumulativeDistance === 0) {
        return null;
      }
      return { distance: cumulativeDistance };
    }

    function updateElevationStats(stats) {
      if (
        !traceDistanceLabel ||
        !traceElevationGainLabel ||
        !traceElevationLossLabel ||
        !traceAltitudeRangeLabel ||
        !profileDistanceValue ||
        !profileElevationGainValue ||
        !profileElevationLossValue
      ) {
        return;
      }

      if (!stats) {
        traceDistanceLabel.textContent = '—';
        traceElevationGainLabel.textContent = '—';
        traceElevationLossLabel.textContent = '—';
        traceAltitudeRangeLabel.textContent = '—';
        profileDistanceValue.textContent = '—';
        profileElevationGainValue.textContent = '—';
        profileElevationLossValue.textContent = '—';
        if (ariaDistance) ariaDistance.textContent = '—';
        if (ariaDPlus) ariaDPlus.textContent = '—';
        if (ariaMin) ariaMin.textContent = '—';
        if (ariaMax) ariaMax.textContent = '—';
        if (gpxTraceDistance) gpxTraceDistance.textContent = '—';
        if (gpxTraceElevation) gpxTraceElevation.textContent = '—';
        if (elevationProfile) {
          elevationProfile.classList.remove('visible');
          elevationProfile.setAttribute('aria-hidden', 'true');
        }
        updateMiniElevationProfile();
        return;
      }

      const distanceKm = stats.totalDistance / 1000;
      const distanceLabel = `${distanceKm.toFixed(2)} km`;
      traceDistanceLabel.textContent = distanceLabel;
      traceElevationGainLabel.textContent = `${stats.elevationGain} m`;
      traceElevationLossLabel.textContent = `${stats.elevationLoss} m`;
      traceAltitudeRangeLabel.textContent = `${stats.minElevation} m - ${stats.maxElevation} m`;
      if (gpxTraceDistance) {
        gpxTraceDistance.textContent = distanceLabel;
      }
      if (gpxTraceElevation) {
        gpxTraceElevation.textContent = `D+ ${stats.elevationGain} m`;
      }

      profileDistanceValue.textContent = `${distanceKm.toFixed(2)} km`;
      profileElevationGainValue.textContent = `${stats.elevationGain} m`;
      profileElevationLossValue.textContent = `${stats.elevationLoss} m`;

      if (ariaDistance) ariaDistance.textContent = `${distanceKm.toFixed(2)} km`;
      if (ariaDPlus) ariaDPlus.textContent = `${stats.elevationGain} m`;
      if (ariaMin) ariaMin.textContent = `${stats.minElevation} m`;
      if (ariaMax) ariaMax.textContent = `${stats.maxElevation} m`;

      if (elevationProfile) {
        elevationProfile.classList.add('visible');
        elevationProfile.setAttribute('aria-hidden', 'false');
      }
      updateMiniElevationProfile();
    }

    function resetElevationDisplay() {
      currentElevationData = null;
      if (elevationHoverMarker) {
        map.removeLayer(elevationHoverMarker);
        elevationHoverMarker = null;
      }
      removeElevationInteraction();
      updateElevationStats(null);
      if (elevationTooltip) {
        elevationTooltip.style.display = 'none';
      }
      if (elevationContent && elevationCanvas) {
        const ctx = elevationCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, elevationCanvas.width, elevationCanvas.height);
        }
      }
      if (elevationProfile) {
        elevationProfile.classList.remove('collapsed');
        elevationProfile.setAttribute('aria-hidden', 'true');
      }
      if (elevationCollapseButton) {
        elevationCollapseButton.setAttribute('aria-expanded', 'true');
        elevationCollapseButton.setAttribute('aria-label', 'Réduire le profil');
      }
      map.invalidateSize();
      if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
        window.roadbookManager.update();
      }
    }

    function drawElevationProfile(canvas, points, stats) {
      if (!canvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return;
      }

      const width = canvas.width;
      const height = canvas.height;

      ctx.clearRect(0, 0, width, height);

      const margin = { top: 20, right: 20, bottom: 40, left: 60 };
      const chartWidth = Math.max(10, width - margin.left - margin.right);
      const chartHeight = Math.max(10, height - margin.top - margin.bottom);
      const maxDistance = stats.totalDistance || 1;
      const minEle = stats.minElevation - 20;
      const maxEle = stats.maxElevation + 20;

      const xScale = (distance) =>
        margin.left + (Math.min(distance, maxDistance) / maxDistance) * chartWidth;
      const yScale = (elevation) =>
        margin.top + chartHeight - ((elevation - minEle) / (maxEle - minEle)) * chartHeight;

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.lineWidth = 1;

      const elevationStep = Math.max(10, Math.ceil((maxEle - minEle) / 5 / 50) * 50);
      for (let ele = Math.ceil(minEle / elevationStep) * elevationStep; ele <= maxEle; ele += elevationStep) {
        const y = yScale(ele);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(width - margin.right, y);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(`${Math.round(ele)} m`, margin.left - 5, y + 4);
      }

      const distanceStepRaw = Math.max(100, Math.ceil(maxDistance / 5 / 1000) * 1000);
      for (let dist = 0; dist <= maxDistance; dist += distanceStepRaw) {
        const x = xScale(dist);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, height - margin.bottom);
        ctx.stroke();
        ctx.fillStyle = '#757575';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${(dist / 1000).toFixed(1)} km`, x, height - margin.bottom + 18);
      }

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.lineTo(xScale(points[points.length - 1].distance), height - margin.bottom);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, margin.top, 0, height - margin.bottom);
      gradient.addColorStop(0, 'rgba(25, 118, 210, 0.3)');
      gradient.addColorStop(1, 'rgba(25, 118, 210, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.strokeStyle = '#1976d2';
      ctx.lineWidth = 2;
      ctx.stroke();

      // --- Draw waypoints on profile ---
      try {
        if (typeof getWaypointMarkers === 'function') {
          const markers = getWaypointMarkers() || [];
          if (Array.isArray(markers) && markers.length > 0) {
            markers.forEach((marker, mi) => {
              try {
                const latlng = marker.getLatLng ? marker.getLatLng() : null;
                if (!latlng) return;

                // find the closest elevation point by geographic distance
                let closest = null;
                let closestDist = Infinity;
                for (let i = 0; i < points.length; i++) {
                  const p = points[i];
                  const d = haversineDistance({ lat: p.lat, lng: p.lng }, { lat: latlng.lat, lng: latlng.lng });
                  if (d < closestDist) {
                    closestDist = d;
                    closest = p;
                  }
                }
                if (!closest) return;

                const x = xScale(closest.distance);
                const y = yScale(closest.elevation);

                // vertical tick
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255,87,34,0.9)';
                ctx.lineWidth = 1;
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, height - margin.bottom);
                ctx.stroke();

                // small circle marker on the profile line
                ctx.beginPath();
                ctx.fillStyle = '#FF5722';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // label (waypoint name or index)
                const label = marker.waypointName || `WP ${mi + 1}`;
                ctx.fillStyle = '#212121';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                // draw background for readability
                const textWidth = ctx.measureText(label).width;
                ctx.fillStyle = 'rgba(255,255,255,0.85)';
                ctx.fillRect(x - textWidth / 2 - 6, margin.top + 4, textWidth + 12, 18);
                ctx.fillStyle = '#212121';
                ctx.fillText(label, x, margin.top + 16);
              } catch (e) {
                // ignore marker-specific errors
              }
            });
          }
        }
      } catch (e) {
        // ignore rendering errors so profile still draws
      }

      ctx.fillStyle = '#424242';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Distance (km)', width / 2, height - 8);

      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Altitude (m)', 0, 0);
      ctx.restore();
    }

    function drawMiniElevationProfile(canvas, points, stats) {
      if (!canvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      const parentWidth = canvas.offsetWidth || canvas.parentElement?.offsetWidth || 0;
      const parentHeight = canvas.offsetHeight || canvas.parentElement?.offsetHeight || 0;
      if (!parentWidth || !parentHeight) {
        return;
      }

      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(parentWidth * dpr);
      canvas.height = Math.floor(parentHeight * dpr);

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return;
      }

      ctx.save();
      ctx.scale(dpr, dpr);

      const width = parentWidth;
      const height = parentHeight;

      ctx.clearRect(0, 0, width, height);

      const margin = { top: 10, right: 10, bottom: 25, left: 40 };
      const chartWidth = Math.max(10, width - margin.left - margin.right);
      const chartHeight = Math.max(10, height - margin.top - margin.bottom);

      const maxDistance = stats.totalDistance || 1;
      const minEle = Math.min(stats.minElevation, stats.maxElevation) - 20;
      const maxEle = Math.max(stats.minElevation, stats.maxElevation) + 20;
      const range = Math.max(1, maxEle - minEle);

      const xScale = (distance) =>
        margin.left + (Math.min(distance, maxDistance) / maxDistance) * chartWidth;
      const yScale = (elevation) =>
        margin.top + chartHeight - ((elevation - minEle) / range) * chartHeight;

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.lineWidth = 1;
      const elevationSteps = 2;
      for (let i = 0; i <= elevationSteps; i++) {
        const ele = minEle + (range * i) / elevationSteps;
        const y = yScale(ele);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(width - margin.right, y);
        ctx.stroke();
        ctx.fillStyle = '#999';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(`${Math.round(ele)}m`, margin.left - 5, y + 3);
      }

      ctx.fillStyle = '#999';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('0km', margin.left, height - 5);
      ctx.fillText(`${(maxDistance / 1000).toFixed(1)}km`, width - margin.right, height - 5);

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.lineTo(xScale(points[points.length - 1].distance), height - margin.bottom);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, margin.top, 0, height - margin.bottom);
      gradient.addColorStop(0, 'rgba(25, 118, 210, 0.15)');
      gradient.addColorStop(1, 'rgba(25, 118, 210, 0.02)');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.strokeStyle = '#1976d2';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Draw compact waypoint markers on mini profile
      try {
        if (typeof getWaypointMarkers === 'function') {
          const markers = getWaypointMarkers() || [];
          markers.forEach((marker) => {
            try {
              const latlng = marker.getLatLng ? marker.getLatLng() : null;
              if (!latlng) return;
              let closest = null;
              let closestDist = Infinity;
              for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const d = haversineDistance({ lat: p.lat, lng: p.lng }, { lat: latlng.lat, lng: latlng.lng });
                if (d < closestDist) {
                  closestDist = d;
                  closest = p;
                }
              }
              if (!closest) return;
              const x = xScale(closest.distance);
              const y = yScale(closest.elevation);
              // tiny tick
              ctx.beginPath();
              ctx.strokeStyle = 'rgba(255,87,34,0.9)';
              ctx.lineWidth = 1;
              ctx.moveTo(x, y - 6);
              ctx.lineTo(x, y + 6);
              ctx.stroke();
              // small dot
              ctx.beginPath();
              ctx.fillStyle = '#FF5722';
              ctx.arc(x, y, 3, 0, Math.PI * 2);
              ctx.fill();
            } catch (e) {}
          });
        }
      } catch (e) {}

      ctx.restore();
    }

    function updateMiniElevationProfile() {
      if (!miniElevationProfile || !miniElevationCanvas) {
        return;
      }

      const hasData =
        currentElevationData &&
        Array.isArray(currentElevationData.points) &&
        currentElevationData.points.length >= 2 &&
        currentElevationData.stats;

      if (!hasData) {
        miniElevationProfile.style.display = 'none';
        if (miniAriaMin) miniAriaMin.textContent = '—';
        if (miniAriaMax) miniAriaMax.textContent = '—';
        return;
      }

      const simplified =
        typeof simplifyElevationData === 'function'
          ? simplifyElevationData(currentElevationData.points, 150)
          : currentElevationData.points;

      if (!Array.isArray(simplified) || simplified.length < 2) {
        miniElevationProfile.style.display = 'none';
        return;
      }

      miniElevationProfile.style.display = 'block';
      const stats = currentElevationData.stats;
      if (miniAriaMin) {
        miniAriaMin.textContent = Number.isFinite(stats.minElevation)
          ? `${stats.minElevation} m`
          : '—';
      }
      if (miniAriaMax) {
        miniAriaMax.textContent = Number.isFinite(stats.maxElevation)
          ? `${stats.maxElevation} m`
          : '—';
      }

      requestAnimationFrame(() => {
        drawMiniElevationProfile(miniElevationCanvas, simplified, stats);
      });
    }

    function renderElevationProfile() {
      if (
        !currentElevationData ||
        !currentElevationData.points ||
        !currentElevationData.stats ||
        !elevationCanvas ||
        !elevationProfile
      ) {
        return;
      }
      if (
        elevationProfile.classList.contains('collapsed') ||
        !elevationProfile.classList.contains('visible')
      ) {
        return;
      }
      sizeCanvasToParent();
      drawElevationProfile(elevationCanvas, currentElevationData.points, currentElevationData.stats);
      setupElevationInteraction(currentElevationData.points, currentElevationData.stats);
    }

    function findClosestElevationPoint(canvas, points, stats, event) {
      if (!canvas || !points || !stats) {
        return null;
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const margin = { left: 60, right: 20 };
      const chartWidth = canvas.width - margin.left - margin.right;
      const relativeX = x - margin.left;
      if (relativeX < 0 || relativeX > chartWidth) {
        return null;
      }
      const distance = (relativeX / chartWidth) * stats.totalDistance;
      let closestPoint = points[0];
      let minDiff = Math.abs(points[0].distance - distance);
      for (let i = 1; i < points.length; i++) {
        const diff = Math.abs(points[i].distance - distance);
        if (diff < minDiff) {
          minDiff = diff;
          closestPoint = points[i];
        }
      }
      return { point: closestPoint, canvasX: x };
    }

    function removeElevationInteraction() {
      if (!elevationCanvas) {
        return;
      }
      if (elevationMouseMoveHandler) {
        elevationCanvas.removeEventListener('mousemove', elevationMouseMoveHandler);
      }
      if (elevationMouseLeaveHandler) {
        elevationCanvas.removeEventListener('mouseleave', elevationMouseLeaveHandler);
      }
      elevationMouseMoveHandler = null;
      elevationMouseLeaveHandler = null;
    }

    function setupElevationInteraction(points, stats) {
      if (!elevationCanvas || !Array.isArray(points) || points.length < 2 || !stats) {
        return;
      }

      removeElevationInteraction();

      elevationMouseMoveHandler = (event) => {
        const result = findClosestElevationPoint(elevationCanvas, points, stats, event);
        if (!result) {
          if (elevationTooltip) {
            elevationTooltip.style.display = 'none';
          }
          if (elevationHoverMarker) {
            map.removeLayer(elevationHoverMarker);
            elevationHoverMarker = null;
          }
          return;
        }

        const { point, canvasX } = result;
        if (elevationTooltip) {
          const rect = elevationCanvas.getBoundingClientRect();
          elevationTooltip.style.display = 'block';
          elevationTooltip.style.left = `${canvasX + 15}px`;
          elevationTooltip.style.top = `${event.clientY - rect.top + 15}px`;
          const distanceElement = document.getElementById('tooltip-distance');
          const elevationElement = document.getElementById('tooltip-elevation');
          if (distanceElement) {
            distanceElement.textContent = `${(point.distance / 1000).toFixed(2)} km`;
          }
          if (elevationElement) {
            elevationElement.textContent = `${point.elevation.toFixed(0)} m`;
          }
        }

        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
        }
        elevationHoverMarker = L.circleMarker([point.lat, point.lng], {
          radius: 7,
          fillColor: '#ff5722',
          fillOpacity: 0.9,
          color: '#ffffff',
          weight: 2,
          interactive: false
        }).addTo(map);
      };

      elevationMouseLeaveHandler = () => {
        if (elevationTooltip) {
          elevationTooltip.style.display = 'none';
        }
        if (elevationHoverMarker) {
          map.removeLayer(elevationHoverMarker);
          elevationHoverMarker = null;
        }
      };

      elevationCanvas.addEventListener('mousemove', elevationMouseMoveHandler);
      elevationCanvas.addEventListener('mouseleave', elevationMouseLeaveHandler);
    }

    function setElevationCollapsed(collapsed) {
      if (!elevationProfile || !elevationCollapseButton) {
        return;
      }
      if (!elevationProfile.classList.contains('visible') && !collapsed) {
        return;
      }

      elevationProfile.classList.toggle('collapsed', collapsed);
      elevationCollapseButton.setAttribute('aria-expanded', String(!collapsed));
      elevationCollapseButton.setAttribute(
        'aria-label',
        collapsed ? 'Agrandir le profil' : 'Réduire le profil'
      );

      if (!collapsed) {
        requestAnimationFrame(() => {
          renderElevationProfile();
          map.invalidateSize();
        });
      } else {
        removeElevationInteraction();
        map.invalidateSize();
      }
    }

    function createWaypointPopupHtml(name) {
      const safeName = escapeHtml(name);
      return `
        <div class="waypoint-popup">
          <label for="waypoint-name-input">Nom du waypoint</label>
          <input id="waypoint-name-input" class="waypoint-name-input" type="text" value="${safeName}" />
          <div class="waypoint-popup-buttons">
            <button type="button" data-action="save">Enregistrer</button>
            <button type="button" data-action="delete">Supprimer</button>
          </div>
        </div>
      `;
    }

    function attachWaypointPopupHandlers(marker, popup) {
      const container = popup.getElement();
      if (!container) {
        return;
      }

      const input = container.querySelector('.waypoint-name-input');
      if (input) {
        input.value = marker.waypointName;
        input.focus();
        input.select();
      }

      const saveAction = () => {
        const newName = input && input.value.trim() ? input.value.trim() : marker.waypointName;
        marker.waypointName = newName;
        marker.setPopupContent(createWaypointPopupHtml(marker.waypointName));
        marker.openPopup();
        updateWaypointsList();
        try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
      };

      const deleteAction = () => {
        waypointLayerGroup.removeLayer(marker);
        map.closePopup(popup);
        updateWaypointsList();
        try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
      
        // Sauvegarde immédiate (sans debounce) pour figer l’état
        if (typeof saveTraceToLocalStorage === 'function') {
          try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); }
        }
      };

      if (input) {
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveAction();
          }
        });
      }

      const saveButton = container.querySelector('[data-action="save"]');
      if (saveButton) {
        saveButton.addEventListener('click', saveAction);
      }

      const deleteButton = container.querySelector('[data-action="delete"]');
      if (deleteButton) {
        deleteButton.addEventListener('click', deleteAction);
      }
    }

    
function createWaypointMarker(latlng, name = '') {
  const trimmedName = name && name.trim() ? name.trim() : '';
  const finalName = trimmedName || `Waypoint ${waypointCounter}`;
  waypointCounter += 1;

  // Créer l'icône personnalisée
  const icon = L.divIcon({
    className: 'waypoint-marker',
    html: `
      <div class="waypoint-marker-inner">
        <div class="waypoint-marker-pin">
          <span class="waypoint-marker-icon">📍</span>
        </div>
      </div>
    `,
    iconSize: [28, 36],
    iconAnchor: [14, 36],
    popupAnchor: [0, -36]
  });

  const marker = L.marker(latlng, { 
    icon: icon,
    draggable: false, 
    bubblingMouseEvents: false,
    riseOnHover: true
  });
  
  marker.waypointName = finalName;
  marker.bindPopup(createWaypointPopupHtml(finalName));
  marker.on('popupopen', (event) => {
    attachWaypointPopupHandlers(marker, event.popup);
  });
  marker.bindTooltip(
    () => marker.waypointName,
    {
      direction: 'top',
      offset: [0, -36]
    }
  );

  waypointLayerGroup.addLayer(marker);
  updateWaypointsList();
  try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
  
  if (typeof marker.on === 'function') {
    marker.on('remove', () => { if (typeof saveTraceDebounced === 'function') saveTraceDebounced(50); });
  }
// Auto-save right after waypoint creation
  if (typeof saveTraceToLocalStorage === 'function') {
    setTimeout(() => saveTraceToLocalStorage(), 50);
  }
  return marker;
}


    function addWaypointsFromFeatures(features) {
      if (!Array.isArray(features)) {
        return;
      }
      features.forEach((feature) => {
        if (!feature || !feature.geometry) {
          return;
        }
        const properties = feature.properties || {};
        const baseName = properties.name || properties.description || '';

        if (feature.geometry.type === 'Point') {
          const coords = feature.geometry.coordinates;
          if (Array.isArray(coords) && coords.length >= 2) {
            createWaypointMarker(L.latLng(coords[1], coords[0]), baseName);
          }
        } else if (feature.geometry.type === 'MultiPoint') {
          const points = feature.geometry.coordinates || [];
          points.forEach((coords, index) => {
            if (Array.isArray(coords) && coords.length >= 2) {
              const name = baseName ? `${baseName} (${index + 1})` : '';
              createWaypointMarker(L.latLng(coords[1], coords[0]), name);
            }
          });
        }
      });
    }

    function handleAddWaypointFromTrack(latlng) {
      const suggestedName = `Waypoint ${waypointCounter}`;
      const userInput = prompt('Nom du waypoint ?', suggestedName);
      if (userInput === null) {
        return;
      }
      const finalName = userInput.trim() ? userInput.trim() : suggestedName;
      const marker = createWaypointMarker(latlng, finalName);
      marker.openPopup();
    }

    function getWaypointMarkers() {
      const markers = [];
      waypointLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          markers.push(layer);
        } else if (layer && typeof layer.getLayers === 'function') {
          layer.getLayers().forEach((child) => {
            if (child instanceof L.Marker) {
              markers.push(child);
            }
          });
        }
      });
      return markers;
    }

    function updateWaypointsList() {
      if (!waypointsList || !waypointCountLabel || !waypointsSection) {
        return;
      }

      const markers = getWaypointMarkers();
      waypointCountLabel.textContent = markers.length;

      const hasWaypoints = markers.length > 0;
      waypointsSection.style.display = hasWaypoints ? 'block' : 'none';

      if (hasWaypoints) {
        const configBefore = window.collapsibleSections?.waypoints;
        if (window.collapsibleSectionsAPI?.init && (!configBefore || !configBefore.initialized)) {
          window.collapsibleSectionsAPI.init('waypoints');
        }
        const config = window.collapsibleSections?.waypoints;
        if (config && !config.isExpanded) {
          if (typeof setSectionExpanded === 'function') {
            setSectionExpanded('waypoints', true, true);
          }
          if (typeof saveSectionState === 'function') {
            saveSectionState('waypoints', true);
          }
        }
      }

      waypointsList.innerHTML = '';

      markers.forEach((marker) => {
        const item = document.createElement('div');
        item.className = 'waypoint-item';
        item.innerHTML = `
          <span class="waypoint-icon" aria-hidden="true">📍</span>
          <span class="waypoint-name">${escapeHtml(marker.waypointName)}</span>
          <button class="btn-icon-small" data-action="center" title="Centrer">🎯</button>
          <button class="btn-icon-small" data-action="delete" title="Supprimer">🗑️</button>
        `;

        const centerButton = item.querySelector('[data-action="center"]');
        if (centerButton) {
          centerButton.addEventListener('click', () => {
            const latlng = marker.getLatLng();
            if (latlng) {
              map.setView(latlng, Math.max(map.getZoom(), 16));
              marker.openPopup();
            }
          });
        }

        const deleteButton = item.querySelector('[data-action="delete"]');
        if (deleteButton) {
          deleteButton.addEventListener('click', () => {
            waypointLayerGroup.removeLayer(marker);
            updateWaypointsList();
            try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
            if (typeof saveTraceDebounced === 'function') {
              saveTraceDebounced(50);
            }
            if (typeof saveTraceToLocalStorage === 'function') {
              try {
                saveTraceToLocalStorage();
              } catch (error) {
                console.warn(error);
              }
            }
          });
        }

        waypointsList.appendChild(item);
      });

      if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
        window.roadbookManager.update();
      }
    }

    function updateTraceInfo(info) {
      if (!traceInfoSection || !traceNameLabel || !pointCountLabel || !traceTypeLabel) {
        return;
      }

      if (!info) {
        traceInfoSection.style.display = 'none';
        displayTraceName('—', 'default');
        pointCountLabel.textContent = '—';
        traceTypeLabel.textContent = '—';
        if (traceFileNameLabel) {
          traceFileNameLabel.textContent = '—';
        }
        if (gpxTraceFilename) {
          gpxTraceFilename.textContent = 'Aucune trace chargée';
        }
        return;
      }

      traceInfoSection.style.display = 'block';
      displayTraceName(currentTraceName || info.name || '—', traceNameSource || 'default');
      pointCountLabel.textContent = Number.isFinite(info.pointCount) ? info.pointCount : '—';
      traceTypeLabel.textContent = info.type || '—';
    if (traceFileNameLabel) {
      traceFileNameLabel.textContent = currentGpxFileName || '—';
    }
    if (gpxTraceFilename) {
      gpxTraceFilename.textContent = currentGpxFileName || info.name || 'Trace GPX';
    }
  }

  const roadbookManager = {
    section: null,
    listContainer: null,
    emptyState: null,
    stepCount: null,
    exportButton: null,
    exportClickHandler: null,
    steps: [],
    waypointListener: null,

    init() {
      this.section = document.getElementById('roadbook-section');
      this.listContainer = document.getElementById('roadbook-list');
      this.emptyState = document.getElementById('roadbook-empty');
      this.stepCount = document.getElementById('roadbook-step-count');
      const exportButtonElement = document.getElementById('roadbook-export-text');

      if (this.exportButton && this.exportClickHandler) {
        this.exportButton.removeEventListener('click', this.exportClickHandler);
      }

      this.exportButton = exportButtonElement || null;

      if (this.exportButton) {
        this.exportClickHandler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          exportRoadbookToText();
        };
        this.exportButton.addEventListener('click', this.exportClickHandler);
      } else {
        this.exportClickHandler = null;
      }

      if (!this.section || !this.listContainer) {
        return;
      }

      if (window.collapsibleSectionsAPI?.init) {
        window.collapsibleSectionsAPI.init('roadbook');
        if (typeof window.collapsibleSectionsAPI.collapse === 'function') {
          window.collapsibleSectionsAPI.collapse('roadbook');
        }
      }

      this.attachListeners();
      this.update();
    },

    attachListeners() {
      if (
        typeof waypointLayerGroup !== 'undefined' &&
        waypointLayerGroup &&
        typeof waypointLayerGroup.on === 'function'
      ) {
        if (this.waypointListener) {
          waypointLayerGroup.off('layeradd', this.waypointListener);
          waypointLayerGroup.off('layerremove', this.waypointListener);
        }
        this.waypointListener = () => this.update();
        waypointLayerGroup.on('layeradd', this.waypointListener);
        waypointLayerGroup.on('layerremove', this.waypointListener);
      }
    },

    updateExportButtonState() {
      if (!this.exportButton) {
        return;
      }
      const hasSteps = Array.isArray(this.steps) && this.steps.length > 0;
      this.exportButton.disabled = !hasSteps;

      if (!hasSteps) {
        if (this.exportButton.__copyResetTimeout) {
          clearTimeout(this.exportButton.__copyResetTimeout);
          this.exportButton.__copyResetTimeout = null;
        }
        this.exportButton.textContent = '📋';
        this.exportButton.classList.remove('copied');
      }
    },

    update() {
      this.steps = this.computeSteps();
      this.render();
    },

    computeSteps() {
      if (
        !currentElevationData ||
        !Array.isArray(currentElevationData.points) ||
        !currentElevationData.stats
      ) {
        return [];
      }

      const elevationPoints = currentElevationData.points;
      const totalDistance = Number.isFinite(currentElevationData.stats.totalDistance)
        ? currentElevationData.stats.totalDistance
        : 0;

      if (!Array.isArray(elevationPoints) || elevationPoints.length === 0) {
        return [];
      }

      const steps = [];
      const startPoint = elevationPoints[0];
      if (startPoint) {
        steps.push({
          type: 'start',
          name: 'Départ',
          lat: startPoint.lat,
          lng: startPoint.lng,
          distance: 0,
          segmentDistance: 0,
          remainingDistance: Math.max(0, totalDistance),
          elevation: Number.isFinite(startPoint.elevation) ? startPoint.elevation : null,
          pointIndex: Number.isFinite(startPoint.index) ? startPoint.index : null
        });
      }

      const markers =
        typeof getWaypointMarkers === 'function' ? getWaypointMarkers() : [];

      const waypointSteps = markers
        .map((marker) => {
          if (!marker || typeof marker.getLatLng !== 'function') {
            return null;
          }
          const latlng = marker.getLatLng();
          const closestPoint = this.findClosestElevationPoint(latlng, elevationPoints);
          const distance = closestPoint ? closestPoint.distance : 0;
          return {
            type: 'waypoint',
            name: marker.waypointName || 'Waypoint',
            lat: latlng.lat,
            lng: latlng.lng,
            distance,
            elevation: closestPoint && Number.isFinite(closestPoint.elevation)
              ? closestPoint.elevation
              : null,
            pointIndex: closestPoint && Number.isFinite(closestPoint.index) ? closestPoint.index : null,
            marker
          };
        })
        .filter(Boolean)
        .sort((a, b) => a.distance - b.distance);

      waypointSteps.forEach((waypoint) => {
        const previousStepDistance =
          steps.length > 0 ? steps[steps.length - 1].distance : 0;
        waypoint.segmentDistance = Math.max(0, waypoint.distance - previousStepDistance);
        waypoint.remainingDistance = Math.max(0, totalDistance - waypoint.distance);
        steps.push(waypoint);
      });

      const endPoint = elevationPoints[elevationPoints.length - 1];
      if (endPoint) {
        const previousDistance = steps.length > 0 ? steps[steps.length - 1].distance : 0;
        steps.push({
          type: 'end',
          name: 'Arrivée',
          lat: endPoint.lat,
          lng: endPoint.lng,
          distance: Math.max(0, totalDistance),
          segmentDistance: Math.max(0, totalDistance - previousDistance),
          remainingDistance: 0,
          elevation: Number.isFinite(endPoint.elevation) ? endPoint.elevation : null,
          pointIndex: Number.isFinite(endPoint.index) ? endPoint.index : null
        });
      }

      // Calculate remaining elevation gain (D+ restant) for each step
      try {
        const findRemainingGainFromIndex = (startIdx) => {
          if (!Number.isFinite(startIdx) || startIdx < 0 || startIdx >= elevationPoints.length) return 0;
          let gain = 0;
          for (let i = startIdx + 1; i < elevationPoints.length; i++) {
            const diff = elevationPoints[i].elevation - elevationPoints[i - 1].elevation;
            if (diff > 0) gain += diff;
          }
          return Math.round(gain);
        };

        steps.forEach((s) => {
          if (Number.isFinite(s.pointIndex)) {
            s.remainingElevationGain = findRemainingGainFromIndex(s.pointIndex);
          } else {
            s.remainingElevationGain = null;
          }
        });
      } catch (e) {
        // if something goes wrong, don't block the roadbook
        steps.forEach((s) => { s.remainingElevationGain = null; });
      }

      return steps;
    },

    findClosestElevationPoint(latlng, points) {
      if (!latlng || !Array.isArray(points) || points.length === 0) {
        return null;
      }

      let closest = points[0];
      let minDistance = Infinity;

      points.forEach((point) => {
        const dist = haversineDistance(
          { lat: point.lat, lng: point.lng },
          { lat: latlng.lat, lng: latlng.lng }
        );
        if (dist < minDistance) {
          minDistance = dist;
          closest = point;
        }
      });

      return closest || null;
    },

    render() {
      if (!this.section || !this.listContainer || !this.emptyState) {
        return;
      }

      const hasSteps = this.steps.length > 0;
      this.updateExportButtonState();
      this.section.style.display = hasSteps ? 'block' : 'none';

      if (!hasSteps) {
        this.emptyState.style.display = 'block';
        this.listContainer.style.display = 'none';
        if (this.stepCount) {
          this.stepCount.textContent = '0';
        }
        return;
      }

      const waypointCount = this.steps.filter((step) => step.type === 'waypoint').length;
      if (this.stepCount) {
        this.stepCount.textContent = String(waypointCount);
      }

      if (waypointCount === 0) {
        this.emptyState.style.display = 'block';
      } else {
        this.emptyState.style.display = 'none';
      }

      this.listContainer.style.display = 'flex';
      this.listContainer.innerHTML = this.steps
        .map((step, index) => this.renderStep(step, index))
        .join('');

      this.attachStepEvents();
    },

    renderStep(step, index) {
      const icon =
        step.type === 'start' ? '🟢' : step.type === 'end' ? '🏁' : '📍';

      const formatKm = (value) => {
        if (!Number.isFinite(value)) {
          return '0.00';
        }
        return (value / 1000).toFixed(2);
      };

      const distanceKm = formatKm(step.distance);
      const segmentKm = formatKm(step.segmentDistance);
      const remainingKm = formatKm(step.remainingDistance);

      const showSegment = step.type !== 'start';
      const showRemaining = step.type !== 'end' && this.steps.length > 1;
      const showElevation =
        step.elevation !== null && Number.isFinite(step.elevation);
      const showRemainingElevation =
        step.remainingElevationGain !== null && Number.isFinite(step.remainingElevationGain);

      return `
        <div class="roadbook-step" data-type="${step.type}" data-index="${index}">
          <div class="roadbook-step-marker">
            <span class="roadbook-step-icon">${icon}</span>
            <span class="roadbook-step-number">#${index + 1}</span>
          </div>
          <div class="roadbook-step-content">
            <div class="roadbook-step-header">
              <h4 class="roadbook-step-name">${escapeHtml(step.name)}</h4>
              <button class="roadbook-step-center-btn" title="Centrer sur la carte">🎯</button>
            </div>
            <div class="roadbook-step-distances">
              <div class="roadbook-distance-item roadbook-distance-cumul">
                <span class="roadbook-distance-label">Depuis le départ :</span>
                <span class="roadbook-distance-value">${distanceKm} km</span>
              </div>
              ${showSegment ? `
                <div class="roadbook-distance-item roadbook-distance-segment">
                  <span class="roadbook-distance-label">Depuis la dernière étape :</span>
                  <span class="roadbook-distance-value">${segmentKm} km</span>
                </div>
              ` : ''}
              ${showRemaining ? `
                <div class="roadbook-distance-item roadbook-distance-remaining">
                  <span class="roadbook-distance-label">Jusqu'à l'arrivée :</span>
                  <span class="roadbook-distance-value">${remainingKm} km</span>
                </div>
              ` : ''}
            </div>
            ${showElevation || showRemainingElevation ? `
              <div class="roadbook-step-elevation">
                ${showElevation ? `
                  <span class="roadbook-elevation-label">Altitude :</span>
                  <span class="roadbook-elevation-value">${Math.round(step.elevation)} m</span>
                ` : ''}
                ${showRemainingElevation ? `
                  <span class="roadbook-elevation-label">D+ restant :</span>
                  <span class="roadbook-elevation-value">${step.remainingElevationGain} m</span>
                ` : ''}
              </div>
            ` : ''}
          </div>
        </div>
      `;
    },

    attachStepEvents() {
      const buttons = this.listContainer.querySelectorAll('.roadbook-step-center-btn');
      buttons.forEach((button) => {
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          const stepElement = button.closest('.roadbook-step');
          if (!stepElement) {
            return;
          }
          const index = parseInt(stepElement.getAttribute('data-index'), 10);
          const step = Number.isInteger(index) ? this.steps[index] : null;
          if (!step) {
            return;
          }
          if (typeof map !== 'undefined' && map && typeof map.setView === 'function') {
            map.setView([step.lat, step.lng], Math.max(map.getZoom(), 15));
          }
          if (step.marker && typeof step.marker.openPopup === 'function') {
            step.marker.openPopup();
          }
        });
      });
    }
  };

  window.roadbookManager = roadbookManager;

  document.addEventListener('DOMContentLoaded', () => {
    if (window.roadbookManager && typeof window.roadbookManager.init === 'function') {
      window.roadbookManager.init();
    }
  });

  function exportRoadbookToText() {
    const manager = window.roadbookManager;
    if (!manager || !Array.isArray(manager.steps) || manager.steps.length === 0) {
      showMessage("Le roadbook est vide. Ajoutez des waypoints pour l'utiliser.", true);
      return;
    }

    const traceNameFromFile =
      window.currentGpxFileName && typeof window.currentGpxFileName === 'string'
        ? window.currentGpxFileName.replace(/\.gpx$/i, '')
        : '';
    const traceName =
      window.currentTraceName ||
      traceNameFromFile ||
      'Trace sans nom';

    const lines = [];
    lines.push(`🗺️ ROADBOOK - ${traceName}`);
    lines.push('━'.repeat(40));
    lines.push('');

    let waypointIndex = 0;

    manager.steps.forEach((step, index) => {
      if (!step) {
        return;
      }

      const icon = step.type === 'start' ? '🟢' : step.type === 'end' ? '🏁' : '📍';
      const rawName = (step.name || '').trim();
      const upperName = rawName ? rawName.toUpperCase() : '';
      let headerLabel = '';

      if (step.type === 'start') {
        headerLabel = upperName && upperName !== 'DÉPART'
          ? `DÉPART - ${upperName}`
          : 'DÉPART';
      } else if (step.type === 'end') {
        headerLabel = upperName && upperName !== 'ARRIVÉE'
          ? `ARRIVÉE - ${upperName}`
          : 'ARRIVÉE';
      } else {
        waypointIndex += 1;
        const waypointName = upperName || `WAYPOINT ${waypointIndex}`;
        headerLabel = `WAYPOINT ${waypointIndex} - ${waypointName}`;
      }

      lines.push(`${icon} ${headerLabel}`);

      if (step.type === 'end') {
        lines.push(`📍 Distance totale : ${formatKmExport(step.distance)}`);
        if (Number.isFinite(step.segmentDistance) && step.segmentDistance > 0) {
          lines.push(`└─ Depuis l'étape précédente : ${formatKmExport(step.segmentDistance)}`);
        }
      } else {
        lines.push(`📍 Depuis le départ : ${formatKmExport(step.distance)}`);

        if (step.type !== 'start' && Number.isFinite(step.segmentDistance) && step.segmentDistance >= 0) {
          lines.push(`└─ Depuis l'étape précédente : ${formatKmExport(step.segmentDistance)}`);
        }

        if (step.type === 'waypoint' && Number.isFinite(step.remainingDistance) && step.remainingDistance >= 0) {
          lines.push(`└─ Jusqu'à l'arrivée : ${formatKmExport(step.remainingDistance)}`);
        }
      }

      if (Number.isFinite(step.elevation)) {
        lines.push(`⛰️ Altitude : ${Math.round(step.elevation)} m`);
      }

      if (step.type !== 'end' && Number.isFinite(step.remainingElevationGain)) {
        lines.push(`📈 D+ restant : ${Math.round(step.remainingElevationGain)} m`);
      }

      lines.push('');
    });

    if (lines[lines.length - 1] === '') {
      lines.pop();
    }

    lines.push('━'.repeat(40));
    const now = new Date();
    const dateStr = now.toLocaleDateString('fr-FR');
    const timeStr = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
    lines.push(`Généré le ${dateStr} à ${timeStr}`);

    const text = lines.join('\n');
    copyRoadbookTextToClipboard(text);
  }

  function formatKmExport(meters) {
    if (!Number.isFinite(meters)) {
      return '0.00 km';
    }
    return (meters / 1000).toFixed(2) + ' km';
  }

  function handleRoadbookCopySuccess(button) {
    if (!button) {
      return;
    }
    button.textContent = '✓';
    button.classList.add('copied');

    if (button.__copyResetTimeout) {
      clearTimeout(button.__copyResetTimeout);
    }

    button.__copyResetTimeout = setTimeout(() => {
      button.textContent = '📋';
      button.classList.remove('copied');
      button.__copyResetTimeout = null;
    }, 2000);
  }

  function copyRoadbookTextToClipboard(text) {
    const button = document.getElementById('roadbook-export-text');

    if (!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
      fallbackCopyRoadbookText(text, button, null);
      return;
    }

    navigator.clipboard.writeText(text)
      .then(() => {
        handleRoadbookCopySuccess(button);
        showMessage('Roadbook copié dans le presse-papiers ✓', false);
      })
      .catch((err) => {
        console.error('Erreur de copie du roadbook:', err);
        fallbackCopyRoadbookText(text, button, err);
      });
  }

  function fallbackCopyRoadbookText(text, button, originalError) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.setAttribute('readonly', '');
    textarea.style.position = 'fixed';
    textarea.style.top = '-9999px';
    textarea.style.opacity = '0';

    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();

    let successful = false;

    try {
      successful = document.execCommand('copy');
    } catch (error) {
      console.error('Fallback copy failed:', error);
      successful = false;
    } finally {
      document.body.removeChild(textarea);
    }

    if (successful) {
      handleRoadbookCopySuccess(button);
      showMessage('Roadbook copié ✓', false);
      return;
    }

    if (button) {
      button.textContent = '📋';
      button.classList.remove('copied');
      if (button.__copyResetTimeout) {
        clearTimeout(button.__copyResetTimeout);
        button.__copyResetTimeout = null;
      }
    }

    if (originalError && originalError.name === 'NotAllowedError') {
      showMessage('Permission de copie refusée par le navigateur.', true);
    } else if (!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
      showMessage('Impossible de copier le texte. Essayez manuellement.', true);
    } else {
      showMessage('Erreur lors de la copie dans le presse-papiers.', true);
    }
  }

  function createArrowIconHtml(bearing) {
      const rotation = ((bearing - 90) + 360) % 360;
      return `<span class="direction-arrow" style="display:inline-block; color:#ff5722; font-size:1rem; line-height:1; text-shadow:0 0 2px rgba(0,0,0,0.5); transform-origin:center; transform: rotate(${rotation}deg);">➤</span>`;
    }

    function createArrowMarker(point, bearing) {
      return L.marker(point, {
        icon: L.divIcon({
          className: '',
          html: createArrowIconHtml(bearing),
          iconSize: [16, 16],
          iconAnchor: [8, 8]
        }),
        interactive: false,
        keyboard: false
      });
    }

    function createArrowMarkers(layer) {
      const arrowMarkers = [];
      const latLngs = normalizeLatLngSegments(layer.getLatLngs());
      const arrowSpacingMeters = 2500;

      latLngs.forEach((segment) => {
        if (!Array.isArray(segment) || segment.length < 2) {
          return;
        }

        let previousPoint = L.latLng(segment[0]);
        let distanceFromLastArrow = 0;
        let totalSegmentDistance = 0;
        const segmentMarkers = [];

        for (let i = 1; i < segment.length; i++) {
          const currentPoint = L.latLng(segment[i]);
          let segmentDistance = map.distance(previousPoint, currentPoint);
          let segmentStart = previousPoint;

          if (segmentDistance === 0) {
            previousPoint = currentPoint;
            continue;
          }

          totalSegmentDistance += segmentDistance;

          while (distanceFromLastArrow + segmentDistance >= arrowSpacingMeters) {
            const distanceNeeded = arrowSpacingMeters - distanceFromLastArrow;
            const ratio = distanceNeeded / segmentDistance;
            const interpolatedLat =
              segmentStart.lat + (currentPoint.lat - segmentStart.lat) * ratio;
            const interpolatedLng =
              segmentStart.lng + (currentPoint.lng - segmentStart.lng) * ratio;
            const arrowPoint = L.latLng(interpolatedLat, interpolatedLng);
            const bearing = computeBearingDegrees(segmentStart, currentPoint);

            const marker = createArrowMarker(arrowPoint, bearing);

            arrowMarkers.push(marker);
            segmentMarkers.push(marker);

            segmentStart = arrowPoint;
            segmentDistance = map.distance(segmentStart, currentPoint);
            if (segmentDistance === 0) {
              break;
            }
            distanceFromLastArrow = 0;
          }

          distanceFromLastArrow += segmentDistance;
          previousPoint = currentPoint;
        }

        if (segmentMarkers.length === 0 && totalSegmentDistance > 0) {
          const targetDistance = totalSegmentDistance / 2;
          let accumulated = 0;
          for (let i = 1; i < segment.length; i++) {
            const start = L.latLng(segment[i - 1]);
            const end = L.latLng(segment[i]);
            const distance = map.distance(start, end);
            if (distance === 0) {
              continue;
            }
            if (accumulated + distance >= targetDistance) {
              const ratio = (targetDistance - accumulated) / distance;
              const lat = start.lat + (end.lat - start.lat) * ratio;
              const lng = start.lng + (end.lng - start.lng) * ratio;
              const point = L.latLng(lat, lng);
              const bearing = computeBearingDegrees(start, end);
              const marker = createArrowMarker(point, bearing);
              arrowMarkers.push(marker);
              segmentMarkers.push(marker);
              break;
            }
            accumulated += distance;
          }
        }
      });

      return arrowMarkers;
    }

    function computeTraceInfo(lineFeatures, geojson) {
      if (!Array.isArray(lineFeatures) || lineFeatures.length === 0) {
        return null;
      }

      const first = lineFeatures[0];
      const properties = first.properties || {};
      const name = properties.name || properties.description || (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : 'Trace');
      let pointCount = 0;
      let type = properties.kind || first.geometry?.type || '—';

      lineFeatures.forEach((feature) => {
        if (!feature.geometry) {
          return;
        }
        const geometry = feature.geometry;
        if (geometry.type === 'LineString') {
          pointCount += Array.isArray(geometry.coordinates) ? geometry.coordinates.length : 0;
        } else if (geometry.type === 'MultiLineString') {
          (geometry.coordinates || []).forEach((segment) => {
            pointCount += Array.isArray(segment) ? segment.length : 0;
          });
        }
        if (!type && geometry.type) {
          type = geometry.type;
        }
        if (!properties.kind && feature.properties && feature.properties.kind) {
          type = feature.properties.kind;
        }
      });

      if (!type && geojson && Array.isArray(geojson.features)) {
        const kinds = geojson.features
          .map((feature) => feature?.properties?.kind)
          .filter(Boolean);
        if (kinds.length > 0) {
          type = kinds[0];
        }
      }

      return {
        name,
        pointCount,
        type: type || '—'
      };
    }

    function displayGeoJSON(geojsonData) {
      clearPreviousLayers();

      currentGeojson = geojsonData;

      const lineFeatures = [];
      const pointFeatures = [];

      if (geojsonData && Array.isArray(geojsonData.features)) {
        geojsonData.features.forEach((feature) => {
          const geometryType = feature && feature.geometry && feature.geometry.type;
          if (geometryType === 'LineString' || geometryType === 'MultiLineString') {
            lineFeatures.push(feature);
          } else if (geometryType === 'Point' || geometryType === 'MultiPoint') {
            pointFeatures.push(feature);
          }
        });
      }

      const linesFeatureCollection = {
        type: 'FeatureCollection',
        features: lineFeatures
      };

      gpxLayerGroup = L.geoJSON(linesFeatureCollection, {
        style: function () {
          return {
            color: '#ff5722',
            weight: 3,
            opacity: 0.9
          };
        }
      }).addTo(map);

      const arrowLayers = [];
      gpxLayerGroup.eachLayer((layer) => {
        if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
          layer.on('click', (event) => {
            if (event.originalEvent) {
              event.originalEvent.preventDefault();
              event.originalEvent.stopPropagation();
            }
            handleAddWaypointFromTrack(event.latlng);
          });

          if (
            typeof L.polylineDecorator === 'function' &&
            L.Symbol &&
            typeof L.Symbol.arrowHead === 'function'
          ) {
            const decorator = L.polylineDecorator(layer, {
              patterns: [
                {
                  offset: '5%',
                  repeat: '50%',
                  symbol: L.Symbol.arrowHead({
                    pixelSize: 10,
                    headAngle: 60,
                    polygon: false,
                    pathOptions: {
                      stroke: true,
                      color: '#ff5722',
                      weight: 2,
                      opacity: 0.9
                    }
                  })
                }
              ]
            });
            arrowLayers.push(decorator);
          } else {
            const markers = createArrowMarkers(layer);
            if (markers.length > 0) {
              arrowLayers.push(L.layerGroup(markers));
            }
          }
        }
      });

      if (arrowLayers.length > 0) {
        arrowLayerGroup = L.layerGroup(arrowLayers).addTo(map);
      }

      if (pointFeatures.length > 0) {
        addWaypointsFromFeatures(pointFeatures);
      } else {
        updateWaypointsList();
      }

      let bounds = null;
      if (gpxLayerGroup.getLayers().length > 0) {
        bounds = gpxLayerGroup.getBounds();
      }
      waypointLayerGroup.eachLayer((layer) => {
        if (typeof layer.getLatLng !== 'function') {
          return;
        }
        const latlng = layer.getLatLng();
        if (!latlng) {
          return;
        }
        if (!bounds) {
          bounds = L.latLngBounds(latlng, latlng);
        } else {
          bounds.extend(latlng);
        }
      });

      if (bounds && typeof bounds.isValid === 'function' && bounds.isValid()) {
        map.fitBounds(bounds.pad(0.1));
      }

      updateTraceInfo(computeTraceInfo(lineFeatures, geojsonData));
      currentGeojson = geojsonData;
    
    try { addTraceEndpointMarkers(geojsonData); } catch(e){ console.warn('addTraceEndpointMarkers: ', e); }
}

    /**
     * Traite le fichier GPX sélectionné.
     * @param {File} file
     */
    async function handleFile(file) {
      if (!file) {
        return;
      }

      setExportAvailability(false);
      currentGpxDocument = null;
      currentGpxFileName = '';
      currentTraceName = '';
      traceNameSource = '';
      displayTraceName('—', 'default');
      updateTraceInfo(null);

      if (!file.name.toLowerCase().endsWith('.gpx')) {
        showMessage('Veuillez sélectionner un fichier .gpx.', true);
        return;
      }

      const reader = new FileReader();

      reader.onload = async function (event) {
        try {
          showMessage('Chargement de la trace GPX…');
          const parser = new DOMParser();
          const xml = parser.parseFromString(event.target.result, 'application/xml');
          const parseError = xml.querySelector('parsererror');
          if (parseError) {
            throw new Error('Fichier GPX invalide.');
          }

          currentGpxDocument = window.currentGpxDocument = xml;
          currentGpxFileName = window.currentGpxFileName = file.name;
          if (traceFileNameLabel) {
            traceFileNameLabel.textContent = file.name;
          }
          if (gpxTraceFilename) {
            gpxTraceFilename.textContent = file.name;
          }

          const extractedTrace = extractTraceName(xml, file.name);
          currentTraceName = window.currentTraceName = extractedTrace.name;
          traceNameSource = window.traceNameSource = extractedTrace.source;
          displayTraceName(currentTraceName, traceNameSource);

          const geojson = convertGpxToGeoJSON(xml);

          if (!geojson || !geojson.features || geojson.features.length === 0) {
            throw new Error('La trace GPX est vide ou invalide.');
          }

          setExportAvailability(true);
          displayGeoJSON(geojson);
    if (typeof attachWaypointPersistence === 'function') attachWaypointPersistence();
          // Guarded elevation render after import
          if (typeof ensureElevationRendered === 'function') ensureElevationRendered(12);

          currentElevationData = currentElevationData = window.currentElevationData = extractElevationData(geojson, xml);
      let noElevationData = false;
          if (currentElevationData) {
            updateElevationStats(currentElevationData.stats);
            setElevationCollapsed(false);
            requestAnimationFrame(() => renderElevationProfile());
          } else {
            updateElevationStats(null);
            const distanceOnly = calculateDistanceOnly(geojson);
            if (distanceOnly && traceDistanceLabel) {
              const distanceKmOnly = (distanceOnly.distance / 1000).toFixed(2);
              traceDistanceLabel.textContent = `${distanceKmOnly} km`;
              if (profileDistanceValue) {
                profileDistanceValue.textContent = `${distanceKmOnly} km`;
              }
              if (ariaDistance) {
                ariaDistance.textContent = `${distanceKmOnly} km`;
              }
              if (gpxTraceDistance) {
                gpxTraceDistance.textContent = `${distanceKmOnly} km`;
              }
            } else if (gpxTraceDistance) {
              gpxTraceDistance.textContent = '—';
            }
            if (traceElevationGainLabel) {
              traceElevationGainLabel.textContent = 'N/A';
            }
            if (gpxTraceElevation) {
              gpxTraceElevation.textContent = 'D+ N/A';
            }
            if (traceElevationLossLabel) {
              traceElevationLossLabel.textContent = 'N/A';
            }
            if (traceAltitudeRangeLabel) {
              traceAltitudeRangeLabel.textContent = 'N/A';
            }
            if (profileElevationGainValue) {
              profileElevationGainValue.textContent = 'N/A';
            }
            if (profileElevationLossValue) {
              profileElevationLossValue.textContent = 'N/A';
            }
            if (ariaDPlus) {
              ariaDPlus.textContent = 'N/A';
            }
            if (ariaMin) {
              ariaMin.textContent = 'N/A';
            }
            if (ariaMax) {
              ariaMax.textContent = 'N/A';
            }
            if (elevationProfile) {
              elevationProfile.setAttribute('aria-hidden', 'true');
            }
            noElevationData = true;
          }

          if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
            window.roadbookManager.update();
          }

          let successMessage = '';
          switch (traceNameSource) {
            case 'gpx-track':
            case 'gpx-route':
            case 'gpx-metadata':
              successMessage = `Trace "<strong>${escapeHtml(currentTraceName)}</strong>" chargée avec succès.`;
              break;
            case 'filename':
              successMessage = `Fichier "<strong>${escapeHtml(currentTraceName)}</strong>" chargé (aucun nom dans le GPX).`;
              break;
            case 'default':
            default:
              successMessage = 'Trace chargée (aucun nom disponible).';
              break;
          }
          if (noElevationData) {
            successMessage += '<br><small>Cette trace ne contient pas de données d\'élévation.</small>';
          }
          showMessage(successMessage, false, true);
          
          // Sauvegarder la trace après chargement réussi
          setTimeout(() => {
            if (typeof saveTraceToLocalStorage === 'function') {
              saveTraceToLocalStorage();
              console.log('Trace sauvegardée après import');
            }
          }, 200);

          
          // Sauvegarder automatiquement la trace chargée
setTimeout(() => { if (typeof saveTraceToLocalStorage === 'function') saveTraceToLocalStorage(); }, 500);
        } catch (error) {
          console.error(error);
          showMessage(error.message || 'Impossible de lire ce fichier GPX.', true);
          clearPreviousLayers();
          currentGpxDocument = null;
          currentGpxFileName = '';
          currentTraceName = '';
          traceNameSource = '';
          displayTraceName('—', 'default');
          setExportAvailability(false);
        }
      };

      reader.onerror = function () {
        showMessage('Erreur de lecture du fichier.', true);
        currentGpxDocument = null;
        currentGpxFileName = '';
        currentTraceName = '';
        traceNameSource = '';
        displayTraceName('—', 'default');
        setExportAvailability(false);
      };

      reader.readAsText(file);
    }

    function exportUpdatedGpx(options = {}) {
      if (!currentGpxDocument) {
        showMessage('Aucune trace GPX à exporter.', true);
        return;
      }

      const includeWaypoints = options.includeWaypoints !== false;
      const requestedName = options.downloadName && options.downloadName.trim();
      const fallbackBase =
        currentTraceName ||
        (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : '') ||
        'trace';

      let finalBase = sanitizeFileName(
        requestedName ? requestedName.replace(/\.gpx$/i, '') : fallbackBase
      );
      const nameWasProvided = Boolean(requestedName);

      if (!finalBase) {
        finalBase = 'trace';
      }

      if (!nameWasProvided) {
        if (includeWaypoints && !/_with_waypoints$/i.test(finalBase)) {
          finalBase = `${finalBase}_with_waypoints`;
        } else if (!includeWaypoints && /_with_waypoints$/i.test(finalBase)) {
          finalBase = finalBase.replace(/_with_waypoints$/i, '');
        }
      }

      const downloadName = `${finalBase}.gpx`;

      const xmlDoc = currentGpxDocument.cloneNode(true);
      const gpxRoot = xmlDoc && xmlDoc.documentElement ? xmlDoc.documentElement : null;

      if (!gpxRoot) {
        showMessage('Impossible de préparer le fichier GPX.', true);
        return;
      }

      const existingWaypoints = xmlDoc.querySelectorAll('wpt');
      existingWaypoints.forEach((node) => {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });

      const markers = includeWaypoints ? getWaypointMarkers() : [];
      markers.forEach((marker) => {
        if (typeof marker.getLatLng !== 'function') {
          return;
        }
        const latlng = marker.getLatLng();
        if (!latlng) {
          return;
        }

        const wptNode = xmlDoc.createElement('wpt');
        wptNode.setAttribute('lat', latlng.lat.toFixed(6));
        wptNode.setAttribute('lon', latlng.lng.toFixed(6));

        if (marker.waypointName) {
          const nameNode = xmlDoc.createElement('name');
          nameNode.textContent = marker.waypointName;
          wptNode.appendChild(nameNode);
        }

        gpxRoot.appendChild(wptNode);
      });

      const serializer = new XMLSerializer();
      let gpxString = serializer.serializeToString(xmlDoc);
      if (!gpxString.startsWith('<?xml')) {
        gpxString = `<?xml version="1.0" encoding="UTF-8"?>\n${gpxString}`;
      }

      const blob = new Blob([gpxString], { type: 'application/gpx+xml' });
      const url = URL.createObjectURL(blob);

      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = downloadName;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);

      setTimeout(() => {
        URL.revokeObjectURL(url);
      }, 0);

      showMessage(`Fichier "${downloadName}" exporté.`);
    }

    function getWaypointCount() {
      try {
        const markers = getWaypointMarkers();
        return Array.isArray(markers) ? markers.length : 0;
      } catch (error) {
        console.warn('getWaypointCount', error);
        return 0;
      }
    }

    function getSuggestedExportBase(includeWaypoints = true) {
      const baseCandidate =
        currentTraceName ||
        (currentGpxFileName ? currentGpxFileName.replace(/\.gpx$/i, '') : '') ||
        'trace';
      let sanitized = sanitizeFileName(baseCandidate);
      if (!sanitized) {
        sanitized = 'trace';
      }
      if (includeWaypoints && !/_with_waypoints$/i.test(sanitized)) {
        sanitized = `${sanitized}_with_waypoints`;
      } else if (!includeWaypoints && /_with_waypoints$/i.test(sanitized)) {
        sanitized = sanitized.replace(/_with_waypoints$/i, '');
      }
      return sanitized;
    }

    function updateExportPreview() {
      if (!exportPreviewName) {
        return null;
      }
      const includeWaypoints = exportIncludeWaypoints ? exportIncludeWaypoints.checked : true;
      const rawInput = exportFileNameInput ? exportFileNameInput.value.trim() : '';
      const suggestedBase = exportFileNameInput ? exportFileNameInput.dataset.suggestedBase || '' : '';
      const sanitizedSuggested = suggestedBase
        ? sanitizeFileName(suggestedBase.replace(/\.gpx$/i, ''))
        : '';
      let sanitizedBase = rawInput
        ? sanitizeFileName(rawInput.replace(/\.gpx$/i, ''))
        : '';

      const isUsingSuggested =
        !rawInput ||
        (!!sanitizedSuggested && sanitizedBase === sanitizedSuggested);

      if (!sanitizedBase) {
        sanitizedBase = sanitizedSuggested || getSuggestedExportBase(includeWaypoints);
      }

      if (isUsingSuggested) {
        if (includeWaypoints && !/_with_waypoints$/i.test(sanitizedBase)) {
          sanitizedBase = `${sanitizedBase}_with_waypoints`;
        } else if (!includeWaypoints && /_with_waypoints$/i.test(sanitizedBase)) {
          sanitizedBase = sanitizedBase.replace(/_with_waypoints$/i, '');
        }
        if (exportFileNameInput) {
          exportFileNameInput.value = sanitizedBase;
        }
      }

      if (!sanitizedBase) {
        sanitizedBase = 'trace';
      }

      const finalName = `${sanitizedBase}.gpx`;
      exportPreviewName.textContent = finalName;
      if (exportFileNameInput) {
        exportFileNameInput.dataset.exportSanitized = sanitizedBase;
      }
      return { includeWaypoints, finalName, sanitizedBase };
    }

    function openExportModal() {
      if (!exportModal || !exportModalBackdrop) {
        return;
      }

      const waypointCount = getWaypointCount();
      const hasWaypoints = waypointCount > 0;

      if (exportWaypointsLabel) {
        exportWaypointsLabel.textContent = `Inclure les waypoints (${waypointCount})`;
      }
      if (exportIncludeWaypoints) {
        exportIncludeWaypoints.disabled = !hasWaypoints;
        exportIncludeWaypoints.checked = hasWaypoints;
      }
      if (exportFileNameInput) {
        const defaultBase = getSuggestedExportBase(exportIncludeWaypoints ? exportIncludeWaypoints.checked : true);
        exportFileNameInput.value = defaultBase;
        exportFileNameInput.dataset.suggestedBase = defaultBase;
        requestAnimationFrame(() => {
          exportFileNameInput.focus();
          exportFileNameInput.select();
        });
      }

      updateExportPreview();
      exportModal.classList.remove('hidden');
      exportModalBackdrop.classList.remove('hidden');
      document.body.classList.add('modal-open');
    }

    function closeExportModal() {
      if (exportModal) {
        exportModal.classList.add('hidden');
      }
      if (exportModalBackdrop) {
        exportModalBackdrop.classList.add('hidden');
      }
      document.body.classList.remove('modal-open');
    }

    function togglePanel(open) {
      if (!toolsPanel) {
        return;
      }
      const shouldOpen = open !== undefined ? open : !toolsPanel.classList.contains('open');
      if (shouldOpen) {
        toolsPanel.classList.add('open');
        menuToggle?.setAttribute('aria-expanded', 'true');
        if (!backdropElement) {
          backdropElement = document.createElement('div');
          backdropElement.className = 'panel-backdrop';
          backdropElement.addEventListener('click', () => {
            togglePanel(false);
          });
          document.body.appendChild(backdropElement);
        }
      } else {
        toolsPanel.classList.remove('open');
        menuToggle?.setAttribute('aria-expanded', 'false');
        if (backdropElement) {
          backdropElement.remove();
          backdropElement = null;
        }
      }
      map.invalidateSize();
    }

    initPOIManager();

    if (gpxImportZone && fileInput) {
      gpxImportZone.addEventListener('click', () => fileInput.click());
      gpxImportZone.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          fileInput.click();
        }
      });
    }

    if (replaceActionButton && fileInput) {
      replaceActionButton.addEventListener('click', () => {
        const waypointCount = getWaypointCount();
        if (waypointCount > 0) {
          const confirmReplace = confirm(
            'Remplacer la trace effacera les waypoints actuels. Continuer ?'
          );
          if (!confirmReplace) {
            return;
          }
        }
        fileInput.click();
      });
    }

    // Helper: on small screens, close the tools panel before opening modal to avoid overlay issues
    function isMobileViewport() {
      try {
        return window.matchMedia && window.matchMedia('(max-width: 767px)').matches;
      } catch (e) {
        return (window.innerWidth || document.documentElement.clientWidth) <= 767;
      }
    }

    if (exportActionButton) {
      exportActionButton.addEventListener('click', () => {
        if (!currentGpxDocument) {
          showMessage('Aucune trace GPX à exporter.', true);
          return;
        }

        // If the panel is open on mobile, close it first so the modal isn't hidden behind it.
        const panelOpen = toolsPanel && toolsPanel.classList.contains('open');
        if (isMobileViewport() && panelOpen) {
          // Close panel and wait for the CSS transition to finish (~300ms) before opening modal
          togglePanel(false);
          // Use requestAnimationFrame + setTimeout as a small debounce to ensure the DOM updated
          window.setTimeout(() => {
            openExportModal();
          }, 320);
        } else {
          openExportModal();
        }
      });
    }

    if (exportModalClose) {
      exportModalClose.addEventListener('click', closeExportModal);
    }
    if (exportModalCancel) {
      exportModalCancel.addEventListener('click', closeExportModal);
    }
    if (exportModalBackdrop) {
      exportModalBackdrop.addEventListener('click', closeExportModal);
    }
    if (exportIncludeWaypoints) {
      exportIncludeWaypoints.addEventListener('change', () => {
        updateExportPreview();
      });
    }
    if (exportFileNameInput) {
      exportFileNameInput.addEventListener('input', () => {
        updateExportPreview();
      });
    }
    if (exportModalDownload) {
      exportModalDownload.addEventListener('click', () => {
        const previewState = updateExportPreview();
        if (!previewState) {
          return;
        }
        exportUpdatedGpx({
          includeWaypoints: previewState.includeWaypoints,
          downloadName: previewState.finalName
        });
        closeExportModal();
      });
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && exportModal && !exportModal.classList.contains('hidden')) {
        event.preventDefault();
        closeExportModal();
      }
    });

    if (typeof attachWaypointPersistence === 'function') attachWaypointPersistence();
    setTimeout(() => {
      if (typeof loadTraceFromLocalStorage === 'function') {
        loadTraceFromLocalStorage();
      }
    }, 300);

    if (menuToggle) {
      menuToggle.addEventListener('click', () => togglePanel(true));
    }

    if (closePanel) {
      closePanel.addEventListener('click', () => togglePanel(false));
    }

    if (elevationHeader && elevationProfile) {
      elevationHeader.addEventListener('click', (event) => {
        if (event.target === elevationCollapseButton) {
          return;
        }
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    if (elevationCollapseButton && elevationProfile) {
      elevationCollapseButton.addEventListener('click', (event) => {
        event.stopPropagation();
        const collapsed = elevationProfile.classList.contains('collapsed');
        setElevationCollapsed(!collapsed);
      });
    }

    // Gestion du changement de fichier via le sélecteur
    fileInput.addEventListener('change', (event) => {
      const selectedFile = event.target.files && event.target.files[0];
      handleFile(selectedFile);
      fileInput.value = '';
    });

    if (clearWaypointsButton) {
      clearWaypointsButton.addEventListener('click', () => {
        waypointLayerGroup.clearLayers();
        updateWaypointsList();
        try { if (typeof refreshElevationProfiles === 'function') refreshElevationProfiles(80); } catch (e) {}
      if (typeof saveTraceDebounced === 'function') saveTraceDebounced(60);
      if (typeof saveTraceToLocalStorage === 'function') { try { saveTraceToLocalStorage(); } catch(e) {} }
  // FINAL SAFETY: persist the current state after any list refresh
  if (window.currentGpxDocument && typeof saveTraceDebounced === 'function') saveTraceDebounced(80);

});
    }

    function handleDragEnter(zone, event) {
      if (!zone) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      zone.classList.add('dragover');
    }

    function handleDragLeave(zone, event) {
      if (!zone) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
    }

    function handleDrop(zone, event) {
      if (!zone) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      zone.classList.remove('dragover');
      const files = event.dataTransfer && event.dataTransfer.files;
      if (files && files.length > 0) {
        if (zone === gpxLoadedState && getWaypointCount() > 0) {
          const confirmReplace = confirm(
            'Remplacer la trace effacera les waypoints actuels. Continuer ?'
          );
          if (!confirmReplace) {
            return;
          }
        }
        handleFile(files[0]);
      }
    }

    [gpxImportZone, gpxLoadedState].forEach((zone) => {
      if (!zone) {
        return;
      }
      ['dragenter', 'dragover'].forEach((eventName) => {
        zone.addEventListener(eventName, (event) => handleDragEnter(zone, event));
      });
      ['dragleave', 'drop'].forEach((eventName) => {
        zone.addEventListener(eventName, (event) => {
          if (eventName === 'drop') {
            handleDrop(zone, event);
          } else {
            handleDragLeave(zone, event);
          }
        });
      });
    });

    // Gestion du drag & drop sur la carte
    const mapContainer = document.querySelector('#map');
    if (mapContainer) {
      ['dragenter', 'dragover'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
        });
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        mapContainer.addEventListener(eventName, (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (eventName === 'drop') {
            const droppedFiles = event.dataTransfer && event.dataTransfer.files;
            if (droppedFiles && droppedFiles.length > 0) {
              handleFile(droppedFiles[0]);
            }
          }
        });
      });
    }

    // Empêche le navigateur d'ouvrir le fichier en dehors de la zone prévue
    document.addEventListener('dragover', (event) => {
      event.preventDefault();
    });
    document.addEventListener('drop', (event) => {
      event.preventDefault();
    });

    // S'assure que la carte s'ajuste lors des changements de taille de fenêtre
    window.addEventListener('resize', () => {
      map.invalidateSize();
      requestAnimationFrame(() => {
        renderElevationProfile();
        updateMiniElevationProfile();
      });
    });

    // Fermer le panneau avec la touche Échap sur mobile
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        togglePanel(false);
      }
    });
  </script>
<script>
// === Géolocalisation : manager & fonctions ===
const geolocationManager = {
  enabled: false,
  watchId: null,
  currentPosition: null,
  marker: null,
  accuracyCircle: null,
  lastUpdate: null,
  refreshInterval: 30000,
  refreshTimer: null,
  // DOM
  toggleCheckbox: null,
  statusElement: null,
  infoContainer: null,
  errorContainer: null,
  centerButton: null,
  // Options
  options: { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 },
};

function initGeolocation() {
  geolocationManager.toggleCheckbox = document.getElementById('geolocation-toggle');
  geolocationManager.statusElement = document.getElementById('geolocation-status');
  geolocationManager.infoContainer = document.getElementById('geolocation-info');
  geolocationManager.errorContainer = document.getElementById('geolocation-error');
  geolocationManager.centerButton = document.getElementById('center-on-position');

  if (!navigator.geolocation) {
    showGeolocationError('Votre navigateur ne supporte pas la géolocalisation.');
    if (geolocationManager.toggleCheckbox) geolocationManager.toggleCheckbox.disabled = true;
    return;
  }

  const savedPreference = loadGeolocationPreference();
  if (savedPreference && geolocationManager.toggleCheckbox) {
    geolocationManager.toggleCheckbox.checked = true;
    enableGeolocation();
  }

  attachGeolocationHandlers();
}

function enableGeolocation() {
  if (!navigator.geolocation) return;
  geolocationManager.enabled = true;
  if (geolocationManager.infoContainer) geolocationManager.infoContainer.style.display = 'block';
  if (geolocationManager.errorContainer) geolocationManager.errorContainer.style.display = 'none';
  updateGeolocationStatus('Recherche de position...', 'searching');
  getCurrentPosition();
  startGeolocationRefresh();
  saveGeolocationPreference(true);
}

function disableGeolocation() {
  geolocationManager.enabled = false;
  stopGeolocationRefresh();
  removeGeolocationMarker();
  if (geolocationManager.infoContainer) geolocationManager.infoContainer.style.display = 'none';
  if (geolocationManager.errorContainer) geolocationManager.errorContainer.style.display = 'none';
  saveGeolocationPreference(false);
}

function getCurrentPosition() {
  if (!navigator.geolocation || !geolocationManager.enabled) return;
  navigator.geolocation.getCurrentPosition(
    handleGeolocationSuccess,
    handleGeolocationError,
    geolocationManager.options
  );
}

function handleGeolocationSuccess(position) {
  if (!geolocationManager.enabled) return;
  const { latitude, longitude, accuracy } = position.coords;
  geolocationManager.currentPosition = { lat: latitude, lng: longitude, accuracy, timestamp: position.timestamp };
  geolocationManager.lastUpdate = Date.now();
  updateGeolocationMarker(latitude, longitude, accuracy);
  const accuracyText = accuracy < 50 ? 'précise' : accuracy < 100 ? 'moyenne' : 'approximative';
  updateGeolocationStatus(`Position obtenue (précision ${accuracyText}: ±${Math.round(accuracy)}m)`, 'active');
  if (geolocationManager.centerButton) geolocationManager.centerButton.disabled = false;
  hideGeolocationError();

  // Centrage automatique à chaque mise à jour
  centerOnUserPosition();
}

function handleGeolocationError(error) {
  if (!geolocationManager.enabled) return;
  let message = '';
  switch (error.code) {
    case error.PERMISSION_DENIED: message = 'Permission de localisation refusée. Veuillez autoriser l\'accès dans les paramètres de votre navigateur.'; break;
    case error.POSITION_UNAVAILABLE: message = 'Position indisponible. Vérifiez votre connexion et vos paramètres de localisation.'; break;
    case error.TIMEOUT: message = 'Délai d\'attente dépassé. Réessayez dans quelques instants.'; break;
    default: message = 'Erreur de géolocalisation inconnue.';
  }
  updateGeolocationStatus('Erreur de localisation', 'error');
  showGeolocationError(message);
  if (geolocationManager.centerButton) geolocationManager.centerButton.disabled = true;
}

function updateGeolocationMarker(lat, lng, accuracy) {
  // Réutilisation si existant
  if (geolocationManager.accuracyCircle) {
    geolocationManager.accuracyCircle.setLatLng([lat,lng]).setRadius(Math.min(accuracy || 0, 1000));
  } else if (accuracy && accuracy < 1000) {
    geolocationManager.accuracyCircle = L.circle([lat, lng], {
      radius: accuracy, className: 'user-location-accuracy', interactive: false
    }).addTo(map);
  }

  const icon = L.divIcon({
    className: 'user-location-marker',
    html: '<div class="user-location-marker-inner"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });

  if (geolocationManager.marker) {
    geolocationManager.marker.setLatLng([lat,lng]).setIcon(icon);
  } else {
    geolocationManager.marker = L.marker([lat, lng], { icon, zIndexOffset: 1000, title: 'Ma position' }).addTo(map);
  }

  const popupContent = '<div style="text-align:center;"><strong>📍 Ma position</strong><br><small>Précision: ±' + Math.round(accuracy) + 'm</small><br><small>' + new Date().toLocaleTimeString('fr-FR') + '</small></div>';
  geolocationManager.marker.bindPopup(popupContent);
}

function removeGeolocationMarker() {
  if (geolocationManager.marker) { try { map.removeLayer(geolocationManager.marker); } catch(e){} geolocationManager.marker = null; }
  if (geolocationManager.accuracyCircle) { try { map.removeLayer(geolocationManager.accuracyCircle); } catch(e){} geolocationManager.accuracyCircle = null; }
}

function startGeolocationRefresh() {
  stopGeolocationRefresh();
  geolocationManager.refreshTimer = setInterval(() => {
    if (geolocationManager.enabled) getCurrentPosition();
  }, geolocationManager.refreshInterval);
}

function stopGeolocationRefresh() {
  if (geolocationManager.refreshTimer) { clearInterval(geolocationManager.refreshTimer); geolocationManager.refreshTimer = null; }
}

function centerOnUserPosition() {
  if (!geolocationManager.currentPosition) return;
  const { lat, lng, accuracy } = geolocationManager.currentPosition;
  let zoom = 16;
  if (accuracy > 500) zoom = 13; else if (accuracy > 100) zoom = 15;
  map.setView([lat, lng], zoom);
  if (geolocationManager.marker) geolocationManager.marker.openPopup();
}

function updateGeolocationStatus(text, state) {
  if (!geolocationManager.statusElement) return;
  const statusText = geolocationManager.statusElement.querySelector('.status-text');
  if (statusText) statusText.textContent = text;
  geolocationManager.statusElement.className = 'geolocation-status ' + state;
}

function showGeolocationError(message) {
  if (!geolocationManager.errorContainer) return;
  geolocationManager.errorContainer.textContent = '⚠️ ' + message;
  geolocationManager.errorContainer.style.display = 'block';
}

function hideGeolocationError() {
  if (!geolocationManager.errorContainer) return;
  geolocationManager.errorContainer.style.display = 'none';
  geolocationManager.errorContainer.textContent = '';
}

function attachGeolocationHandlers() {
  if (geolocationManager.toggleCheckbox) {
    geolocationManager.toggleCheckbox.addEventListener('change', (e) => {
      if (e.target.checked) enableGeolocation();
      else disableGeolocation();
    });
  }
  if (geolocationManager.centerButton) geolocationManager.centerButton.addEventListener('click', centerOnUserPosition);
}

function saveGeolocationPreference(enabled) {
  try { localStorage.setItem('gpx_geolocation_enabled', JSON.stringify(enabled)); } catch(e){}
}
function loadGeolocationPreference() {
  try { const saved = localStorage.getItem('gpx_geolocation_enabled'); return saved ? JSON.parse(saved) : false; } catch(e){ return false; }
}

// ---- Bootstrapping (après que la carte soit prête) ----
(function bootGeolocWhenReady(){
  function ready() {
    // S'assure que map & L existent
    if (typeof L === 'undefined' || typeof map === 'undefined' || !map) {
      // réessaie au prochain tick
      return void requestAnimationFrame(ready);
    }
    initGeolocation();
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ready);
  } else {
    ready();
  }
})();

// Nettoyage
window.addEventListener('beforeunload', () => { stopGeolocationRefresh(); });

// Économie de batterie
document.addEventListener('visibilitychange', () => {
  if (document.hidden) stopGeolocationRefresh();
  else if (geolocationManager.enabled) { getCurrentPosition(); startGeolocationRefresh(); }
});


// === SAUVEGARDE LOCALE DE LA TRACE GPX ===

const GPX_STORAGE_KEY = 'gpx_saved_trace';
const GPX_WAYPOINTS_KEY = 'gpx_saved_waypoints';
/**
 * Sauvegarde la trace GPX et les waypoints dans localStorage
 */

function saveTraceToLocalStorage() {
  console.log('saveTraceToLocalStorage appelée');
  console.log('currentGpxDocument:', window.currentGpxDocument);
  console.log('currentGpxFileName:', window.currentGpxFileName);
  
  if (!window.currentGpxDocument || !window.currentGpxFileName) {
    console.warn('Pas de trace à sauvegarder');
    return;
  }

  try {
    // Sérialiser le document XML
    const serializer = new XMLSerializer();
    let gpxString = serializer.serializeToString(window.currentGpxDocument);
    if (!gpxString.startsWith('<?xml')) {
      gpxString = `<?xml version="1.0" encoding="UTF-8"?>
${gpxString}`;
    }

        // Collecter les waypoints affichés sur la carte (tous, GPX + personnalisés)
    const waypoints = [];
    const seen = new Set(); // anti-doublons lat/lng+nom
    const markers = (typeof getWaypointMarkers === 'function') ? getWaypointMarkers() : [];
    (markers || []).forEach((marker) => {
      const latlng = marker.getLatLng && marker.getLatLng();
      if (!latlng) return;
      const key = latlng.lat.toFixed(6) + ',' + latlng.lng.toFixed(6);
      const nameKey = (marker.waypointName || '').trim();
      const dedupKey = key + '|' + nameKey;
      if (seen.has(dedupKey)) return;
      seen.add(dedupKey);
      waypoints.push({ lat: latlng.lat, lng: latlng.lng, name: marker.waypointName || '' });
    });

    // Préparer les données à sauvegarder
    const traceData = {
      fileName: window.currentGpxFileName,
      traceName: window.currentTraceName || '',
      traceNameSource: window.traceNameSource || 'default',
      gpxContent: gpxString,
      waypoints: waypoints,
      timestamp: Date.now()
    };

    // Sauvegarder dans localStorage
    localStorage.setItem(GPX_STORAGE_KEY, JSON.stringify(traceData));
    console.log('📝 localStorage updated (waypoints:', waypoints.length, ')');
    
    console.log('✅ Trace sauvegardée avec succès:', window.currentGpxFileName);
    console.log('Waypoints sauvegardés:', waypoints.length);
    
    // Afficher le bouton "Effacer"
  } catch (error) {
    console.error('❌ Erreur sauvegarde:', error);
    
    // Si erreur de quota, informer l'utilisateur
    if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
      if (typeof showMessage === 'function') {
        showMessage('Trace trop volumineuse pour être sauvegardée localement.', true);
      }
    }
  }
}


/**
 * Charge la trace sauvegardée depuis localStorage
 */

function loadTraceFromLocalStorage() {
  try {
    const savedData = localStorage.getItem(GPX_STORAGE_KEY);
    if (!savedData) return false;

    const traceData = JSON.parse(savedData);
    if (!traceData || !traceData.gpxContent || !traceData.fileName) return false;

    if (typeof showMessage === 'function') {
      showMessage('Chargement de la trace sauvegardée...', false);
    }

    // Parse GPX
    const parser = new DOMParser();
    const xml = parser.parseFromString(traceData.gpxContent, 'application/xml');
    const parseError = xml.querySelector('parsererror');
    if (parseError) throw new Error('Fichier GPX sauvegardé invalide.');

    // Restore basic state
    window.currentGpxDocument = currentGpxDocument = xml;
    window.currentGpxFileName = currentGpxFileName = traceData.fileName;
    window.currentTraceName = currentTraceName = traceData.traceName || '';
    window.traceNameSource = traceNameSource = traceData.traceNameSource || 'default';

    if (typeof traceFileNameLabel !== 'undefined' && traceFileNameLabel) {
      traceFileNameLabel.textContent = traceData.fileName;
    }
    if (typeof gpxTraceFilename !== 'undefined' && gpxTraceFilename) {
      gpxTraceFilename.textContent = traceData.fileName;
    }
    if (typeof displayTraceName === 'function') {
      displayTraceName(window.currentTraceName, window.traceNameSource);
    }

    // Convert GPX to GeoJSON
    const geojson = (typeof convertGpxToGeoJSON === 'function') ? convertGpxToGeoJSON(xml) : null;
    const hasStoredWaypoints = Array.isArray(traceData.waypoints); // accept [] as authoritative
    if (hasStoredWaypoints && geojson && Array.isArray(geojson.features)) {
      geojson.features = geojson.features.filter(f => {
        const t = f && f.geometry && f.geometry.type;
        return t !== 'Point' && t !== 'MultiPoint';
      });
    }
    if (!geojson || !geojson.features || geojson.features.length === 0) {
      throw new Error('La trace sauvegardée est vide.');
    }

    if (typeof setExportAvailability === 'function') setExportAvailability(true);
    if (typeof displayGeoJSON === 'function') displayGeoJSON(geojson);
    if (typeof attachWaypointPersistence === 'function') attachWaypointPersistence();

    // Restore saved waypoints (dedup against any existing markers)
    if (hasStoredWaypoints) {
      if (typeof waypointCounter !== 'undefined') window.waypointCounter = 1;
      const existing = (typeof getWaypointMarkers === 'function') ? (getWaypointMarkers() || []) : [];
      traceData.waypoints.forEach((wp) => {
        if (!wp || !wp.lat || !wp.lng || typeof createWaypointMarker !== 'function') return;
        const lat = parseFloat(wp.lat), lng = parseFloat(wp.lng);
        const nameKey = (wp.name || '').trim();
        let duplicate = false;
        existing.forEach(m => {
          const ll = m && m.getLatLng && m.getLatLng();
          if (!ll) return;
          const mkName = (m.waypointName || '').trim();
          if (Math.abs(ll.lat - lat) < 1e-5 && Math.abs(ll.lng - lng) < 1e-5) {
            if (mkName === nameKey || !nameKey || !mkName) duplicate = true;
          }
        });
        if (!duplicate) createWaypointMarker(L.latLng(lat, lng), wp.name);
      });
    }

    // Elevation data
    if (typeof extractElevationData === 'function') {
      window.currentElevationData = currentElevationData = extractElevationData(geojson, xml);
      if (window.currentElevationData) {
        if (typeof updateElevationStats === 'function') updateElevationStats(window.currentElevationData.stats);
        if (typeof elevationProfile !== 'undefined' && elevationProfile) {
          elevationProfile.classList.add('visible');
          elevationProfile.setAttribute('aria-hidden', 'false');
          elevationProfile.classList.remove('collapsed');
          sizeCanvasToParent();
          if (typeof renderElevationProfile === 'function') renderElevationProfile();
        }
        if (typeof setElevationCollapsed === 'function') setElevationCollapsed(false);
        if (typeof renderElevationProfile === 'function') {
          requestAnimationFrame(() => {
            renderElevationProfile();
            setTimeout(() => { renderElevationProfile(); }, 200);
          });
          if (typeof ensureElevationRendered === 'function') ensureElevationRendered(12);
        }
      } else {
        if (typeof updateElevationStats === 'function') updateElevationStats(null);
        if (typeof calculateDistanceOnly === 'function') {
          const distanceOnly = calculateDistanceOnly(geojson);
          if (distanceOnly && typeof traceDistanceLabel !== 'undefined' && traceDistanceLabel) {
            traceDistanceLabel.textContent = `${(distanceOnly.distance / 1000).toFixed(2)} km`;
          }
        }
      }
    }

    if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
      window.roadbookManager.update();
    }

    // UX message
    const elapsed = Date.now() - (traceData.timestamp || Date.now());
    const minutes = Math.max(0, Math.floor(elapsed / 60000));
    const timeAgo = minutes < 1 ? "à l'instant" : minutes < 60 ? `il y a ${minutes} min` : `il y a ${Math.floor(minutes / 60)}h`;
    if (typeof showMessage === 'function' && typeof escapeHtml === 'function') {
      showMessage(`Trace "<strong>${escapeHtml(window.currentTraceName || traceData.fileName)}</strong>" rechargée (sauvegardée ${timeAgo}).`, false, true);
    } else {
      console.log(`Trace "${window.currentTraceName || traceData.fileName}" rechargée (sauvegardée ${timeAgo}).`);
    }

    return true;
  } catch (error) {
    console.error('Erreur lors du chargement de la trace sauvegardée :', error);
    try { localStorage.removeItem(GPX_STORAGE_KEY); } catch(_) {}
    return false;
  }
}

function clearSavedTrace() {
  try {
    currentGpxDocument = null;
    currentGpxFileName = '';
    currentTraceName = '';
    traceNameSource = 'default';
    currentGeojson = null;
  } catch (_){}

  try {
    if (typeof setExportAvailability === 'function') setExportAvailability(false);
    if (typeof updateWaypointsList === 'function') updateWaypointsList();
    if (typeof updateTraceInfo === 'function') updateTraceInfo(null);
    if (typeof displayTraceName === 'function') displayTraceName('—', 'default');
    if (typeof traceFileNameLabel !== 'undefined' && traceFileNameLabel) traceFileNameLabel.textContent = '—';
    if (typeof gpxTraceFilename !== 'undefined' && gpxTraceFilename) gpxTraceFilename.textContent = 'Aucune trace chargée';
    if (typeof gpxTraceDistance !== 'undefined' && gpxTraceDistance) gpxTraceDistance.textContent = '—';
    if (typeof gpxTraceElevation !== 'undefined' && gpxTraceElevation) gpxTraceElevation.textContent = '—';
    if (typeof resetElevationDisplay === 'function') resetElevationDisplay();
  } catch (_){}

  if (typeof showMessage === 'function') showMessage('Trace sauvegardée effacée et carte nettoyée.', false);

  try {
    localStorage.removeItem(GPX_STORAGE_KEY);
    localStorage.removeItem(GPX_WAYPOINTS_KEY);
  } catch (error) {
    console.error('Erreur lors de la suppression du stockage local :', error);
  }

  try {
    if (typeof clearPreviousLayers === 'function') clearPreviousLayers();
    if (typeof waypointLayerGroup !== 'undefined' && waypointLayerGroup && typeof waypointLayerGroup.clearLayers === 'function') waypointLayerGroup.clearLayers();
    if (typeof gpxLayerGroup !== 'undefined' && gpxLayerGroup && typeof gpxLayerGroup.clearLayers === 'function') gpxLayerGroup.clearLayers();
    if (typeof arrowLayerGroup !== 'undefined' && arrowLayerGroup && typeof arrowLayerGroup.clearLayers === 'function') arrowLayerGroup.clearLayers();
  } catch (error) {
    console.warn('Nettoyage des calques :', error);
  }

  try {
    window.currentGpxDocument = null;
    window.currentGpxFileName = '';
    window.currentTraceName = '';
    window.traceNameSource = 'default';
    if (typeof currentGpxDocument !== 'undefined') currentGpxDocument = null;
    if (typeof currentGpxFileName !== 'undefined') currentGpxFileName = '';
    if (typeof currentTraceName !== 'undefined') currentTraceName = '';
    if (typeof traceNameSource !== 'undefined') traceNameSource = 'default';
    if (typeof currentGeojson !== 'undefined') currentGeojson = null;
  } catch (error) {
    console.warn('Réinit variables :', error);
  }
}


// Événement du bouton "Effacer la trace" - Attachement différé
function attachClearTraceButton() {
  const btn = document.getElementById('clear-trace-button');
  if (btn && !btn.__listenerAttached) {
    btn.__listenerAttached = true;
    const labelEl = btn.querySelector('.label');
    const originalLabel = labelEl ? labelEl.textContent : btn.textContent;
    btn.dataset.originalLabel = originalLabel;

    const resetState = () => {
      btn.dataset.confirming = 'false';
      btn.classList.remove('is-confirm');
      if (labelEl) {
        labelEl.textContent = btn.dataset.originalLabel || originalLabel;
      }
      if (btn.__confirmTimeout) {
        clearTimeout(btn.__confirmTimeout);
        btn.__confirmTimeout = null;
      }
    };
    btn.__resetConfirmState = resetState;

    btn.addEventListener('click', () => {
      if (btn.dataset.confirming === 'true') {
        resetState();
        clearSavedTrace();
        return;
      }

      btn.dataset.confirming = 'true';
      btn.classList.add('is-confirm');
      if (labelEl) {
        labelEl.textContent = 'Confirmer';
      }
      if (btn.__confirmTimeout) {
        clearTimeout(btn.__confirmTimeout);
      }
      btn.__confirmTimeout = setTimeout(() => {
        resetState();
      }, 4000);
    });

    btn.addEventListener('blur', resetState);
  }
}

// Charger automatiquement au démarrage
window.addEventListener('DOMContentLoaded', () => {
  // Attacher le bouton d'effacement
  attachClearTraceButton();
  
  // Attendre que la carte soit initialisée
  setTimeout(() => {
    loadTraceFromLocalStorage();
  }, 500);
});
// === Robust elevation render helper (enhanced) ===
function ensureElevationRendered(retries = 8) {
  try {
    const hasData = typeof currentElevationData !== 'undefined' && currentElevationData;
    const hasPoints = hasData && Array.isArray(currentElevationData.points) && currentElevationData.points.length > 1;
    const hasStats = hasData && currentElevationData.stats;
    const hasCanvas = typeof elevationCanvas !== 'undefined' && elevationCanvas;
    const hasProfile = typeof elevationProfile !== 'undefined' && elevationProfile;

    if (!(hasPoints && hasStats && hasCanvas && hasProfile)) {
      // Attempt self-heal: recompute elevation if geojson exists
      if ((!hasData || !hasPoints || !hasStats) && typeof extractElevationData === 'function' && typeof currentGeojson !== 'undefined' && currentGeojson) {
        try {
          const xml = window.currentGpxDocument || null;
          const recomputed = extractElevationData(currentGeojson, xml);
          if (recomputed) {
            window.currentElevationData = recomputed;
            if (typeof updateElevationStats === 'function') updateElevationStats(recomputed.stats);
            if (window.roadbookManager && typeof window.roadbookManager.update === 'function') {
              window.roadbookManager.update();
            }
          }
        } catch (e) {
          console.warn('Recompute elevation failed:', e);
        }
      }

      if (retries > 0) {
        setTimeout(() => ensureElevationRendered(retries - 1), 200);
      } else {
        console.warn('Elevation not ready after retries.', {
          hasData: !!hasData, hasPoints: !!hasPoints, hasStats: !!hasStats,
          hasCanvas: !!hasCanvas, hasProfile: !!hasProfile,
          pointsLen: hasData && currentElevationData.points ? currentElevationData.points.length : 0,
          canvasW: hasCanvas ? elevationCanvas.offsetWidth : null,
          canvasH: hasCanvas ? elevationCanvas.offsetHeight : null
        });
      }
      return;
    }

    // Ensure panel visible and not collapsed
    elevationProfile.classList.add('visible');
    elevationProfile.classList.remove('collapsed');
    elevationProfile.setAttribute('aria-hidden', 'false');

    // Ensure canvas has a non-zero size
    if (elevationCanvas && (elevationCanvas.offsetHeight === 0 || elevationCanvas.offsetWidth === 0)) {
      elevationCanvas.style.height = '240px';
      elevationCanvas.style.width = '100%';
    }

    // Render now
    if (typeof renderElevationProfile === 'function') {
      if (typeof fitElevationToViewport === 'function') fitElevationToViewport();
      renderElevationProfile();
      setTimeout(() => { if (typeof fitElevationToViewport === 'function') fitElevationToViewport(); renderElevationProfile(); }, 200);
    }
  } catch (e) {
    console.warn('ensureElevationRendered error:', e);
  }
}

// Re-render on resize as a safety net
window.addEventListener('resize', () => {
  if (typeof renderElevationProfile === 'function') {
    renderElevationProfile();
  }
});


// --- Responsive elevation canvas sizing ---
function resizeElevationCanvas() {
  if (!elevationCanvas || !elevationProfile) return;
  // Reserve a fraction of the viewport height while accounting for the panel header
  const viewportH = window.innerHeight || 800;
  const header = elevationProfile.querySelector('.elevation-header');
  const headerH = header ? header.offsetHeight : 48;
  // Target 28% of viewport, min 160px, max 420px
  const target = Math.max(160, Math.min(420, Math.floor(viewportH * 0.28)));
  // Apply height only if different to avoid layout thrash
  const targetPx = target + 'px';
  if (elevationCanvas.style.height !== targetPx) {
    elevationCanvas.style.height = targetPx;
  }
  elevationCanvas.style.width = '100%';
}

window.addEventListener('resize', () => {
  resizeElevationCanvas();
  if (typeof renderElevationProfile === 'function') {
    renderElevationProfile();
  }
});



// --- Viewport-aware elevation fit (strong) ---
function fitElevationToViewport() {
  try {
    if (typeof elevationProfile === 'undefined' || typeof elevationCanvas === 'undefined') return;
    if (!elevationProfile || !elevationCanvas) return;

    const rect = elevationProfile.getBoundingClientRect();
    const viewportH = window.innerHeight || document.documentElement.clientHeight || 800;

    // Account for bottom UI (dock, browser UI). Tune this if needed.
    const safeBottom = 40;
    let available = Math.floor(viewportH - rect.top - safeBottom);
    const minH = 180, maxH = 360; // tighter to avoid overflow

    if (!Number.isFinite(available) || available <= 0) available = 240;
    const target = Math.max(minH, Math.min(maxH, available));

    // Apply CSS size
    const targetPx = target + 'px';
    if (elevationCanvas.style.height !== targetPx) {
      elevationCanvas.style.height = targetPx;
    }
    elevationCanvas.style.width = '100%';

    // Sync intrinsic canvas size with DPR to avoid blurriness/clipping mismatch
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const cssW = elevationCanvas.clientWidth || elevationCanvas.offsetWidth || 800;
    const cssH = target;
    const wantW = Math.floor(cssW * dpr);
    const wantH = Math.floor(cssH * dpr);
    if (elevationCanvas.width !== wantW) elevationCanvas.width = wantW;
    if (elevationCanvas.height !== wantH) elevationCanvas.height = wantH;
  } catch (e) {
    console.warn('fitElevationToViewport error:', e);
  }
}

// (removed dynamic observers to prevent loops)
// === Elevation render scheduler (prevents tight loops) ===
let __elevRenderScheduled = false;
function scheduleElevationRender(reason) {
  try {
    if (__elevRenderScheduled) return;
    __elevRenderScheduled = true;
    requestAnimationFrame(() => {
      __elevRenderScheduled = false;
      if (typeof fitElevationToViewport === 'function') fitElevationToViewport();
      if (typeof renderElevationProfile === 'function') renderElevationProfile();
    });
  } catch (e) {
    console.warn('scheduleElevationRender error:', e);
    // Fallback direct render
    if (typeof renderElevationProfile === 'function') renderElevationProfile();
  }
}


// --- Minimal elevation canvas sizing (fixed height) ---
const ELEV_CANVAS_FIXED_H = 260; // px; change if you want bigger/smaller
function setElevationCanvasSize() {
  if (!window.elevationCanvas || !window.elevationProfile) return;
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const cssW = elevationProfile.clientWidth || elevationCanvas.parentElement?.clientWidth || elevationCanvas.clientWidth || 800;
  const cssH = ELEV_CANVAS_FIXED_H;
  elevationCanvas.style.width = '100%';
  elevationCanvas.style.height = cssH + 'px';
  const wantW = Math.max(1, Math.floor(cssW * dpr));
  const wantH = Math.max(1, Math.floor(cssH * dpr));
  if (elevationCanvas.width !== wantW) elevationCanvas.width = wantW;
  if (elevationCanvas.height !== wantH) elevationCanvas.height = wantH;
}


// --- Keep elevation container sized to canvas ---
function syncElevationContainer() {
  try {
    if (typeof elevationCanvas === 'undefined' || typeof elevationProfile === 'undefined') return;
    const content = document.getElementById('elevation-content');
    if (!content || !elevationCanvas) return;
    // Read actual canvas CSS height (not intrinsic pixels)
    const h = elevationCanvas.getBoundingClientRect().height;
    if (h && Math.abs((content.getBoundingClientRect().height || 0) - h) > 1) {
      content.style.height = h + 'px';
    }
  } catch (e) {
    console.warn('syncElevationContainer error:', e);
  }
}


// --- Canvas == parent size (with DPR) ---
function sizeCanvasToParent() {
  const parent = document.getElementById('elevation-content');
  const canvas = typeof elevationCanvas !== 'undefined' ? elevationCanvas : document.getElementById('elevation-canvas');
  if (!parent || !canvas) return;
  const rect = parent.getBoundingClientRect();
  // If parent is hidden/collapsed, skip (will be re-called later)
  if (!rect.width || !rect.height) return;

  // CSS size already set via width/height:100%; sync intrinsic pixels for crisp rendering
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const wantW = Math.max(1, Math.floor(rect.width * dpr));
  const wantH = Math.max(1, Math.floor(rect.height * dpr));
  if (canvas.width !== wantW) canvas.width = wantW;
  if (canvas.height !== wantH) canvas.height = wantH;
}

// Observe parent size changes
(function observeParentForCanvas(){
  try {
    const parent = document.getElementById('elevation-content');
    if (!parent) return;
    const ro = new ResizeObserver(() => sizeCanvasToParent());
    ro.observe(parent);
    // First sizing attempt
    sizeCanvasToParent();
  } catch (e) {
    console.warn('ResizeObserver not available or failed:', e);
    // Fallback: size once on load
    setTimeout(sizeCanvasToParent, 100);
  }
})();


// === PERSISTENCE WAYPOINTS — debounce & group hooks ===
if (typeof window.__saveWpTimer === 'undefined') window.__saveWpTimer = null;
function saveTraceDebounced(delay = 120) {
  if (typeof saveTraceToLocalStorage !== 'function') return;
  clearTimeout(window.__saveWpTimer);
  window.__saveWpTimer = setTimeout(() => {
    try { saveTraceToLocalStorage(); } catch(e) { console.warn(e); }
  }, delay);
}

function attachWaypointPersistence() {
  try {
    if (typeof waypointLayerGroup === 'undefined' || !waypointLayerGroup || typeof waypointLayerGroup.on !== 'function') return;
    waypointLayerGroup.off('layeradd', saveTraceDebounced);
    waypointLayerGroup.off('layerremove', saveTraceDebounced);
    waypointLayerGroup.on('layeradd', () => saveTraceDebounced());
    waypointLayerGroup.on('layerremove', () => saveTraceDebounced());
    // initial sync
    saveTraceDebounced(10);
  } catch (e) { console.warn('attachWaypointPersistence:', e); }
}

</script>
<script>
// --- Hotfix: éviter la récursion de __lsSetItem en fixant la méthode native ---
(function(){
  try {
    var __nativeSetItem = (Storage && Storage.prototype && Storage.prototype.setItem)
      ? Storage.prototype.setItem.bind(localStorage)
      : function(k,v){ localStorage.setItem(k, v); };
    // Version sûre : n'appelle jamais localStorage.setItem directement (qui pourrait être surchargé)
    window.__lsSetItem = function(key, value){
      try { __nativeSetItem(key, value); return true; }
      catch(e){ console.warn('Erreur setItem localStorage (safe):', e); return false; }
    };
  } catch(e){
    console.warn('Hotfix __lsSetItem init failed:', e);
  }
})();
</script>
<script>
// === Start/End markers for GPX trace ===
window.__TRACE_MARKERS__ = true; // guard flag
let startMarker = null;
let endMarker = null;

/** Centre la carte sur un point */
function centerOnPoint(lat, lng) {
  if (typeof map !== 'undefined' && map && map.setView) {
    map.setView([lat, lng], Math.max(map.getZoom(), 15));
  }
}

/** HTML du popup pour start/end */
function createTraceMarkerPopup(latlng, type, elevation) {
  const isStart = type === 'start';
  const icon = isStart ? '🟢' : '🏁';
  const title = isStart ? 'Départ' : 'Arrivée';
  const eleRow = (elevation !== null && Number.isFinite(elevation))
    ? `<div class="trace-marker-popup-row">
         <span class="trace-marker-popup-label">Altitude :</span>
         <span class="trace-marker-popup-value">${Math.round(elevation)} m</span>
       </div>` : '';
  return `
    <div class="trace-marker-popup">
      <div class="trace-marker-popup-header">
        <span style="font-size:1.5rem;">${icon}</span>
        <strong class="trace-marker-popup-title">${title}</strong>
      </div>
      <div class="trace-marker-popup-details">
        <div class="trace-marker-popup-row">
          <span class="trace-marker-popup-label">Latitude :</span>
          <span class="trace-marker-popup-value">${latlng.lat.toFixed(6)}°</span>
        </div>
        <div class="trace-marker-popup-row">
          <span class="trace-marker-popup-label">Longitude :</span>
          <span class="trace-marker-popup-value">${latlng.lng.toFixed(6)}°</span>
        </div>
        ${eleRow}
      </div>
      <button class="btn btn-primary btn-small trace-marker-popup-button"
              onclick="centerOnPoint(${latlng.lat}, ${latlng.lng})">
        <span aria-hidden="true">🎯</span> Centrer sur ce point
      </button>
    </div>`;
}

/** Crée un divIcon + marker (start/end) */
function createTraceMarker(latlng, type, elevation = null) {
  const isStart = type === 'start';
  const className = isStart ? 'trace-start-marker' : 'trace-end-marker';
  const label = isStart ? '🟢 Départ de la trace' : '🏁 Arrivée de la trace';
  const inner = `<div class="${className}-inner"><span class="${className}-icon">${isStart ? '🟢' : '🏁'}</span></div>`;
  const icon = L.divIcon({
    className, html: inner, iconSize: [32,32], iconAnchor: [16,16], popupAnchor: [0,-16]
  });
  const marker = L.marker(latlng, {
    icon, zIndexOffset: 2000, title: label, riseOnHover: true
  });
  marker.bindTooltip(label, { direction: 'top', offset: [0, -16] });
  marker.bindPopup(createTraceMarkerPopup(latlng, type, elevation), { maxWidth: 250, className: 'trace-marker-popup-container' });
  return marker;
}

/** Marqueur combiné pour boucle (départ = arrivée) */
function createCombinedMarker(latlng, elevation = null) {
  const icon = L.divIcon({
    className: 'trace-combined-marker',
    html: `<div class="trace-combined-marker-inner"><span class="trace-combined-marker-icon">🔄</span></div>`,
    iconSize: [32,32], iconAnchor: [16,16], popupAnchor: [0,-16]
  });
  const marker = L.marker(latlng, { icon, zIndexOffset: 2000, title: 'Départ/Arrivée (trace circulaire)', riseOnHover: true });
  marker.bindTooltip('🔄 Départ/Arrivée', { direction: 'top', offset: [0, -16] });
  const html = `
    <div class="trace-marker-popup">
      <div class="trace-marker-popup-header">
        <span style="font-size:1.5rem;">🔄</span>
        <strong class="trace-marker-popup-title">Départ/Arrivée</strong>
      </div>
      <div class="trace-marker-popup-details">
        <div class="trace-marker-popup-row"><span class="trace-marker-popup-label">Type :</span><span class="trace-marker-popup-value">Trace circulaire</span></div>
        <div class="trace-marker-popup-row"><span class="trace-marker-popup-label">Latitude :</span><span class="trace-marker-popup-value">${latlng.lat.toFixed(6)}°</span></div>
        <div class="trace-marker-popup-row"><span class="trace-marker-popup-label">Longitude :</span><span class="trace-marker-popup-value">${latlng.lng.toFixed(6)}°</span></div>
        ${Number.isFinite(elevation) ? `<div class="trace-marker-popup-row"><span class="trace-marker-popup-label">Altitude :</span><span class="trace-marker-popup-value">${Math.round(elevation)} m</span></div>` : ''}
      </div>
      <button class="btn btn-primary btn-small trace-marker-popup-button" onclick="centerOnPoint(${latlng.lat}, ${latlng.lng})">
        <span aria-hidden="true">🎯</span> Centrer sur ce point
      </button>
    </div>`;
  marker.bindPopup(html, { maxWidth: 250, className: 'trace-marker-popup-container' });
  return marker;
}

/** Extrait start/end (LineString ou MultiLineString) + alt */
function extractTraceEndpoints(geojson) {
  if (!geojson || !Array.isArray(geojson.features)) return null;
  const lineFeatures = geojson.features.filter(f => {
    const t = f?.geometry?.type;
    return t === 'LineString' || t === 'MultiLineString';
  });
  if (lineFeatures.length === 0) return null;

  let firstCoord = null, lastCoord = null;
  lineFeatures.forEach((feature) => {
    const g = feature.geometry, coords = g.coordinates;
    if (g.type === 'LineString') {
      if (!firstCoord && coords.length) firstCoord = coords[0];
      if (coords.length) lastCoord = coords[coords.length - 1];
    } else if (g.type === 'MultiLineString') {
      (coords || []).forEach(seg => {
        if (!firstCoord && seg.length) firstCoord = seg[0];
        if (seg.length) lastCoord = seg[seg.length - 1];
      });
    }
  });

  if (!firstCoord || !lastCoord) return null;
  const start = L.latLng(firstCoord[1], firstCoord[0]);
  const end   = L.latLng(lastCoord[1],  lastCoord[0]);
  const startEle = firstCoord.length > 2 ? firstCoord[2] : null;
  const endEle   = lastCoord.length  > 2 ? lastCoord[2]  : null;
  return { start, end, startEle, endEle };
}

/** Ajoute les marqueurs de départ/arrivée (ou combiné) */
function addTraceEndpointMarkers(geojson) {
  try {
    removeTraceEndpointMarkers();
    const endpoints = extractTraceEndpoints(geojson);
    if (!endpoints) return;
    const { start, end, startEle, endEle } = endpoints;
    if (typeof map === 'undefined' || !map) return;
    const isSamePoint = map.distance(start, end) < 10; // < 10 m => boucle
    if (isSamePoint) {
      startMarker = createCombinedMarker(start, startEle ?? endEle ?? null);
      startMarker.addTo(map);
    } else {
      startMarker = createTraceMarker(start, 'start', startEle);
      endMarker   = createTraceMarker(end,   'end',   endEle);
      startMarker.addTo(map);
      endMarker.addTo(map);
    }
  } catch(e) {
    console.warn('addTraceEndpointMarkers error:', e);
  }
}

/** Supprime les marqueurs s'ils existent */
function removeTraceEndpointMarkers() {
  try {
    if (typeof map !== 'undefined' && map) {
      if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
      if (endMarker)   { map.removeLayer(endMarker);   endMarker   = null; }
    } else {
      startMarker = null; endMarker = null;
    }
  } catch(e) {
    console.warn('removeTraceEndpointMarkers error:', e);
  }
}
</script>
<script>
// === Système générique de sections collapsibles ===
window.collapsibleSections = window.collapsibleSections || {};
const collapsibleSections = Object.assign(window.collapsibleSections, {
  mapStyle: {
    id: 'map-style-section',
    storageKey: 'gpx_map_style_section_expanded',
    defaultExpanded: false,
    section: null,
    toggle: null,
    content: null,
    isExpanded: false,
    boundToggleHandler: null,
    initialized: false
  },
  layers: {
    id: 'layers-section',
    storageKey: 'gpx_layers_section_expanded',
    defaultExpanded: true,
    section: null,
    toggle: null,
    content: null,
    isExpanded: true,
    boundToggleHandler: null,
    initialized: false
  },
  waypoints: {
    id: 'waypoints-section',
    storageKey: null,
    defaultExpanded: false,
    section: null,
    toggle: null,
    content: null,
    isExpanded: false,
    boundToggleHandler: null,
    initialized: false
  },
  roadbook: {
    id: 'roadbook-section',
    storageKey: null,
    defaultExpanded: false,
    section: null,
    toggle: null,
    content: null,
    isExpanded: false,
    boundToggleHandler: null,
    initialized: false
  }
});

function ensureSectionElements(config) {
  if (config.section && config.toggle && config.content) {
    return true;
  }
  config.section = document.getElementById(config.id);
  if (!config.section) {
    return false;
  }
  config.toggle = config.section.querySelector('.section-header-toggle');
  config.content = config.section.querySelector('.section-collapsible-content');
  return Boolean(config.toggle && config.content);
}

function saveSectionState(sectionKey, expanded) {
  const config = collapsibleSections[sectionKey];
  if (!config || !config.storageKey) {
    return;
  }
  try {
    localStorage.setItem(config.storageKey, JSON.stringify(expanded));
  } catch (error) {
    console.warn(`Impossible de sauvegarder l'état de "${sectionKey}":`, error);
  }
}

function loadSectionState(sectionKey) {
  const config = collapsibleSections[sectionKey];
  if (!config) {
    return false;
  }
  if (!config.storageKey) {
    return config.defaultExpanded;
  }
  try {
    const saved = localStorage.getItem(config.storageKey);
    if (saved === null) {
      return config.defaultExpanded;
    }
    return JSON.parse(saved);
  } catch (error) {
    console.warn(`Erreur lors du chargement de l'état de "${sectionKey}":`, error);
    return config.defaultExpanded;
  }
}

function handleSectionOpened(sectionKey) {
  if (sectionKey === 'mapStyle') {
    const refreshPreviews = window.__mapStylePreviews?.refresh;
    if (typeof refreshPreviews === 'function') {
      refreshPreviews();
    }
  }
}

function setSectionExpanded(sectionKey, expanded, animate = true) {
  const config = collapsibleSections[sectionKey];
  if (!config) {
    return;
  }
  if (!ensureSectionElements(config)) {
    return;
  }

  config.isExpanded = expanded;

  const applyState = () => {
    config.section.classList.toggle('expanded', expanded);
    config.toggle.setAttribute('aria-expanded', String(expanded));
  };

  if (!animate) {
    const previousTransition = config.content.style.transition;
    config.content.style.transition = 'none';
    applyState();
    requestAnimationFrame(() => {
      config.content.style.transition = previousTransition || '';
      if (expanded) {
        handleSectionOpened(sectionKey);
      }
    });
    return;
  }

  applyState();

  if (expanded) {
    setTimeout(() => handleSectionOpened(sectionKey), 350);
  }
}

function toggleSection(sectionKey) {
  const config = collapsibleSections[sectionKey];
  if (!config) {
    return;
  }
  const newState = !config.isExpanded;
  setSectionExpanded(sectionKey, newState, true);
  saveSectionState(sectionKey, newState);
}

function initCollapsibleSection(sectionKey) {
  const config = collapsibleSections[sectionKey];
  if (!config) {
    return;
  }

  if (!ensureSectionElements(config)) {
    config.initialized = false;
    return;
  }

  if (config.boundToggleHandler) {
    config.toggle.removeEventListener('click', config.boundToggleHandler);
  }

  config.isExpanded = loadSectionState(sectionKey);
  setSectionExpanded(sectionKey, config.isExpanded, false);

  config.boundToggleHandler = () => toggleSection(sectionKey);
  config.toggle.addEventListener('click', config.boundToggleHandler);
  config.initialized = true;
}

function initCollapsibleSections() {
  Object.keys(collapsibleSections).forEach((sectionKey) => {
    initCollapsibleSection(sectionKey);
  });
}

window.collapsibleSectionsAPI = {
  expand: (sectionKey) => {
    setSectionExpanded(sectionKey, true, true);
    saveSectionState(sectionKey, true);
  },
  collapse: (sectionKey) => {
    setSectionExpanded(sectionKey, false, true);
    saveSectionState(sectionKey, false);
  },
  toggle: (sectionKey) => toggleSection(sectionKey),
  isExpanded: (sectionKey) => {
    const config = collapsibleSections[sectionKey];
    return config ? Boolean(config.isExpanded) : false;
  },
  init: (sectionKey) => initCollapsibleSection(sectionKey)
};

document.addEventListener('DOMContentLoaded', initCollapsibleSections);
</script>
<script>
(function(){
  function initSidebarMapStyleSection(){
    var container = document.getElementById('map-style-section');
    if (!container) return;
    var buttons = Array.prototype.slice.call(container.querySelectorAll('.map-style-option'));
    if (!buttons.length) return;

    function setActive(id){
      buttons.forEach(function(b){
        if (b.getAttribute('data-style') === id) b.classList.add('active');
        else b.classList.remove('active');
      });
    }

    // Determine saved or default style
    var saved = null;
    try { saved = localStorage.getItem('gpx_map_style'); } catch(e) {}
    var styleId = (saved && saved.trim()) ? saved : 'voyager';

    // Apply on map immediately
    if (typeof changeMapStyle === 'function') {
      changeMapStyle(styleId);
    }
    // Reflect active button
    setActive(styleId);

    // Wire clicks
    buttons.forEach(function(btn){
      btn.addEventListener('click', function(){
        var id = btn.getAttribute('data-style');
        if (!id) return;
        if (typeof changeMapStyle === 'function'){ changeMapStyle(id); }
        setActive(id);
        try { localStorage.setItem('gpx_map_style', id); } catch(_) {}
      });
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initSidebarMapStyleSection);
  } else {
    initSidebarMapStyleSection();
  }
})();
</script>
<script>
// === Previews for map styles in sidebar (full-width + synced to main map) ===
(function(){
  var __previewMaps = {}; // styleId -> Leaflet map
  var __previewLayers = {}; // styleId -> array of tile layers

  function buildLayersFor(styleId){
    if (!window.mapStyles || !mapStyles[styleId]) return [];
    var style = mapStyles[styleId];
    if (style.layers) {
      return style.layers.map(function(ld){
        return L.tileLayer(ld.url, { maxZoom: ld.maxZoom, attribution: style.attribution || '' });
      });
    } else {
      return [ L.tileLayer(style.url, { maxZoom: style.maxZoom, attribution: style.attribution || '' }) ];
    }
  }

  function ensurePreview(styleId){
    var el = document.getElementById('map-thumb-' + styleId);
    if (!el || !window.L) return null;
    if (__previewMaps[styleId]) return __previewMaps[styleId];

    var mapPrev = L.map(el, {
      attributionControl: false,
      zoomControl: false,
      dragging: false,
      scrollWheelZoom: false,
      doubleClickZoom: false,
      boxZoom: false,
      keyboard: false,
      tap: false,
      touchZoom: false,
      inertia: false
    });

    var layers = buildLayersFor(styleId);
    __previewLayers[styleId] = layers;
    layers.forEach(function(ly){ ly.addTo(mapPrev); });

    // Default view will be adjusted by sync
    __previewMaps[styleId] = mapPrev;
    // Store a flag to avoid re-init
    el.dataset.inited = '1';
    return mapPrev;
  }

  function initPreviews(){
    var container = document.getElementById('map-style-section');
    if (!container) return;
    var thumbs = Array.prototype.slice.call(container.querySelectorAll('.map-style-thumb-inner'));
    thumbs.forEach(function(div){
      var id = div.id.replace('map-thumb-', '');
      if (!id) return;
      ensurePreview(id);
    });

    // Initial sync once main map exists
    if (window.map) {
      syncPreviewsToMain();
      // Listen to move/zoom to update previews
      map.on('moveend zoomend', syncPreviewsToMain);
    }

    // Invalidate size on resize to avoid clipped tiles
    window.addEventListener('resize', function(){
      Object.keys(__previewMaps).forEach(function(k){
        __previewMaps[k].invalidateSize();
      });
    });
  }

  function syncPreviewsToMain(){
    if (!window.map) return;
    var center = map.getCenter();
    var zoom = map.getZoom();
    Object.keys(__previewMaps).forEach(function(k){
      var m = __previewMaps[k];
      // Keep it snappy; avoid animation to not feel laggy
      m.setView(center, zoom, { animate: false });
      m.invalidateSize();
    });
  }

  // If the user switches panel visibility or styles, refresh sizes
  function refreshPreviewsLayout(){
    Object.keys(__previewMaps).forEach(function(k){
      __previewMaps[k].invalidateSize();
    });
    syncPreviewsToMain();
  }

  // Rebuild layers for a preview if needed (e.g., style definitions changed)
  function refreshPreviewLayers(styleId){
    var m = __previewMaps[styleId];
    if (!m) return;
    // remove old layers
    if (__previewLayers[styleId]) {
      __previewLayers[styleId].forEach(function(ly){ m.removeLayer(ly); });
    }
    var layers = buildLayersFor(styleId);
    __previewLayers[styleId] = layers;
    layers.forEach(function(ly){ ly.addTo(m); });
    m.invalidateSize();
  }

  // Hook into sidebar’s button clicks to refresh highlight and previews layout
  document.addEventListener('click', function(e){
    var btn = e.target.closest && e.target.closest('#map-style-section .map-style-option');
    if (!btn) return;
    setTimeout(refreshPreviewsLayout, 0);
  });

  // Observe DOM changes inside map-style-section (accordion toggles etc.)
  var obs;
  function observeSection(){
    var sec = document.getElementById('map-style-section');
    if (!sec) return;
    if (obs) { try { obs.disconnect(); } catch(_){} }
    obs = new MutationObserver(function(){ setTimeout(refreshPreviewsLayout, 0); });
    obs.observe(sec, { childList: true, subtree: true, attributes: true });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      initPreviews();
      observeSection();
    });
  } else {
    initPreviews();
    observeSection();
  }

  // Expose minimal API if needed
  window.__mapStylePreviews = {
    refresh: refreshPreviewsLayout,
    refreshLayers: refreshPreviewLayers
  };
})();
</script>

<!-- ==================== FOOTER SEO (masqué visuellement) ==================== -->
<footer id="seo-footer" style="position:absolute;left:-9999px;width:1px;height:1px;overflow:hidden;" aria-hidden="true">
  <h2>À propos de Cycling Companion</h2>
  <p>
    <strong>Cycling Companion</strong> est un outil gratuit et <strong>open source</strong> de planification 
    d'itinéraires pour le <strong>bikepacking</strong> et le <strong>cyclotourisme</strong>. 
    Développé par <a href="https://lamouche.fr" rel="author">Benoit Lamouche</a> 
    (<a href="https://twitter.com/blamouche" rel="author">@blamouche</a>), cet outil 
    vous permet d'importer vos <strong>traces GPX</strong>, de visualiser le 
    <strong>profil d'élévation</strong> avec statistiques détaillées (dénivelé positif D+, 
    dénivelé négatif D-, distance totale), d'ajouter des <strong>waypoints personnalisés</strong> 
    et de trouver facilement les <strong>points d'intérêt essentiels</strong> pour vos aventures à vélo.
  </p>
  
  <h3>Fonctionnalités principales pour le bikepacking</h3>
  <ul>
    <li><strong>Import et export GPX</strong> : Compatibilité totale avec Komoot, Strava, Garmin, Wahoo, Suunto</li>
    <li><strong>Profil d'élévation interactif</strong> : Visualisez le dénivelé en temps réel avec votre souris</li>
    <li><strong>Gestion de waypoints</strong> : Créez des points d'étape avec noms personnalisables</li>
    <li><strong>Roadbook automatique</strong> : Générez un carnet de route détaillé avec distances cumulées et D+ restant</li>
    <li><strong>Recherche de POI</strong> : Trouvez eau potable, nourriture, hébergement, réparation vélo</li>
    <li><strong>Multiples fonds de carte</strong> : CyclOSM (optimisée cyclisme), OpenStreetMap, OpenTopoMap (relief), vue satellite Esri</li>
    <li><strong>Géolocalisation GPS</strong> : Suivez votre position en temps réel sur la trace</li>
    <li><strong>Sauvegarde automatique</strong> : Vos données restent privées, stockées localement dans votre navigateur</li>
    <li><strong>100% gratuit</strong> : Aucune inscription, aucune publicité, code open source sur GitHub</li>
    <li><strong>Application web progressive (PWA)</strong> : Installez l'app sur votre téléphone et utilisez-la hors ligne</li>
  </ul>

  <h3>Points d'intérêt pour cyclotouristes et bikepackers</h3>
  <p>
    Localisez facilement tous les services essentiels le long de votre parcours cycliste :
  </p>
  <ul>
    <li><strong>Eau potable</strong> : Fontaines publiques, points d'eau, cimetières (robinets d'eau gratuits)</li>
    <li><strong>Alimentation</strong> : Supermarchés, épiceries, boulangeries, restaurants, cafés, fast-food</li>
    <li><strong>Hébergement outdoor</strong> : Campings, bivouacs autorisés, zones de camping sauvage, refuges montagne, refuges alpins</li>
    <li><strong>Hébergement confort</strong> : Hôtels, auberges de jeunesse, chambres d'hôtes, gîtes</li>
    <li><strong>Services vélo</strong> : Stations de réparation self-service, magasins de cycles, vélocistes</li>
    <li><strong>Hygiène et sanitaires</strong> : Toilettes publiques, douches, blocs sanitaires</li>
    <li><strong>Santé</strong> : Pharmacies, hôpitaux, centres médicaux</li>
    <li><strong>Patrimoine</strong> : Cimetières (point d'eau), monuments historiques</li>
  </ul>

  <h3>Pour qui ?</h3>
  <p>
    Cycling Companion s'adresse à tous les passionnés de <strong>voyage à vélo</strong> :
  </p>
  <ul>
    <li><strong>Bikepackers</strong> solos ou en groupe préparant des aventures multi-jours</li>
    <li><strong>Cyclotouristes</strong> longue distance planifiant des itinéraires à travers la France et l'Europe</li>
    <li><strong>Gravel riders</strong> cherchant des parcours mixtes route/chemin</li>
    <li><strong>Vététistes en itinérance</strong> explorant les sentiers et single tracks</li>
    <li><strong>Cyclistes ultra-distance</strong> (audax, brevets, ultra-cycling)</li>
    <li><strong>Voyageurs à vélo</strong> préparant des week-ends bikepacking ou des vacances cyclistes</li>
    <li><strong>Organisateurs de randonnées</strong> cyclosportives ou événements vélo</li>
  </ul>

  <h3>Cas d'usage typiques</h3>
  <ul>
    <li>Préparer un voyage bikepacking de plusieurs jours avec étapes quotidiennes</li>
    <li>Planifier un itinéraire cyclotourisme à travers les véloroutes européennes (EuroVelo)</li>
    <li>Repérer les points d'eau et de ravitaillement sur un parcours gravel</li>
    <li>Calculer le dénivelé total et anticiper les difficultés d'un parcours montagne</li>
    <li>Trouver des campings et bivouacs le long d'un itinéraire</li>
    <li>Exporter une trace GPX enrichie avec waypoints pour son GPS Garmin, Wahoo ou Sigma</li>
    <li>Partager un itinéraire détaillé avec roadbook à ses compagnons de voyage</li>
  </ul>

  <h3>Technologies et données ouvertes</h3>
  <p>
    Application web responsive et moderne basée sur <strong>Leaflet.js</strong> pour la cartographie interactive 
    et les données libres <strong>OpenStreetMap</strong>. Points d'intérêt fournis en temps réel par 
    <strong>Overpass API</strong>. Multiples fonds de carte disponibles : 
  </p>
  <ul>
    <li><strong>CyclOSM</strong> : Carte optimisée pour le cyclisme avec pistes cyclables, véloroutes et voies vertes</li>
    <li><strong>OpenStreetMap</strong> : Carte standard collaborative mondiale</li>
    <li><strong>OpenTopoMap</strong> : Carte topographique avec courbes de niveau et relief</li>
    <li><strong>Esri Satellite</strong> : Imagerie satellite haute résolution</li>
    <li><strong>Esri Hybrid</strong> : Satellite avec labels et noms de lieux</li>
  </ul>
  <p>
    Compatible avec tous les navigateurs modernes (Chrome, Firefox, Safari, Edge) sur mobile, tablette et desktop. 
    Interface optimisée pour écrans tactiles. Application web progressive installable sur iOS et Android.
  </p>

  <h3>Open Source et contributions</h3>
  <p>
    Code source disponible sur 
    <a href="https://github.com/blamouche/bikepacking-gpx-manager" target="_blank" rel="noopener">
      GitHub
    </a>. 
    Contributions, suggestions et rapports de bugs sont les bienvenus ! Licence MIT.
  </p>
  
  <h3>Compatibilité GPS et applications</h3>
  <p>
    Les fichiers GPX exportés sont compatibles avec :
  </p>
  <ul>
    <li><strong>GPS de vélo</strong> : Garmin Edge, Wahoo ELEMNT, Sigma ROX, Bryton, Hammerhead Karoo</li>
    <li><strong>Montres GPS</strong> : Garmin Fenix, Suunto, Polar, Coros</li>
    <li><strong>Smartphones</strong> : Komoot, Strava, Ride with GPS, ViewRanger, OruxMaps</li>
    <li><strong>Applications web</strong> : Strava Routes, Komoot, Ride with GPS, Bikemap</li>
  </ul>

  <h3>Données et confidentialité</h3>
  <p>
    Cycling Companion respecte votre vie privée. Aucune donnée personnelle n'est collectée ou envoyée 
    à un serveur externe. Vos traces GPX et waypoints sont sauvegardés uniquement dans le stockage local 
    de votre navigateur (localStorage). Aucun compte utilisateur requis. Aucun cookie de tracking. 
    Application conforme RGPD.
  </p>

  <h3>Mots-clés et recherche</h3>
  <p>
    bikepacking, cyclotourisme, trace GPX, profil altimétrique, dénivelé positif, dénivelé négatif, 
    waypoints, roadbook vélo, planification itinéraire vélo, carte cyclable, points d'intérêt vélo, 
    eau potable vélo, bivouac vélo, camping vélo, gravel bike, voyage à vélo, ultra-cycling, 
    randonneur cycliste, cyclosportif, véloroute, voie verte, EuroVelo, grande traversée VTT, 
    OpenStreetMap, CyclOSM, Leaflet, application web progressive, PWA vélo, GPS vélo, 
    Garmin GPX, Komoot alternative, Strava route planner, Ride with GPS alternative
  </p>

  <p>
    <small>
      Données cartographiques © <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a> | 
      CyclOSM © <a href="https://www.cyclosm.org/">CyclOSM</a> | 
      Esri Imagery © <a href="https://www.esri.com/">Esri</a> |
      Développé par <a href="https://lamouche.fr">Benoit Lamouche</a> | 
      Twitter: <a href="https://twitter.com/blamouche">@blamouche</a> | 
      Code source: <a href="https://github.com/blamouche/bikepacking-gpx-manager">GitHub</a>
    </small>
  </p>
</footer>

<!-- ==================== SERVICE WORKER REGISTRATION (PWA) ==================== -->
<script>
  // Enregistrement du Service Worker pour fonctionnalité PWA
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register('/bikepacking-gpx-manager/sw.js')
        .then((registration) => {
          console.log('✅ Service Worker enregistré:', registration.scope);
          
          // Vérifier les mises à jour périodiquement
          setInterval(() => {
            registration.update();
          }, 60 * 60 * 1000); // Toutes les heures
        })
        .catch((error) => {
          console.log('❌ Échec enregistrement Service Worker:', error);
        });
      
      // Gérer les mises à jour du Service Worker
      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (!refreshing) {
          refreshing = true;
          window.location.reload();
        }
      });
    });
  }
</script>
</body>
</html>
